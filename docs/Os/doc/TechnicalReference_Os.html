---
layout: default
title: TechnicalReference_Os
nav_order: 3
parent: OS
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR OS </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 2.12.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Anton </p>
<p>Schmukel, </p>
<p>Ivan </p>
<p>Begert, </p>
<p>Stefano </p>
<p>Simoncelli, </p>
<p>Torsten  Schmidt,  Da  He,  David  Feuerstein,  Michael </p>
<p>Kock,  Martin  Schultheiß,  Andreas  Jehl,  Fabian  Wild, </p>
<p>Senol Cendere, Benjamin Seifert </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>2 </p>
<p>based on template version 6.0.1 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Torsten Schmidt </p>
<p>2016-04-27 </p>
<p>1.0.0 </p>
<p>First release version </p>
<p>Torsten Schmidt </p>
<p>2016-05-18 </p>
<p>1.0.1 </p>
<p>References to hardware manuals added. </p>
<p>Revision work </p>
<p>Torsten Schmidt </p>
<p>2016-06-03 </p>
<p>1.0.2 </p>
<p>Fix of ESCAN00089598 </p>
<p>Torsten Schmidt </p>
<p>2016-06-20 </p>
<p>1.1.0 </p>
<p>List of OS internal objects added. </p>
<p>Additional startup concept chapter added. </p>
<p>Chapter “Memory mapping concept” reworked. </p>
<p>Description of “generate callout stubs” feature </p>
<p>added. </p>
<p>Torsten Schmidt </p>
<p>2016-07-05 </p>
<p>1.1.1 </p>
<p>Chapter “Memory Mapping Concept” extended. </p>
<p>IOC notification callback concept changed. </p>
<p>HSI of RH850 family added. </p>
<p>HSI of Power PC family added. </p>
<p>Torsten Schmidt </p>
<p>2016-07-19 </p>
<p>1.1.2 </p>
<p>Chapter “Memory Mapping Concept” changed. </p>
<p>Hints for shorter compile times added. </p>
<p>Nesting behavior of OS hooks described. </p>
<p>Ivan Begert </p>
<p>2016-08-11 </p>
<p>1.1.3 </p>
<p>HSI of ARM family added. </p>
<p>Torsten Schmidt </p>
<p>2016-08-12 </p>
<p>1.1.4 </p>
<p>Chapter “Memory Mapping Concept” extended. </p>
<p>Chapter “Clear Pending Interrupt” extended. </p>
<p>Chapter “RH850 Special Characteristics” extended. </p>
<p>Ivan Begert </p>
<p>2016-08-18 </p>
<p>1.1.5 </p>
<p>HSI of ARM Zynq UltraScale added. </p>
<p>Torsten Schmidt </p>
<p>2016-08-30 </p>
<p>1.1.6 </p>
<p>HSI of RH850 extended. </p>
<p>Torsten Schmidt </p>
<p>2016-08-31 </p>
<p>1.1.7 </p>
<p>ORTI Debugging added. </p>
<p>Timing Hook Macros reworked. </p>
<p>Chapter “Memory Mapping Concept” changed. </p>
<p>Chapter “Category 1 Interrupts” extended. </p>
<p>Stefano Simoncelli </p>
<p>Torsten Schmidt </p>
<p>2016-09-15 </p>
<p>1.1.8 </p>
<p>Chapter “Interrupt Source API” extended. </p>
<p>HSI chapter for ARM extended </p>
<p>Torsten Schmidt </p>
<p>2016-09-22 </p>
<p>1.2.0 </p>
<p>VTT OS and Dual Target Concept added. </p>
<p>Chapter ORTI Debugging extended. </p>
<p>Anton Schmukel </p>
<p>Da He </p>
<p>2016-10-14 </p>
<p>1.3.0 </p>
<p>Ristrictions concerning API usage before StartOS() </p>
<p>documented. </p>
<p>Clarification concerning forcible termination and </p>
<p>schedule tables added. </p>
<p>Deviations in IOC added. </p>
<p>Notes on mixed criticality systems added. </p>
<p>Chapter “RH850 Special Characteristics” extended. </p>
<p>Torsten Schmidt </p>
<p>2016-10-19 </p>
<p>1.3.1 </p>
<p>Chapter “Configuration of X-Signals” added. </p>
<p>Chapter “Power PC Special Characteristics” </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>3 </p>
<p>based on template version 6.0.1 </p>
<p>extended. </p>
<p>Correction of startup examples. </p>
<p>Chapter “User include files” added. </p>
<p>RH850 HSI extended. </p>
<p>PPC HSI extended. </p>
<p>Hardware Overview extended by RH850. </p>
<p>David Feuerstein </p>
<p>2016-11-03 </p>
<p>1.4.0 </p>
<p>PPC HSI extended. </p>
<p>Chapter ORTI Debugging extended. </p>
<p>Michael Kock </p>
<p>2016-11-25 </p>
<p>1.5.0 </p>
<p>Updated chapter Timing Hooks </p>
<p>Martin Schultheiß </p>
<p>2016-12-08 </p>
<p>1.6.0 </p>
<p>PPC HSI extended. </p>
<p>Updated characteristics of VTT OS. </p>
<p>David Feuerstein </p>
<p>Andreas Jehl </p>
<p>Ivan Begert </p>
<p>Stefano Simoncelli </p>
<p>2016-12-22 </p>
<p>1.7.0 </p>
<p>Updated precautions in PreStartTask. </p>
<p>Support new Power PC Derivative: PC580003 </p>
<p>Support IAR compiler for ARM </p>
<p>ARM Cortex-A HSI added </p>
<p>David Feuerstein </p>
<p>Torsten Schmidt </p>
<p>2017-01-23 </p>
<p>1.8.0 </p>
<p>Chapter “Memory Mapping Concept” changed. </p>
<p>Chapter “Resulting sections” extended. </p>
<p>Chapter “X-Signals” extended. </p>
<p>Chapter “API Description” extended. </p>
<p>Torsten Schmidt </p>
<p>Stefano Simoncelli </p>
<p>David Feuerstein </p>
<p>2017-02-06 </p>
<p> </p>
<p>2.0.0 </p>
<p>Chapter “Memory Mapping Concept” corrected. </p>
<p>Chapter “MICROSAR OS Deviations from </p>
<p>AUTOSAR OS Specification” extended. </p>
<p>Chapter “IOC” extended. </p>
<p>Feature “Fast Trusted Functions” added. </p>
<p>Chapter “Non-Trusted Functions (NTF)” changed. </p>
<p>ARM Cortex-M Hardware overview updated. </p>
<p>Feature “Barriers” added. </p>
<p>Martin Schultheiß </p>
<p>Benjamin Seifert </p>
<p>Da He </p>
<p>Torsten Schmidt </p>
<p>Stefano Simoncelli </p>
<p>Anton Schmukel </p>
<p>2017-03-22 </p>
<p>2.1.0 </p>
<p>Updated Hardware Overview for Power PC </p>
<p>derivative groups (RM revisions). </p>
<p>Chapter “MICROSAR OS Deviations from </p>
<p>AUTOSAR OS Specification” corrected. </p>
<p>Added API </p>
<p>OSError_GetScheduleTableStatus_ScheduleStatus </p>
<p>Chapter “ARM Special characteristic” extended. </p>
<p>Chapter “Cortex-R derivatives” extended. </p>
<p>Chapter “Idle Task” extended. </p>
<p>TI Compiler added as supported compiler for ARM. </p>
<p>Platform POSIX added </p>
<p>Added HSI for ARM Cortext-M </p>
<p>Fabian Wild </p>
<p>Stefano Simoncelli </p>
<p>2017-03-31 </p>
<p>2.2.0 </p>
<p>Added AUTOSAR specification deviations. </p>
<p>Changed address parameter type in periperal API </p>
<p>functions. </p>
<p>Da He </p>
<p>Martin Schultheiß </p>
<p>2017-04-11 </p>
<p>2.3.0 </p>
<p>Added HSI for TI AR16xx </p>
<p>Added information for Hardware Init Core </p>
<p>Senol Cendere </p>
<p>Torsten Schmidt </p>
<p>2017-05-10 </p>
<p>2.4.0 </p>
<p>Added HSI for R-Car H3. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>4 </p>
<p>based on template version 6.0.1 </p>
<p>Martin Schultheiß </p>
<p>Da He </p>
<p>Extended chapter “Memory Mapping Concept”. </p>
<p>Added chapter “Linking of Spinlocks”. </p>
<p>Updated HSI for S32K derivatives. </p>
<p>Added chapter for exception context manipulation </p>
<p>Fabian Wild </p>
<p>Martin Schultheiß </p>
<p>2017-06-19 </p>
<p>2.5.0 </p>
<p>Removed ORTI tracing from Os_Init and </p>
<p>Os_InitMemory </p>
<p>Support new Power PC Derivative: SPC574Sxx </p>
<p>Torsten Schmidt </p>
<p>2017-06-06 </p>
<p>2.6.0 </p>
<p>Added descriptions for category 0 ISRs. </p>
<p>Ivan Begert </p>
<p>Senol Cendere </p>
<p>2017-07-05 </p>
<p>2.6.1 </p>
<p>Chapter “ARM Special characteristic” extended. </p>
<p>RH850 HSI extended. </p>
<p>Updated Table 1-9 Supported RH850 Compilers. </p>
<p>Updated Chapter 4.5.2 RH850 </p>
<p>Torsten Schmidt </p>
<p>2017-07-17 </p>
<p>2.7.0 </p>
<p>Chapter “Software Stack Check” extended. </p>
<p>Chapter “VTT OS Specifics” extended. </p>
<p>Chapter “Initialization of Interrupt Sources” </p>
<p>extended. </p>
<p>Chapter “Notes on Category 1 ISRs” extended. </p>
<p>Chapter “Notes on Category 0 ISRs” extended. </p>
<p>Chapter “Pre-Process Linker Command Files” </p>
<p>added. </p>
<p>API description of “Os_Init” extended. </p>
<p>Senol Cendere </p>
<p>Da He </p>
<p>Andreas Jehl </p>
<p>2017-08-15 </p>
<p>2.8.0 </p>
<p>Documented support for more RH850 derivatives </p>
<p>and compiler versions. </p>
<p>Updated documentations regarding location of OS </p>
<p>identifiers. </p>
<p>Support ARM CC (5.x) compiler for ARM Cortex-M </p>
<p>Documented support of TC39x derivative with </p>
<p>Tasking v6.0r1p2 compiler </p>
<p>Martin Schultheiß </p>
<p>2017-08-17 </p>
<p>2.9.0 </p>
<p>Updated Derivative Support for PPC and RH850 </p>
<p>Senol Cendere </p>
<p>Torsten Schmidt </p>
<p>Rainer </p>
<p>Künnemeyer </p>
<p>2017-10-25 </p>
<p>2.10.0 </p>
<p>New vector timing hooks </p>
<p>OS_VTHACTIVATION_LIMIT and </p>
<p>OS_VTH_WAITEVENT_NOWAIT, usage of vector </p>
<p>timing hooks now also in safety systems. Chapter </p>
<p>“Task Stack Sharing” Extended </p>
<p>Added comments on RTE interrupt API </p>
<p>Da He </p>
<p>Benjamin Seifert </p>
<p>2017-11-13 </p>
<p>2.11.0 </p>
<p>Support GCC Linaro compiler for ARM Cortex-A/R </p>
<p>and Cortex-M </p>
<p>Added HighTec compiler support for PowerPC and </p>
<p>TriCore </p>
<p>Added MPC56xx derivatives to chapter “Hardware </p>
<p>Overview” and “Hardware Software Interfaces” </p>
<p>Fixed Timing Hooks API descriptions </p>
<p>Stefano Simoncelli </p>
<p>Torsten Schmidt </p>
<p>Benjamin Seifert </p>
<p>2017-12-14 </p>
<p>2.12.00 </p>
<p>Support for TDA2x family derivatives  </p>
<p>Support for TriCore Aurix TC38x </p>
<p>Added caution to chapter “Aurix Special </p>
<p>Characteristics </p>
<p>Fixed descriptions in chapter &quot;Os generated </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>5 </p>
<p>based on template version 6.0.1 </p>
<p>objects&quot; </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>6 </p>
<p>based on template version 6.0.1 </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Source </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR </p>
<p>Specification of Operating System </p>
<p>Document ID 034:  AUTOSAR_SWS_OS </p>
<p>4.2.1 </p>
<p>[2] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK/VDX Operating System Specification </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2.3 </p>
<p>[3] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK RunTime Interface (ORTI) Part A: </p>
<p>Language Specification. </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2 </p>
<p>[4] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK Run Time Interface (ORTI) Part B: OSEK </p>
<p>Objects and Attributes </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2 </p>
<p>[5] </p>
<p> </p>
<p>Lauterbach </p>
<p>ORTI Representation of SMP Systems (ORTI </p>
<p>2.3) </p>
<p>4 </p>
<p>[6] </p>
<p> </p>
<p>Vector </p>
<p>vVIRTUALtarget Technical Reference </p>
<p>See delivery </p>
<p>information </p>
<p>[7] </p>
<p> </p>
<p>Vector </p>
<p>Startup with Vector and vVIRTUALtarget </p>
<p>See delivery </p>
<p>information </p>
<p>[8] </p>
<p> </p>
<p>Vector </p>
<p>MICROSAR VStdLib Technical Reference </p>
<p>TechnicalReference_VStdLib_GenericAsr.pdf </p>
<p>See delivery </p>
<p>information </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>7 </p>
<p>based on template version 6.0.1 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 24</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 24</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Abstract ........................................................................................................... 25</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Characteristics ................................................................................................. 25</p>
<p> </p>
<p>1.4</p>
<p> </p>
<p>Hardware Overview ......................................................................................... 26</p>
<p> </p>
<p>1.4.1</p>
<p> </p>
<p>TriCore Aurix .................................................................................... 27</p>
<p> </p>
<p>1.4.2</p>
<p> </p>
<p>Power PC ......................................................................................... 28</p>
<p> </p>
<p>1.4.3</p>
<p> </p>
<p>ARM ................................................................................................. 30</p>
<p> </p>
<p>1.4.4</p>
<p> </p>
<p>RH850.............................................................................................. 32</p>
<p> </p>
<p>1.4.5</p>
<p> </p>
<p>VTT OS ............................................................................................ 33</p>
<p> </p>
<p>1.4.5.1</p>
<p> </p>
<p>Characteristics of VTT OS ............................................. 33</p>
<p> </p>
<p>1.4.6</p>
<p> </p>
<p>POSIX OS ........................................................................................ 33</p>
<p> </p>
<p>1.4.6.1</p>
<p> </p>
<p>Characteristic of POSIX OS ........................................... 34</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 35</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>General ............................................................................................................ 35</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>MICROSAR OS Deviations from AUTOSAR OS Specification ......................... 35</p>
<p> </p>
<p>2.2.1</p>
<p> </p>
<p>Generic Deviation for API Functions ................................................. 35</p>
<p> </p>
<p>2.2.2</p>
<p> </p>
<p>Trusted Function API Deviations ...................................................... 35</p>
<p> </p>
<p>2.2.3</p>
<p> </p>
<p>Service Protection Deviation ............................................................ 36</p>
<p> </p>
<p>2.2.4</p>
<p> </p>
<p>Code Protection ............................................................................... 36</p>
<p> </p>
<p>2.2.5</p>
<p> </p>
<p>SyncScheduleTable API Deviation ................................................... 36</p>
<p> </p>
<p>2.2.6</p>
<p> </p>
<p>CheckTask/ISRMemoryAccess API Deviation .................................. 37</p>
<p> </p>
<p>2.2.7</p>
<p> </p>
<p>Interrupt API Deviation ..................................................................... 37</p>
<p> </p>
<p>2.2.8</p>
<p> </p>
<p>Cross Core Getter APIs .................................................................... 37</p>
<p> </p>
<p>2.2.9</p>
<p> </p>
<p>IOC .................................................................................................. 38</p>
<p> </p>
<p>2.2.10</p>
<p> </p>
<p>Return value upon stack violation ..................................................... 38</p>
<p> </p>
<p>2.2.11</p>
<p> </p>
<p>Handling of OS internal errors .......................................................... 39</p>
<p> </p>
<p>2.2.12</p>
<p> </p>
<p>Forcible Termination of Applications ................................................. 39</p>
<p> </p>
<p>2.2.13</p>
<p> </p>
<p>OS Configuration ............................................................................. 40</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>Stack Concept ................................................................................................. 41</p>
<p> </p>
<p>2.3.1</p>
<p> </p>
<p>Task Stack Sharing .......................................................................... 42</p>
<p> </p>
<p>2.3.1.1</p>
<p> </p>
<p>Description ..................................................................... 42</p>
<p> </p>
<p>2.3.1.2</p>
<p> </p>
<p>Activation ....................................................................... 42</p>
<p> </p>
<p>2.3.1.3</p>
<p> </p>
<p>Usage ............................................................................ 43</p>
<p> </p>
<p>2.3.2</p>
<p> </p>
<p>ISR Stack Sharing ............................................................................ 43</p>
<p> </p>
<p>2.3.2.1</p>
<p> </p>
<p>Description ..................................................................... 43</p>
<p> </p>
<p>2.3.2.2</p>
<p> </p>
<p>Activation ....................................................................... 43</p>
<p> </p>
<p>2.3.2.3</p>
<p> </p>
<p>Usage ............................................................................ 44</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>8 </p>
<p>based on template version 6.0.1 </p>
<p>2.3.3</p>
<p> </p>
<p>Stack Check Strategy ....................................................................... 44</p>
<p> </p>
<p>2.3.4</p>
<p> </p>
<p>Software Stack Check ...................................................................... 44</p>
<p> </p>
<p>2.3.4.1</p>
<p> </p>
<p>Description ..................................................................... 44</p>
<p> </p>
<p>2.3.4.2</p>
<p> </p>
<p>Activation ....................................................................... 45</p>
<p> </p>
<p>2.3.4.3</p>
<p> </p>
<p>Usage ............................................................................ 45</p>
<p> </p>
<p>2.3.5</p>
<p> </p>
<p>Stack Supervision by MPU ............................................................... 46</p>
<p> </p>
<p>2.3.5.1</p>
<p> </p>
<p>Description ..................................................................... 46</p>
<p> </p>
<p>2.3.5.2</p>
<p> </p>
<p>Activation ....................................................................... 46</p>
<p> </p>
<p>2.3.5.3</p>
<p> </p>
<p>Usage ............................................................................ 46</p>
<p> </p>
<p>2.3.6</p>
<p> </p>
<p>Stack Usage Measurement .............................................................. 47</p>
<p> </p>
<p>2.3.6.1</p>
<p> </p>
<p>Description ..................................................................... 47</p>
<p> </p>
<p>2.3.6.2</p>
<p> </p>
<p>Activation ....................................................................... 47</p>
<p> </p>
<p>2.3.6.3</p>
<p> </p>
<p>Usage ............................................................................ 47</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>Interrupt Concept ............................................................................................. 48</p>
<p> </p>
<p>2.4.1</p>
<p> </p>
<p>Interrupt Handling API ...................................................................... 48</p>
<p> </p>
<p>2.4.2</p>
<p> </p>
<p>Interrupt Levels ................................................................................ 48</p>
<p> </p>
<p>2.4.3</p>
<p> </p>
<p>Interrupt Vector Table ....................................................................... 49</p>
<p> </p>
<p>2.4.4</p>
<p> </p>
<p>Nesting of Category 2 Interrupts....................................................... 49</p>
<p> </p>
<p>2.4.4.1</p>
<p> </p>
<p>Description ..................................................................... 49</p>
<p> </p>
<p>2.4.4.2</p>
<p> </p>
<p>Activation ....................................................................... 49</p>
<p> </p>
<p>2.4.5</p>
<p> </p>
<p>Category 1 Interrupts ....................................................................... 49</p>
<p> </p>
<p>2.4.5.1</p>
<p> </p>
<p>Implementation of Category 1 ISRs ............................... 49</p>
<p> </p>
<p>2.4.5.2</p>
<p> </p>
<p>Nesting of Category 1 ISRs ............................................ 49</p>
<p> </p>
<p>2.4.5.3</p>
<p> </p>
<p>Category 1 ISRs before StartOS .................................... 50</p>
<p> </p>
<p>2.4.5.4</p>
<p> </p>
<p>Notes on Category 1 ISRs ............................................. 50</p>
<p> </p>
<p>2.4.6</p>
<p> </p>
<p>Initialization of Interrupt Sources ...................................................... 51</p>
<p> </p>
<p>2.4.7</p>
<p> </p>
<p>Unhandled Interrupts ........................................................................ 52</p>
<p> </p>
<p>2.5</p>
<p> </p>
<p>Exception Concept ........................................................................................... 53</p>
<p> </p>
<p>2.5.1</p>
<p> </p>
<p>Exception Vector Table ..................................................................... 53</p>
<p> </p>
<p>2.5.2</p>
<p> </p>
<p>Unhandled Exceptions ..................................................................... 53</p>
<p> </p>
<p>2.6</p>
<p> </p>
<p>Timer Concept ................................................................................................. 54</p>
<p> </p>
<p>2.6.1</p>
<p> </p>
<p>Description ....................................................................................... 54</p>
<p> </p>
<p>2.6.2</p>
<p> </p>
<p>Activation ......................................................................................... 54</p>
<p> </p>
<p>2.6.3</p>
<p> </p>
<p>Usage .............................................................................................. 54</p>
<p> </p>
<p>2.6.4</p>
<p> </p>
<p>Dependencies .................................................................................. 54</p>
<p> </p>
<p>2.7</p>
<p> </p>
<p>Periodical Interrupt Timer (PIT) ........................................................................ 55</p>
<p> </p>
<p>2.7.1</p>
<p> </p>
<p>Description ....................................................................................... 55</p>
<p> </p>
<p>2.7.2</p>
<p> </p>
<p>Activation ......................................................................................... 55</p>
<p> </p>
<p>2.8</p>
<p> </p>
<p>High Resolution Timer (HRT) ........................................................................... 56</p>
<p> </p>
<p>2.8.1</p>
<p> </p>
<p>Description ....................................................................................... 56</p>
<p> </p>
<p>2.8.2</p>
<p> </p>
<p>Activation ......................................................................................... 56</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>9 </p>
<p>based on template version 6.0.1 </p>
<p>2.9</p>
<p> </p>
<p>PIT versus HRT ............................................................................................... 56</p>
<p> </p>
<p>2.10</p>
<p> </p>
<p>Startup Concept ............................................................................................... 57</p>
<p> </p>
<p>2.11</p>
<p> </p>
<p>Single Core Startup .......................................................................................... 58</p>
<p> </p>
<p>2.11.1</p>
<p> </p>
<p>Single Core Derivatives .................................................................... 58</p>
<p> </p>
<p>2.11.2</p>
<p> </p>
<p>Multi Core Derivatives ...................................................................... 58</p>
<p> </p>
<p>2.11.2.1</p>
<p> </p>
<p>Examples for SC1 / SC2 Systems .................................. 58</p>
<p> </p>
<p>2.11.2.2</p>
<p> </p>
<p>Examples for SC3 / SC4 Systems .................................. 59</p>
<p> </p>
<p>2.12</p>
<p> </p>
<p>Multi Core Startup ............................................................................................ 61</p>
<p> </p>
<p>2.12.1</p>
<p> </p>
<p>Example for SC1 / SC2 Systems ...................................................... 61</p>
<p> </p>
<p>2.12.2</p>
<p> </p>
<p>Examples for SC3 / SC4 systems .................................................... 62</p>
<p> </p>
<p>2.12.2.1</p>
<p> </p>
<p>Only with AUTOSAR Cores ............................................ 62</p>
<p> </p>
<p>2.12.2.2</p>
<p> </p>
<p>Mixed Core System........................................................ 62</p>
<p> </p>
<p>2.13</p>
<p> </p>
<p>Error Handling .................................................................................................. 64</p>
<p> </p>
<p>2.14</p>
<p> </p>
<p>Error Reporting ................................................................................................ 64</p>
<p> </p>
<p>2.14.1</p>
<p> </p>
<p>Extension of Service IDs .................................................................. 64</p>
<p> </p>
<p>2.14.2</p>
<p> </p>
<p>Extension of Error Codes ................................................................. 65</p>
<p> </p>
<p>2.14.3</p>
<p> </p>
<p>Detailed Error Codes ........................................................................ 65</p>
<p> </p>
<p>2.15</p>
<p> </p>
<p>Multi Core Concepts ........................................................................................ 67</p>
<p> </p>
<p>2.15.1</p>
<p> </p>
<p>Scheduling and Dispatching ............................................................. 67</p>
<p> </p>
<p>2.15.2</p>
<p> </p>
<p>Multi Core Data Concepts ................................................................ 67</p>
<p> </p>
<p>2.15.3</p>
<p> </p>
<p>X-Signals ......................................................................................... 67</p>
<p> </p>
<p>2.15.4</p>
<p> </p>
<p>Master / Slave Core ......................................................................... 67</p>
<p> </p>
<p>2.15.5</p>
<p> </p>
<p>Hardware Init Core ........................................................................... 67</p>
<p> </p>
<p>2.15.6</p>
<p> </p>
<p>Startup of a Multi Core System ........................................................ 67</p>
<p> </p>
<p>2.15.7</p>
<p> </p>
<p>Spinlocks ......................................................................................... 67</p>
<p> </p>
<p>2.15.7.1</p>
<p> </p>
<p>Linking of Spinlocks ....................................................... 68</p>
<p> </p>
<p>2.15.8</p>
<p> </p>
<p>Cache .............................................................................................. 68</p>
<p> </p>
<p>2.15.9</p>
<p> </p>
<p>Shutdown ......................................................................................... 68</p>
<p> </p>
<p>2.15.9.1</p>
<p> </p>
<p>Shutdown of one Core ................................................... 68</p>
<p> </p>
<p>2.15.9.2</p>
<p> </p>
<p>Shutdown of all Cores .................................................... 68</p>
<p> </p>
<p>2.15.9.3</p>
<p> </p>
<p>Shutdown during Protection Violation............................. 68</p>
<p> </p>
<p>2.16</p>
<p> </p>
<p>Debugging Concepts ....................................................................................... 69</p>
<p> </p>
<p>2.16.1</p>
<p> </p>
<p>Description ....................................................................................... 69</p>
<p> </p>
<p>2.16.2</p>
<p> </p>
<p>Activation ......................................................................................... 69</p>
<p> </p>
<p>2.16.3</p>
<p> </p>
<p>ORTI Debugging .............................................................................. 69</p>
<p> </p>
<p>2.17</p>
<p> </p>
<p>Memory Protection ........................................................................................... 71</p>
<p> </p>
<p>2.17.1</p>
<p> </p>
<p>Usage of the System MPU ............................................................... 71</p>
<p> </p>
<p>2.17.2</p>
<p> </p>
<p>Usage of the Core MPUs ................................................................. 71</p>
<p> </p>
<p>2.17.3</p>
<p> </p>
<p>Configuration Aspects ...................................................................... 71</p>
<p> </p>
<p>2.17.3.1</p>
<p> </p>
<p>Static MPU Regions ....................................................... 72</p>
<p> </p>
<p>2.17.3.2</p>
<p> </p>
<p>Dynamic MPU Regions .................................................. 72</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>10 </p>
<p>based on template version 6.0.1 </p>
<p>2.17.3.3</p>
<p> </p>
<p>Freedom from Interference ............................................ 72</p>
<p> </p>
<p>2.17.4</p>
<p> </p>
<p>Stack Monitoring .............................................................................. 73</p>
<p> </p>
<p>2.17.5</p>
<p> </p>
<p>Protection Violation Handling ........................................................... 73</p>
<p> </p>
<p>2.17.6</p>
<p> </p>
<p>Optimized / Fast Core MPU Handling .............................................. 73</p>
<p> </p>
<p>2.17.7</p>
<p> </p>
<p>Recommended Configuration ........................................................... 74</p>
<p> </p>
<p>2.18</p>
<p> </p>
<p>Memory Access Checks ................................................................................... 75</p>
<p> </p>
<p>2.18.1</p>
<p> </p>
<p>Description ....................................................................................... 75</p>
<p> </p>
<p>2.18.2</p>
<p> </p>
<p>Activation ......................................................................................... 75</p>
<p> </p>
<p>2.18.3</p>
<p> </p>
<p>Usage .............................................................................................. 75</p>
<p> </p>
<p>2.18.4</p>
<p> </p>
<p>Dependencies .................................................................................. 75</p>
<p> </p>
<p>2.19</p>
<p> </p>
<p>Timing Protection Concept ............................................................................... 76</p>
<p> </p>
<p>2.19.1</p>
<p> </p>
<p>Description ....................................................................................... 76</p>
<p> </p>
<p>2.19.2</p>
<p> </p>
<p>Activation ......................................................................................... 76</p>
<p> </p>
<p>2.19.3</p>
<p> </p>
<p>Usage .............................................................................................. 77</p>
<p> </p>
<p>2.20</p>
<p> </p>
<p>IOC .................................................................................................................. 78</p>
<p> </p>
<p>2.20.1</p>
<p> </p>
<p>Description ....................................................................................... 78</p>
<p> </p>
<p>2.20.2</p>
<p> </p>
<p>Unqeued (Last Is Best) Communication ........................................... 78</p>
<p> </p>
<p>2.20.2.1</p>
<p> </p>
<p>1:1 Communication Variant ............................................ 78</p>
<p> </p>
<p>2.20.2.2</p>
<p> </p>
<p>N:1 Communication Variant ........................................... 78</p>
<p> </p>
<p>2.20.2.3</p>
<p> </p>
<p>N:M Communication Variant .......................................... 79</p>
<p> </p>
<p>2.20.3</p>
<p> </p>
<p>Queued Communication .................................................................. 79</p>
<p> </p>
<p>2.20.4</p>
<p> </p>
<p>Notification ....................................................................................... 79</p>
<p> </p>
<p>2.20.5</p>
<p> </p>
<p>Particularities ................................................................................... 79</p>
<p> </p>
<p>2.20.5.1</p>
<p> </p>
<p>N:1 Queued Communication .......................................... 79</p>
<p> </p>
<p>2.20.5.2</p>
<p> </p>
<p>IOC Spinlocks ................................................................ 80</p>
<p> </p>
<p>2.20.5.3</p>
<p> </p>
<p>Notification ..................................................................... 80</p>
<p> </p>
<p>2.20.5.4</p>
<p> </p>
<p>Complex Data Types ...................................................... 81</p>
<p> </p>
<p>2.21</p>
<p> </p>
<p>Trusted OS Applications ................................................................................... 82</p>
<p> </p>
<p>2.21.1</p>
<p> </p>
<p>Trusted OS Applications with Memory Protection ............................. 82</p>
<p> </p>
<p>2.21.1.1</p>
<p> </p>
<p>Description ..................................................................... 82</p>
<p> </p>
<p>2.21.1.2</p>
<p> </p>
<p>Activation ....................................................................... 82</p>
<p> </p>
<p>2.21.1.3</p>
<p> </p>
<p>Dependencies ................................................................ 82</p>
<p> </p>
<p>2.21.2</p>
<p> </p>
<p>Trusted OS Applications in User Mode ............................................. 82</p>
<p> </p>
<p>2.21.2.1</p>
<p> </p>
<p>Description ..................................................................... 82</p>
<p> </p>
<p>2.21.2.2</p>
<p> </p>
<p>Activation ....................................................................... 82</p>
<p> </p>
<p>2.21.2.3</p>
<p> </p>
<p>Dependencies ................................................................ 82</p>
<p> </p>
<p>2.21.3</p>
<p> </p>
<p>Trusted Functions ............................................................................ 83</p>
<p> </p>
<p>2.22</p>
<p> </p>
<p>OS Hooks ........................................................................................................ 84</p>
<p> </p>
<p>2.22.1</p>
<p> </p>
<p>Runtime Context .............................................................................. 84</p>
<p> </p>
<p>2.22.2</p>
<p> </p>
<p>Nesting behavior .............................................................................. 84</p>
<p> </p>
<p>2.22.3</p>
<p> </p>
<p>Hints ................................................................................................ 84</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>11 </p>
<p>based on template version 6.0.1 </p>
<p><b>3</b></p>
<p> </p>
<p><b>Vector Specific OS Features ...................................................................................... 86</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Optimized Spinlocks ........................................................................................ 86</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Description ....................................................................................... 86</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>Activation ......................................................................................... 86</p>
<p> </p>
<p>3.1.3</p>
<p> </p>
<p>Usage .............................................................................................. 86</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Barriers ............................................................................................................ 87</p>
<p> </p>
<p>3.2.1</p>
<p> </p>
<p>Description ....................................................................................... 87</p>
<p> </p>
<p>3.2.2</p>
<p> </p>
<p>Activation ......................................................................................... 87</p>
<p> </p>
<p>3.2.3</p>
<p> </p>
<p>Usage .............................................................................................. 87</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Peripheral Access API ...................................................................................... 89</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>Description ....................................................................................... 89</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>Activation ......................................................................................... 89</p>
<p> </p>
<p>3.3.3</p>
<p> </p>
<p>Usage .............................................................................................. 89</p>
<p> </p>
<p>3.3.4</p>
<p> </p>
<p>Dependencies .................................................................................. 89</p>
<p> </p>
<p>3.3.5</p>
<p> </p>
<p>Alternatives ...................................................................................... 89</p>
<p> </p>
<p>3.3.6</p>
<p> </p>
<p>Common Use Cases ........................................................................ 89</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Trusted Function Call Stubs ............................................................................. 90</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>Description ....................................................................................... 90</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>Activation ......................................................................................... 90</p>
<p> </p>
<p>3.4.3</p>
<p> </p>
<p>Usage .............................................................................................. 90</p>
<p> </p>
<p>3.4.4</p>
<p> </p>
<p>Dependencies .................................................................................. 90</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Non-Trusted Functions (NTF) .......................................................................... 91</p>
<p> </p>
<p>3.5.1</p>
<p> </p>
<p>Description ....................................................................................... 91</p>
<p> </p>
<p>3.5.2</p>
<p> </p>
<p>Activation ......................................................................................... 91</p>
<p> </p>
<p>3.5.3</p>
<p> </p>
<p>Usage .............................................................................................. 91</p>
<p> </p>
<p>3.5.4</p>
<p> </p>
<p>Dependencies .................................................................................. 91</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Fast Trusted Functions..................................................................................... 92</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Description ....................................................................................... 92</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>Activation ......................................................................................... 92</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Usage .............................................................................................. 92</p>
<p> </p>
<p>3.6.4</p>
<p> </p>
<p>Dependencies .................................................................................. 92</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>Interrupt Source API ......................................................................................... 93</p>
<p> </p>
<p>3.7.1</p>
<p> </p>
<p>Description ....................................................................................... 93</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Pre-Start Task .................................................................................................. 94</p>
<p> </p>
<p>3.8.1</p>
<p> </p>
<p>Description ....................................................................................... 94</p>
<p> </p>
<p>3.8.2</p>
<p> </p>
<p>Activation ......................................................................................... 94</p>
<p> </p>
<p>3.8.3</p>
<p> </p>
<p>Usage .............................................................................................. 94</p>
<p> </p>
<p>3.8.4</p>
<p> </p>
<p>Dependencies .................................................................................. 95</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>X-Signals ......................................................................................................... 96</p>
<p> </p>
<p>3.9.1</p>
<p> </p>
<p>Description ....................................................................................... 96</p>
<p> </p>
<p>3.9.1.1</p>
<p> </p>
<p>Notes on Synchronous X-Signals ................................... 98</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>12 </p>
<p>based on template version 6.0.1 </p>
<p>3.9.1.2</p>
<p> </p>
<p>Notes on Mixed Criticality Systems ................................ 98</p>
<p> </p>
<p>3.9.2</p>
<p> </p>
<p>Activation ......................................................................................... 99</p>
<p> </p>
<p>3.10</p>
<p> </p>
<p>Timing Hooks ................................................................................................. 100</p>
<p> </p>
<p>3.10.1</p>
<p> </p>
<p>Description ..................................................................................... 100</p>
<p> </p>
<p>3.10.2</p>
<p> </p>
<p>Activation ....................................................................................... 100</p>
<p> </p>
<p>3.10.3</p>
<p> </p>
<p>Usage ............................................................................................ 100</p>
<p> </p>
<p>3.11</p>
<p> </p>
<p>Kernel Panic .................................................................................................. 102</p>
<p> </p>
<p>3.12</p>
<p> </p>
<p>Generate callout stubs ................................................................................... 103</p>
<p> </p>
<p>3.12.1</p>
<p> </p>
<p>Description ..................................................................................... 103</p>
<p> </p>
<p>3.12.2</p>
<p> </p>
<p>Activation ....................................................................................... 103</p>
<p> </p>
<p>3.12.3</p>
<p> </p>
<p>Usage ............................................................................................ 103</p>
<p> </p>
<p>3.13</p>
<p> </p>
<p>Exception Context Manipulation ..................................................................... 104</p>
<p> </p>
<p>3.13.1</p>
<p> </p>
<p>Description ..................................................................................... 104</p>
<p> </p>
<p>3.13.2</p>
<p> </p>
<p>Usage ............................................................................................ 104</p>
<p> </p>
<p>3.14</p>
<p> </p>
<p>Category 0 Interrupts ..................................................................................... 105</p>
<p> </p>
<p>3.14.1</p>
<p> </p>
<p>Description ..................................................................................... 105</p>
<p> </p>
<p>3.14.2</p>
<p> </p>
<p>Usage ............................................................................................ 105</p>
<p> </p>
<p>3.14.2.1</p>
<p> </p>
<p>Implement Category 0 ISRs ......................................... 105</p>
<p> </p>
<p>3.14.2.2</p>
<p> </p>
<p>Nesting of Category 0 ISRs .......................................... 105</p>
<p> </p>
<p>3.14.2.3</p>
<p> </p>
<p>Category 0 ISRs before StartOS .................................. 106</p>
<p> </p>
<p>3.14.2.4</p>
<p> </p>
<p>Locations where category 0 ISRs are locked ............... 106</p>
<p> </p>
<p>3.14.3</p>
<p> </p>
<p>Notes on Category 0 ISRs.............................................................. 106</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration ................................................................................................................. 109</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Compiler Optimization Assumptions ............................................................... 109</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Compile Time ................................................................................. 109</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Hardware Software Interfaces (HSI)............................................................... 109</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>TriCore Aurix Family ....................................................................... 110</p>
<p> </p>
<p>4.2.1.1</p>
<p> </p>
<p>Context ........................................................................ 110</p>
<p> </p>
<p>4.2.1.2</p>
<p> </p>
<p>Core Registers ............................................................. 110</p>
<p> </p>
<p>4.2.1.3</p>
<p> </p>
<p>Interrupt Registers ....................................................... 110</p>
<p> </p>
<p>4.2.1.4</p>
<p> </p>
<p>GPT Registers ............................................................. 110</p>
<p> </p>
<p>4.2.1.5</p>
<p> </p>
<p>STM Registers .............................................................. 111</p>
<p> </p>
<p>4.2.1.6</p>
<p> </p>
<p>Aurix Special Characteristics ........................................ 111</p>
<p> </p>
<p>4.2.1.7</p>
<p> </p>
<p>PSW handling .............................................................. 114</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>RH850 Family ................................................................................ 115</p>
<p> </p>
<p>4.2.2.1</p>
<p> </p>
<p>Context ........................................................................ 115</p>
<p> </p>
<p>4.2.2.2</p>
<p> </p>
<p>Core Registers ............................................................. 115</p>
<p> </p>
<p>4.2.2.3</p>
<p> </p>
<p>MPU Registers ............................................................. 116</p>
<p> </p>
<p>4.2.2.4</p>
<p> </p>
<p>INTC Registers ............................................................ 116</p>
<p> </p>
<p>4.2.2.5</p>
<p> </p>
<p>Inter Processor Interrupt Control Registers .................. 116</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>13 </p>
<p>based on template version 6.0.1 </p>
<p>4.2.2.6</p>
<p> </p>
<p>Timer TAUJ Registers .................................................. 116</p>
<p> </p>
<p>4.2.2.7</p>
<p> </p>
<p>Timer STM Registers ................................................... 118</p>
<p> </p>
<p>4.2.2.8</p>
<p> </p>
<p>Timer OSTM Registers ................................................ 119</p>
<p> </p>
<p>4.2.2.9</p>
<p> </p>
<p>RH850 Special Characteristics .................................... 119</p>
<p> </p>
<p>4.2.2.10</p>
<p> </p>
<p>PSW Register Handling ............................................... 121</p>
<p> </p>
<p>4.2.2.11</p>
<p> </p>
<p>Instructions .................................................................. 121</p>
<p> </p>
<p>4.2.2.12</p>
<p> </p>
<p>Exception and Interrupt Cause Address ....................... 121</p>
<p> </p>
<p>4.2.3</p>
<p> </p>
<p>Power PC Family ........................................................................... 122</p>
<p> </p>
<p>4.2.3.1</p>
<p> </p>
<p>Context ........................................................................ 122</p>
<p> </p>
<p>4.2.3.2</p>
<p> </p>
<p>Core Registers ............................................................. 122</p>
<p> </p>
<p>4.2.3.3</p>
<p> </p>
<p>Interrupt Registers ....................................................... 122</p>
<p> </p>
<p>4.2.3.4</p>
<p> </p>
<p>PIT Registers ............................................................... 123</p>
<p> </p>
<p>4.2.3.5</p>
<p> </p>
<p>STM Registers ............................................................. 123</p>
<p> </p>
<p>4.2.3.6</p>
<p> </p>
<p>MPU Registers ............................................................. 123</p>
<p> </p>
<p>4.2.3.7</p>
<p> </p>
<p>SEMA4 Registers ........................................................ 123</p>
<p> </p>
<p>4.2.3.8</p>
<p> </p>
<p>MC_ME Registers ........................................................ 123</p>
<p> </p>
<p>4.2.3.9</p>
<p> </p>
<p>SSCM Registers .......................................................... 123</p>
<p> </p>
<p>4.2.3.10</p>
<p> </p>
<p>Power PC Special Characteristics ................................ 124</p>
<p> </p>
<p>4.2.3.11</p>
<p> </p>
<p>Derivative Special Characteristics ................................ 126</p>
<p> </p>
<p>4.2.3.12</p>
<p> </p>
<p>MSR Handling .............................................................. 126</p>
<p> </p>
<p>4.2.4</p>
<p> </p>
<p>ARM Family ................................................................................... 127</p>
<p> </p>
<p>4.2.4.1</p>
<p> </p>
<p>Cortex-R derivatives .................................................... 127</p>
<p> </p>
<p>4.2.4.1.1</p>
<p> </p>
<p>Generic Cortex-R ..................................... 127</p>
<p> </p>
<p>4.2.4.1.2</p>
<p> </p>
<p>Traveo Family .......................................... 128</p>
<p> </p>
<p>4.2.4.1.3</p>
<p> </p>
<p>Ultrascale Family ..................................... 130</p>
<p> </p>
<p>4.2.4.1.4</p>
<p> </p>
<p>TI AR 16xx ............................................... 131</p>
<p> </p>
<p>4.2.4.1.5</p>
<p> </p>
<p>Renesas R-Car H3 (Cortex-R7) ............... 132</p>
<p> </p>
<p>4.2.4.2</p>
<p> </p>
<p>Cortex-A derivatives ..................................................... 134</p>
<p> </p>
<p>4.2.4.3</p>
<p> </p>
<p>Cortex-M derivatives .................................................... 135</p>
<p> </p>
<p>4.2.4.3.1</p>
<p> </p>
<p>Generic Cortex-M..................................... 135</p>
<p> </p>
<p>4.2.4.3.2</p>
<p> </p>
<p>ATSAMv7x Family .................................... 136</p>
<p> </p>
<p>4.2.4.3.3</p>
<p> </p>
<p>S32K14x Family ....................................... 137</p>
<p> </p>
<p>4.2.4.3.4</p>
<p> </p>
<p>TDA2x ...................................................... 138</p>
<p> </p>
<p>4.2.4.4</p>
<p> </p>
<p>ARM Special Characteristics ........................................ 139</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Memory Mapping Concept ............................................................................. 141</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>Provided MemMap Section Specifiers ............................................ 141</p>
<p> </p>
<p>4.3.1.1</p>
<p> </p>
<p>Usage of MemMap Macros .......................................... 144</p>
<p> </p>
<p>4.3.1.2</p>
<p> </p>
<p>Resulting sections ........................................................ 144</p>
<p> </p>
<p>4.3.1.3</p>
<p> </p>
<p>Access Rights to Variable Sections .............................. 150</p>
<p> </p>
<p>4.3.1.4</p>
<p> </p>
<p>Access Rights to Shared Data Sections ....................... 152</p>
<p> </p>
<p>4.3.2</p>
<p> </p>
<p>Link Sections.................................................................................. 152</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>14 </p>
<p>based on template version 6.0.1 </p>
<p>4.3.2.1</p>
<p> </p>
<p>Pre-Process Linker Command Files ............................. 152</p>
<p> </p>
<p>4.3.2.2</p>
<p> </p>
<p>Simple Linker Defines .................................................. 153</p>
<p> </p>
<p>4.3.2.3</p>
<p> </p>
<p>Hierachical Linker Defines ........................................... 153</p>
<p> </p>
<p>4.3.2.4</p>
<p> </p>
<p>Selecting OS constants ................................................ 153</p>
<p> </p>
<p>4.3.2.5</p>
<p> </p>
<p>Selecting OS variables ................................................. 154</p>
<p> </p>
<p>4.3.2.6</p>
<p> </p>
<p>Selecting special OS Variables .................................... 155</p>
<p> </p>
<p>4.3.2.7</p>
<p> </p>
<p>Selecting User Constant Sections ................................ 156</p>
<p> </p>
<p>4.3.2.8</p>
<p> </p>
<p>Selecting User Variable Sections ................................. 157</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>Section Symbols ............................................................................ 159</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Static Code Analysis ...................................................................................... 159</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Configuration of X-Signals ............................................................................. 160</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>TriCore Aurix Family ....................................................................... 160</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>RH850 Family ................................................................................ 160</p>
<p> </p>
<p>4.5.3</p>
<p> </p>
<p>Power PC Family ........................................................................... 161</p>
<p> </p>
<p>4.5.4</p>
<p> </p>
<p>ARM Family ................................................................................... 161</p>
<p> </p>
<p>4.5.5</p>
<p> </p>
<p>VTT OS .......................................................................................... 161</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>OS generated objects .................................................................................... 161</p>
<p> </p>
<p>4.6.1</p>
<p> </p>
<p>System Application ......................................................................... 161</p>
<p> </p>
<p>4.6.2</p>
<p> </p>
<p>Idle Task ......................................................................................... 162</p>
<p> </p>
<p>4.6.3</p>
<p> </p>
<p>Timer ISR ....................................................................................... 162</p>
<p> </p>
<p>4.6.4</p>
<p> </p>
<p>System Timer Counter ................................................................... 162</p>
<p> </p>
<p>4.6.5</p>
<p> </p>
<p>Timing Protection Counter .............................................................. 163</p>
<p> </p>
<p>4.6.6</p>
<p> </p>
<p>Timing protection ISR ..................................................................... 163</p>
<p> </p>
<p>4.6.7</p>
<p> </p>
<p>Resource Scheduler....................................................................... 163</p>
<p> </p>
<p>4.6.8</p>
<p> </p>
<p>X-Signal ISR .................................................................................. 163</p>
<p> </p>
<p>4.6.9</p>
<p> </p>
<p>IOC Spinlocks ................................................................................ 163</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>VTT OS Specifics ........................................................................................... 164</p>
<p> </p>
<p>4.7.1</p>
<p> </p>
<p>Configuration.................................................................................. 164</p>
<p> </p>
<p>4.7.2</p>
<p> </p>
<p>CANoe Interface ............................................................................ 164</p>
<p> </p>
<p>4.7.2.1</p>
<p> </p>
<p>Idle Task behavior with VTT OS ................................... 164</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>POSIX OS Specifics ...................................................................................... 165</p>
<p> </p>
<p>4.8.1</p>
<p> </p>
<p>Configuration.................................................................................. 165</p>
<p> </p>
<p>4.8.2</p>
<p> </p>
<p>Posix Interface ............................................................................... 165</p>
<p> </p>
<p>4.9</p>
<p> </p>
<p>User include files............................................................................................ 166</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ......................................................................................................... 167</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Specified OS services .................................................................................... 167</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>StartCore ....................................................................................... 167</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>StartNonAutosarCore ..................................................................... 168</p>
<p> </p>
<p>5.1.3</p>
<p> </p>
<p>GetCoreID ...................................................................................... 169</p>
<p> </p>
<p>5.1.4</p>
<p> </p>
<p>GetNumberOfActivatedCores ......................................................... 170</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>15 </p>
<p>based on template version 6.0.1 </p>
<p>5.1.5</p>
<p> </p>
<p>GetActiveApplicationMode ............................................................. 171</p>
<p> </p>
<p>5.1.6</p>
<p> </p>
<p>StartOS .......................................................................................... 172</p>
<p> </p>
<p>5.1.7</p>
<p> </p>
<p>ShutdownOS .................................................................................. 173</p>
<p> </p>
<p>5.1.8</p>
<p> </p>
<p>ShutdownAllCores ......................................................................... 174</p>
<p> </p>
<p>5.1.9</p>
<p> </p>
<p>ControlIdle ..................................................................................... 175</p>
<p> </p>
<p>5.1.10</p>
<p> </p>
<p>GetSpinlock ................................................................................... 176</p>
<p> </p>
<p>5.1.11</p>
<p> </p>
<p>ReleaseSpinlock ............................................................................ 177</p>
<p> </p>
<p>5.1.12</p>
<p> </p>
<p>TryToGetSpinlock ........................................................................... 178</p>
<p> </p>
<p>5.1.13</p>
<p> </p>
<p>DisableAllInterrupts ........................................................................ 179</p>
<p> </p>
<p>5.1.14</p>
<p> </p>
<p>EnableAllInterrupts ......................................................................... 180</p>
<p> </p>
<p>5.1.15</p>
<p> </p>
<p>SuspendAllInterrupts ...................................................................... 181</p>
<p> </p>
<p>5.1.16</p>
<p> </p>
<p>ResumeAllInterrupts ....................................................................... 182</p>
<p> </p>
<p>5.1.17</p>
<p> </p>
<p>SuspendOSInterrupts ..................................................................... 183</p>
<p> </p>
<p>5.1.18</p>
<p> </p>
<p>ResumeOSInterrupts ..................................................................... 184</p>
<p> </p>
<p>5.1.19</p>
<p> </p>
<p>ActivateTask ................................................................................... 185</p>
<p> </p>
<p>5.1.20</p>
<p> </p>
<p>TerminateTask ................................................................................ 186</p>
<p> </p>
<p>5.1.21</p>
<p> </p>
<p>ChainTask ...................................................................................... 187</p>
<p> </p>
<p>5.1.22</p>
<p> </p>
<p>Schedule ........................................................................................ 188</p>
<p> </p>
<p>5.1.23</p>
<p> </p>
<p>GetTaskID ...................................................................................... 189</p>
<p> </p>
<p>5.1.24</p>
<p> </p>
<p>GetTaskState ................................................................................. 190</p>
<p> </p>
<p>5.1.25</p>
<p> </p>
<p>GetISRID ....................................................................................... 191</p>
<p> </p>
<p>5.1.26</p>
<p> </p>
<p>SetEvent ........................................................................................ 192</p>
<p> </p>
<p>5.1.27</p>
<p> </p>
<p>ClearEvent ..................................................................................... 193</p>
<p> </p>
<p>5.1.28</p>
<p> </p>
<p>GetEvent ........................................................................................ 194</p>
<p> </p>
<p>5.1.29</p>
<p> </p>
<p>WaitEvent ....................................................................................... 195</p>
<p> </p>
<p>5.1.30</p>
<p> </p>
<p>IncrementCounter .......................................................................... 196</p>
<p> </p>
<p>5.1.31</p>
<p> </p>
<p>GetCounterValue ........................................................................... 197</p>
<p> </p>
<p>5.1.32</p>
<p> </p>
<p>GetElapsedValue ........................................................................... 198</p>
<p> </p>
<p>5.1.33</p>
<p> </p>
<p>GetAlarmBase ................................................................................ 199</p>
<p> </p>
<p>5.1.34</p>
<p> </p>
<p>GetAlarm ........................................................................................ 200</p>
<p> </p>
<p>5.1.35</p>
<p> </p>
<p>SetRelAlarm ................................................................................... 201</p>
<p> </p>
<p>5.1.36</p>
<p> </p>
<p>SetAbsAlarm .................................................................................. 202</p>
<p> </p>
<p>5.1.37</p>
<p> </p>
<p>CancelAlarm .................................................................................. 203</p>
<p> </p>
<p>5.1.38</p>
<p> </p>
<p>GetResource .................................................................................. 204</p>
<p> </p>
<p>5.1.39</p>
<p> </p>
<p>ReleaseResource .......................................................................... 205</p>
<p> </p>
<p>5.1.40</p>
<p> </p>
<p>StartScheduleTableRel ................................................................... 206</p>
<p> </p>
<p>5.1.41</p>
<p> </p>
<p>StartScheduleTableAbs .................................................................. 207</p>
<p> </p>
<p>5.1.42</p>
<p> </p>
<p>StopScheduleTable ........................................................................ 208</p>
<p> </p>
<p>5.1.43</p>
<p> </p>
<p>NextScheduleTable ........................................................................ 209</p>
<p> </p>
<p>5.1.44</p>
<p> </p>
<p>GetScheduleTableStatus ................................................................ 210</p>
<p> </p>
<p>5.1.45</p>
<p> </p>
<p>StartScheduleTableSynchron ......................................................... 211</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>16 </p>
<p>based on template version 6.0.1 </p>
<p>5.1.46</p>
<p> </p>
<p>SyncScheduleTable........................................................................ 212</p>
<p> </p>
<p>5.1.47</p>
<p> </p>
<p>SetScheduleTableAsync ................................................................ 213</p>
<p> </p>
<p>5.1.48</p>
<p> </p>
<p>GetApplicationID ............................................................................ 214</p>
<p> </p>
<p>5.1.49</p>
<p> </p>
<p>GetCurrentApplicationID ................................................................ 215</p>
<p> </p>
<p>5.1.50</p>
<p> </p>
<p>GetApplicationState ....................................................................... 216</p>
<p> </p>
<p>5.1.51</p>
<p> </p>
<p>CheckObjectAccess ....................................................................... 217</p>
<p> </p>
<p>5.1.52</p>
<p> </p>
<p>CheckObjectOwnership ................................................................. 218</p>
<p> </p>
<p>5.1.53</p>
<p> </p>
<p>AllowAccess ................................................................................... 219</p>
<p> </p>
<p>5.1.54</p>
<p> </p>
<p>TerminateApplication ...................................................................... 220</p>
<p> </p>
<p>5.1.55</p>
<p> </p>
<p>CallTrustedFunction ....................................................................... 221</p>
<p> </p>
<p>5.1.56</p>
<p> </p>
<p>Check Task Memory Access .......................................................... 222</p>
<p> </p>
<p>5.1.57</p>
<p> </p>
<p>Check ISR Memory Access ............................................................ 223</p>
<p> </p>
<p>5.1.58</p>
<p> </p>
<p>OSErrorGetServiceId ..................................................................... 224</p>
<p> </p>
<p>5.1.59</p>
<p> </p>
<p>OSError_Os_DisableInterruptSource_ISRID .................................. 225</p>
<p> </p>
<p>5.1.60</p>
<p> </p>
<p>OSError_Os_EnableInterruptSource_ISRID .................................. 225</p>
<p> </p>
<p>5.1.61</p>
<p> </p>
<p>OSError_Os_EnableInterruptSource_ClearPending....................... 226</p>
<p> </p>
<p>5.1.62</p>
<p> </p>
<p>OSError_Os_ClearPendingInterrupt_ISRID ................................... 226</p>
<p> </p>
<p>5.1.63</p>
<p> </p>
<p>OSError_Os_IsInterruptSourceEnabled_ISRID .............................. 227</p>
<p> </p>
<p>5.1.64</p>
<p> </p>
<p>OSError_Os_IsInterruptSourceEnabled_IsEnabled ....................... 227</p>
<p> </p>
<p>5.1.65</p>
<p> </p>
<p>OSError_Os_IsInterruptPending_ISRID ......................................... 228</p>
<p> </p>
<p>5.1.66</p>
<p> </p>
<p>OSError_Os_IsInterruptPending_IsPending ................................... 228</p>
<p> </p>
<p>5.1.67</p>
<p> </p>
<p>OSError_CallTrustedFunction_FunctionIndex ................................ 229</p>
<p> </p>
<p>5.1.68</p>
<p> </p>
<p>OSError_CallTrustedFunction_FunctionParams ............................. 229</p>
<p> </p>
<p>5.1.69</p>
<p> </p>
<p>OSError_CallNonTrustedFunction_FunctionIndex .......................... 230</p>
<p> </p>
<p>5.1.70</p>
<p> </p>
<p>OSError_CallNonTrustedFunction_FunctionParams ...................... 230</p>
<p> </p>
<p>5.1.71</p>
<p> </p>
<p>OSError_StartScheduleTableRel_ScheduleTableID ....................... 231</p>
<p> </p>
<p>5.1.72</p>
<p> </p>
<p>OSError_StartScheduleTableRel_Offset ........................................ 231</p>
<p> </p>
<p>5.1.73</p>
<p> </p>
<p>OSError_StartScheduleTableAbs_ScheduleTableID ...................... 232</p>
<p> </p>
<p>5.1.74</p>
<p> </p>
<p>OSError_StartScheduleTableAbs_Start.......................................... 232</p>
<p> </p>
<p>5.1.75</p>
<p> </p>
<p>OSError_StopScheduleTable_ScheduleTableID ............................. 233</p>
<p> </p>
<p>5.1.76</p>
<p> </p>
<p>OSError_NextScheduleTable_ScheduleTableID_From .................. 233</p>
<p> </p>
<p>5.1.77</p>
<p> </p>
<p>OSError_NextScheduleTable_ScheduleTableID_To ....................... 234</p>
<p> </p>
<p>5.1.78</p>
<p> </p>
<p>OSError_StartScheduleTableSynchron_ScheduleTableID ............. 234</p>
<p> </p>
<p>5.1.79</p>
<p> </p>
<p>OSError_SyncScheduleTable_ScheduleTableID ............................ 235</p>
<p> </p>
<p>5.1.80</p>
<p> </p>
<p>OSError_SyncScheduleTable_Value .............................................. 235</p>
<p> </p>
<p>5.1.81</p>
<p> </p>
<p>OSError_SetScheduleTableAsync_ScheduleTableID ..................... 236</p>
<p> </p>
<p>5.1.82</p>
<p> </p>
<p>OSError_GetScheduleTableStatus_ScheduleTableID .................... 236</p>
<p> </p>
<p>5.1.83</p>
<p> </p>
<p>OSError_GetScheduleTableStatus_ScheduleStatus ...................... 237</p>
<p> </p>
<p>5.1.84</p>
<p> </p>
<p>OSError_IncrementCounter_CounterID ......................................... 237</p>
<p> </p>
<p>5.1.85</p>
<p> </p>
<p>OSError_GetCounterValue_CounterID ........................................... 238</p>
<p> </p>
<p>5.1.86</p>
<p> </p>
<p>OSError_GetCounterValue_Value .................................................. 239</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>17 </p>
<p>based on template version 6.0.1 </p>
<p>5.1.87</p>
<p> </p>
<p>OSError_GetElapsedValue_CounterID .......................................... 239</p>
<p> </p>
<p>5.1.88</p>
<p> </p>
<p>OSError_GetElapsedValue_Value .................................................. 240</p>
<p> </p>
<p>5.1.89</p>
<p> </p>
<p>OSError_GetElapsedValue_ElapsedValue ..................................... 240</p>
<p> </p>
<p>5.1.90</p>
<p> </p>
<p>OSError_TerminateApplication_Application .................................... 241</p>
<p> </p>
<p>5.1.91</p>
<p> </p>
<p>OSError_TerminateApplication_RestartOption ............................... 241</p>
<p> </p>
<p>5.1.92</p>
<p> </p>
<p>OSError_GetApplicationState_Application ..................................... 242</p>
<p> </p>
<p>5.1.93</p>
<p> </p>
<p>OSError_GetApplicationState_Value .............................................. 242</p>
<p> </p>
<p>5.1.94</p>
<p> </p>
<p>OSError_GetSpinlock_SpinlockId .................................................. 243</p>
<p> </p>
<p>5.1.95</p>
<p> </p>
<p>OSError_ReleaseSpinlock_SpinlockId ........................................... 243</p>
<p> </p>
<p>5.1.96</p>
<p> </p>
<p>OSError_TryToGetSpinlock_SpinlockId .......................................... 244</p>
<p> </p>
<p>5.1.97</p>
<p> </p>
<p>OSError_TryToGetSpinlock_Success ............................................. 244</p>
<p> </p>
<p>5.1.98</p>
<p> </p>
<p>OSError_ControlIdle_CoreID ......................................................... 245</p>
<p> </p>
<p>5.1.99</p>
<p> </p>
<p>OSError_Os_GetExceptionContext_Context .................................. 245</p>
<p> </p>
<p>5.1.100</p>
<p> </p>
<p>OSError_Os_SetExceptionContext_Context .................................. 246</p>
<p> </p>
<p>5.1.101</p>
<p> </p>
<p>OSError_ControlIdle_IdleMode ...................................................... 246</p>
<p> </p>
<p>5.1.102</p>
<p> </p>
<p>OSError_IocSend_IN ..................................................................... 247</p>
<p> </p>
<p>5.1.103</p>
<p> </p>
<p>OSError_IocWrite_IN ..................................................................... 247</p>
<p> </p>
<p>5.1.104</p>
<p> </p>
<p>OSError_IocSendGroup_IN ........................................................... 248</p>
<p> </p>
<p>5.1.105</p>
<p> </p>
<p>OSError_IocWriteGroup_IN ........................................................... 248</p>
<p> </p>
<p>5.1.106</p>
<p> </p>
<p>OSError_IocReceive_OUT ............................................................. 249</p>
<p> </p>
<p>5.1.107</p>
<p> </p>
<p>OSError_IocRead_OUT ................................................................. 249</p>
<p> </p>
<p>5.1.108</p>
<p> </p>
<p>OSError_IocReceiveGroup_OUT ................................................... 250</p>
<p> </p>
<p>5.1.109</p>
<p> </p>
<p>OSError_IocReadGroup_OUT ....................................................... 250</p>
<p> </p>
<p>5.1.110</p>
<p> </p>
<p>OSError_StartOS_Mode ................................................................ 251</p>
<p> </p>
<p>5.1.111</p>
<p> </p>
<p>OSError_ActivateTask_TaskID ....................................................... 251</p>
<p> </p>
<p>5.1.112</p>
<p> </p>
<p>OSError_ChainTask_TaskID .......................................................... 252</p>
<p> </p>
<p>5.1.113</p>
<p> </p>
<p>OSError_GetTaskID_TaskID .......................................................... 252</p>
<p> </p>
<p>5.1.114</p>
<p> </p>
<p>OSError_GetTaskState_TaskID ...................................................... 253</p>
<p> </p>
<p>5.1.115</p>
<p> </p>
<p>OSError_GetTaskState_State ........................................................ 253</p>
<p> </p>
<p>5.1.116</p>
<p> </p>
<p>OSError_SetEvent_TaskID............................................................. 254</p>
<p> </p>
<p>5.1.117</p>
<p> </p>
<p>OSError_SetEvent_Mask ............................................................... 254</p>
<p> </p>
<p>5.1.118</p>
<p> </p>
<p>OSError_ClearEvent_Mask ............................................................ 255</p>
<p> </p>
<p>5.1.119</p>
<p> </p>
<p>OSError_GetEvent_TaskID ............................................................ 255</p>
<p> </p>
<p>5.1.120</p>
<p> </p>
<p>OSError_GetEvent_Mask .............................................................. 256</p>
<p> </p>
<p>5.1.121</p>
<p> </p>
<p>OSError_WaitEvent_Mask ............................................................. 256</p>
<p> </p>
<p>5.1.122</p>
<p> </p>
<p>OSError_GetAlarmBase_AlarmID .................................................. 257</p>
<p> </p>
<p>5.1.123</p>
<p> </p>
<p>OSError_GetAlarmBase_Info ......................................................... 257</p>
<p> </p>
<p>5.1.124</p>
<p> </p>
<p>OSError_GetAlarm_AlarmID .......................................................... 258</p>
<p> </p>
<p>5.1.125</p>
<p> </p>
<p>OSError_GetAlarm_Tick ................................................................ 258</p>
<p> </p>
<p>5.1.126</p>
<p> </p>
<p>OSError_SetRelAlarm_AlarmID ..................................................... 259</p>
<p> </p>
<p>5.1.127</p>
<p> </p>
<p>OSError_SetRelAlarm_increment .................................................. 259</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>18 </p>
<p>based on template version 6.0.1 </p>
<p>5.1.128</p>
<p> </p>
<p>OSError_SetRelAlarm_cycle .......................................................... 260</p>
<p> </p>
<p>5.1.129</p>
<p> </p>
<p>OSError_SetAbsAlarm_AlarmID .................................................... 260</p>
<p> </p>
<p>5.1.130</p>
<p> </p>
<p>OSError_SetAbsAlarm_start .......................................................... 261</p>
<p> </p>
<p>5.1.131</p>
<p> </p>
<p>OSError_SetAbsAlarm_cycle ......................................................... 261</p>
<p> </p>
<p>5.1.132</p>
<p> </p>
<p>OSError_CancelAlarm_AlarmID ..................................................... 262</p>
<p> </p>
<p>5.1.133</p>
<p> </p>
<p>OSError_GetResource_ResID ....................................................... 262</p>
<p> </p>
<p>5.1.134</p>
<p> </p>
<p>OSError_ReleaseResource_ResID ................................................ 263</p>
<p> </p>
<p>5.1.135</p>
<p> </p>
<p>OSError_Os_GetUnhandledIrq_InterruptSource ............................ 263</p>
<p> </p>
<p>5.1.136</p>
<p> </p>
<p>OSError_Os_GetUnhandledExc_ExceptionSource ........................ 264</p>
<p> </p>
<p>5.1.137</p>
<p> </p>
<p>OSError_BarrierSynchronize_BarrierID.......................................... 264</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Additional OS services ................................................................................... 265</p>
<p> </p>
<p>5.2.1</p>
<p> </p>
<p>Os_GetVersionInfo ......................................................................... 265</p>
<p> </p>
<p>5.2.2</p>
<p> </p>
<p>Peripheral Access API .................................................................... 266</p>
<p> </p>
<p>5.2.2.1</p>
<p> </p>
<p>Read Functions ............................................................ 266</p>
<p> </p>
<p>5.2.2.2</p>
<p> </p>
<p>Write Functions ............................................................ 268</p>
<p> </p>
<p>5.2.2.3</p>
<p> </p>
<p>Bitmask Functions ....................................................... 270</p>
<p> </p>
<p>5.2.3</p>
<p> </p>
<p>Pre-Start Task ................................................................................ 272</p>
<p> </p>
<p>5.2.4</p>
<p> </p>
<p>Non-Trusted Functions (NTF) ......................................................... 273</p>
<p> </p>
<p>5.2.5</p>
<p> </p>
<p>Fast Trusted Functions ................................................................... 274</p>
<p> </p>
<p>5.2.6</p>
<p> </p>
<p>Interrupt Source API ....................................................................... 275</p>
<p> </p>
<p>5.2.6.1</p>
<p> </p>
<p>Disable Interrupt Source .............................................. 275</p>
<p> </p>
<p>5.2.6.2</p>
<p> </p>
<p>Enable Interrupt Source ............................................... 276</p>
<p> </p>
<p>5.2.6.3</p>
<p> </p>
<p>Clear Pending Interrupt ................................................ 277</p>
<p> </p>
<p>5.2.6.4</p>
<p> </p>
<p>Check Interrupt Source Enabled .................................. 278</p>
<p> </p>
<p>5.2.6.5</p>
<p> </p>
<p>Check Interrupt Pending .............................................. 279</p>
<p> </p>
<p>5.2.7</p>
<p> </p>
<p>Detailed Error API .......................................................................... 280</p>
<p> </p>
<p>5.2.7.1</p>
<p> </p>
<p>Get detailed Error ........................................................ 280</p>
<p> </p>
<p>5.2.7.2</p>
<p> </p>
<p>Unhandled Interrupt Requests ..................................... 281</p>
<p> </p>
<p>5.2.7.3</p>
<p> </p>
<p>Unhandled Exception Requests ................................... 282</p>
<p> </p>
<p>5.2.8</p>
<p> </p>
<p>Stack Usage API ............................................................................ 283</p>
<p> </p>
<p>5.2.9</p>
<p> </p>
<p>RTE Interrupt API ........................................................................... 284</p>
<p> </p>
<p>5.2.10</p>
<p> </p>
<p>Time Conversion Macros ............................................................... 285</p>
<p> </p>
<p>5.2.10.1</p>
<p> </p>
<p>Convert from Time into Counter Ticks .......................... 285</p>
<p> </p>
<p>5.2.10.2</p>
<p> </p>
<p>Convert from Counter Ticks into Time .......................... 285</p>
<p> </p>
<p>5.2.11</p>
<p> </p>
<p>OS Initialization .............................................................................. 286</p>
<p> </p>
<p>5.2.12</p>
<p> </p>
<p>Timing Hooks ................................................................................. 287</p>
<p> </p>
<p>5.2.12.1</p>
<p> </p>
<p>Timing Hooks for Activation .......................................... 287</p>
<p> </p>
<p>5.2.12.1.1</p>
<p> </p>
<p>Task Activation ......................................... 287</p>
<p> </p>
<p>5.2.12.1.2</p>
<p> </p>
<p>Task Activation Exeeding Limit ................. 288</p>
<p> </p>
<p>5.2.12.1.3</p>
<p> </p>
<p>Set Event ................................................. 288</p>
<p> </p>
<p>5.2.12.1.4</p>
<p> </p>
<p>Wait Event Not Waiting ............................ 289</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>19 </p>
<p>based on template version 6.0.1 </p>
<p>5.2.12.1.5</p>
<p> </p>
<p>Timing Hook for Context Switch ............... 290</p>
<p> </p>
<p>5.2.12.2</p>
<p> </p>
<p>Timing Hooks for Locking Purposes ............................. 291</p>
<p> </p>
<p>5.2.12.2.1</p>
<p> </p>
<p>Get Resource ........................................... 291</p>
<p> </p>
<p>5.2.12.2.2</p>
<p> </p>
<p>Release Resource ................................... 291</p>
<p> </p>
<p>5.2.12.2.3</p>
<p> </p>
<p>Request Spinlock ..................................... 292</p>
<p> </p>
<p>5.2.12.2.4</p>
<p> </p>
<p>Request Internal Spinlock ........................ 292</p>
<p> </p>
<p>5.2.12.2.5</p>
<p> </p>
<p>Get Spinlock ............................................ 293</p>
<p> </p>
<p>5.2.12.2.6</p>
<p> </p>
<p>Get Internal Spinlock ................................ 293</p>
<p> </p>
<p>5.2.12.2.7</p>
<p> </p>
<p>Release Spinlock ..................................... 294</p>
<p> </p>
<p>5.2.12.2.8</p>
<p> </p>
<p>Release Internal Spinlock ........................ 294</p>
<p> </p>
<p>5.2.12.2.9</p>
<p> </p>
<p>Disable Interrupts ..................................... 295</p>
<p> </p>
<p>5.2.12.2.10</p>
<p> </p>
<p>Enable Interrupts ..................................... 296</p>
<p> </p>
<p>5.2.13</p>
<p> </p>
<p>PanicHook ..................................................................................... 297</p>
<p> </p>
<p>5.2.14</p>
<p> </p>
<p>Barriers .......................................................................................... 298</p>
<p> </p>
<p>5.2.15</p>
<p> </p>
<p>Exception Context Manipulation ..................................................... 299</p>
<p> </p>
<p>5.2.15.1</p>
<p> </p>
<p>Os_GetExceptionContext............................................. 299</p>
<p> </p>
<p>5.2.15.2</p>
<p> </p>
<p>Os_SetExceptionContext ............................................. 300</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Calling Context Overview ............................................................................... 301</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Configuration ............................................................................................................ 302</b></p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary .................................................................................................................... 303</b></p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 304</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>20 </p>
<p>based on template version 6.0.1 </p>
<p><b>Illustrations </b></p>
<p>Figure 1-1</p>
<p> </p>
<p>AUTOSAR Architecture Overview ............................................................. 24</p>
<p> </p>
<p>Figure 2-1</p>
<p> </p>
<p>Stack Safety Gap ...................................................................................... 47</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Interrupt Lock Levels ................................................................................ 48</p>
<p> </p>
<p>Figure 2-3</p>
<p> </p>
<p>API functions during startup ...................................................................... 57</p>
<p> </p>
<p>Figure 2-4</p>
<p> </p>
<p>MICROSAR OS Detailed Error Code ........................................................ 66</p>
<p> </p>
<p>Figure 2-5</p>
<p> </p>
<p>N:1 Multiple Sender Queues ..................................................................... 80</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>Barriers ..................................................................................................... 87</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>X-Signal .................................................................................................... 96</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p>Usage of manipulating exception context ................................................ 104</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Padding bytes between MPU regions ...................................................... 111</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>MICROSAR OS Characteristics ................................................................ 25</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Supported TriCore Aurix Hardware ........................................................... 27</p>
<p> </p>
<p>Table 1-3 </p>
<p> </p>
<p>Supported TriCore Aurix Compilers ........................................................... 27</p>
<p> </p>
<p>Table 1-4 </p>
<p> </p>
<p>Supported Power PC Hardware ................................................................ 30</p>
<p> </p>
<p>Table 1-5 </p>
<p> </p>
<p>Supported Power PC compilers ................................................................ 30</p>
<p> </p>
<p>Table 1-6 </p>
<p> </p>
<p>Supported ARM Hardware ........................................................................ 30</p>
<p> </p>
<p>Table 1-7 </p>
<p> </p>
<p>Supported ARM compilers ........................................................................ 30</p>
<p> </p>
<p>Table 1-8 </p>
<p> </p>
<p>Supported RH850 Hardware ..................................................................... 32</p>
<p> </p>
<p>Table 1-9 </p>
<p> </p>
<p>Supported RH850 Compilers .................................................................... 32</p>
<p> </p>
<p>Table 1-10 </p>
<p> </p>
<p>VTT OS characteristics ............................................................................. 33</p>
<p> </p>
<p>Table 1-11 </p>
<p> </p>
<p>POSIX OS characteristic .......................................................................... 34</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>MICROSAR OS Stack Types .................................................................... 42</p>
<p> </p>
<p>Table 2-2 </p>
<p> </p>
<p>Stack Check Patterns ............................................................................... 44</p>
<p> </p>
<p>Table 2-3 </p>
<p> </p>
<p>PIT versus HRT ........................................................................................ 56</p>
<p> </p>
<p>Table 2-4 </p>
<p> </p>
<p>Types of OS Errors ................................................................................... 64</p>
<p> </p>
<p>Table 2-5 </p>
<p> </p>
<p>Extension of Error Codes .......................................................................... 65</p>
<p> </p>
<p>Table 2-6 </p>
<p> </p>
<p>Linking of spinlocks................................................................................... 68</p>
<p> </p>
<p>Table 2-7 </p>
<p> </p>
<p>Recommended Configuration MPU Access Rights ................................... 74</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Differences of OS and Optimized Spinlocks .............................................. 86</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Comparison between Synchronous and Asynchronous X-Signal .............. 97</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Priority of X-Signal receiver ISR................................................................ 98</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Provided MemMap Section Specifiers .................................................... 143</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>MemMap Code Sections Descriptions .................................................... 144</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>MemMap Callout Code Sections Descriptions ........................................ 144</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>MemMap Const Sections Descriptions ................................................... 145</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>MemMap Variable Sections Descriptions ................................................ 148</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>MemMap Variable Stack Sections Descriptions ...................................... 149</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Recommended Section Access Rights ................................................... 151</p>
<p> </p>
<p>Table 4-8 </p>
<p> </p>
<p>Recommended Spinlock Section Access Rights ..................................... 152</p>
<p> </p>
<p>Table 4-9 </p>
<p> </p>
<p>List of Generated Linker Command Files ................................................ 152</p>
<p> </p>
<p>Table 4-10 </p>
<p> </p>
<p>OS constants linker define group ............................................................ 153</p>
<p> </p>
<p>Table 4-11 </p>
<p> </p>
<p>OS variables linker define group ............................................................. 154</p>
<p> </p>
<p>Table 4-12 </p>
<p> </p>
<p>OS Barriers and Core status linker define group ..................................... 155</p>
<p> </p>
<p>Table 4-13 </p>
<p> </p>
<p>User constants linker define group .......................................................... 156</p>
<p> </p>
<p>Table 4-14 </p>
<p> </p>
<p>User variables linker define group ........................................................... 157</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>StartCore ................................................................................................ 167</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>StartNonAutosarCore ............................................................................. 168</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>GetCoreID .............................................................................................. 169</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>21 </p>
<p>based on template version 6.0.1 </p>
<p>Table 5-4 </p>
<p> </p>
<p>GetNumberOfActivatedCores ................................................................. 170</p>
<p> </p>
<p>Table 5-5 </p>
<p> </p>
<p>GetActiveApplicationMode ...................................................................... 171</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>StartOS ................................................................................................... 172</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>ShutdownOS .......................................................................................... 173</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>ShutdownAllCores .................................................................................. 174</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>ControlIdle .............................................................................................. 175</p>
<p> </p>
<p>Table 5-10 </p>
<p> </p>
<p>GetSpinlock ............................................................................................ 176</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>ReleaseSpinlock ..................................................................................... 177</p>
<p> </p>
<p>Table 5-12 </p>
<p> </p>
<p>TryToGetSpinlock ................................................................................... 178</p>
<p> </p>
<p>Table 5-13 </p>
<p> </p>
<p>DisableAllInterrupts................................................................................. 179</p>
<p> </p>
<p>Table 5-14 </p>
<p> </p>
<p>EnableAllInterrupts ................................................................................. 180</p>
<p> </p>
<p>Table 5-15 </p>
<p> </p>
<p>SuspendAllInterrupts .............................................................................. 181</p>
<p> </p>
<p>Table 5-16 </p>
<p> </p>
<p>ResumeAllInterrupts ............................................................................... 182</p>
<p> </p>
<p>Table 5-17 </p>
<p> </p>
<p>SuspendOSInterrupts ............................................................................. 183</p>
<p> </p>
<p>Table 5-18 </p>
<p> </p>
<p>ResumeOSInterrupts .............................................................................. 184</p>
<p> </p>
<p>Table 5-19 </p>
<p> </p>
<p>ActivateTask ........................................................................................... 185</p>
<p> </p>
<p>Table 5-20 </p>
<p> </p>
<p>TerminateTask ........................................................................................ 186</p>
<p> </p>
<p>Table 5-21 </p>
<p> </p>
<p>ChainTask ............................................................................................... 187</p>
<p> </p>
<p>Table 5-22 </p>
<p> </p>
<p>Schedule ................................................................................................ 188</p>
<p> </p>
<p>Table 5-23 </p>
<p> </p>
<p>GetTaskID ............................................................................................... 189</p>
<p> </p>
<p>Table 5-24 </p>
<p> </p>
<p>GetTaskState .......................................................................................... 190</p>
<p> </p>
<p>Table 5-25 </p>
<p> </p>
<p>GetISRID ................................................................................................ 191</p>
<p> </p>
<p>Table 5-26 </p>
<p> </p>
<p>SetEvent ................................................................................................. 192</p>
<p> </p>
<p>Table 5-27 </p>
<p> </p>
<p>ClearEvent .............................................................................................. 193</p>
<p> </p>
<p>Table 5-28 </p>
<p> </p>
<p>GetEvent ................................................................................................ 194</p>
<p> </p>
<p>Table 5-29 </p>
<p> </p>
<p>WaitEvent ............................................................................................... 195</p>
<p> </p>
<p>Table 5-30 </p>
<p> </p>
<p>IncrementCounter ................................................................................... 196</p>
<p> </p>
<p>Table 5-31 </p>
<p> </p>
<p>GetCounterValue .................................................................................... 197</p>
<p> </p>
<p>Table 5-32 </p>
<p> </p>
<p>GetElapsedValue .................................................................................... 198</p>
<p> </p>
<p>Table 5-33 </p>
<p> </p>
<p>GetAlarmBase ........................................................................................ 199</p>
<p> </p>
<p>Table 5-34 </p>
<p> </p>
<p>GetAlarm ................................................................................................ 200</p>
<p> </p>
<p>Table 5-35 </p>
<p> </p>
<p>SetRelAlarm ........................................................................................... 201</p>
<p> </p>
<p>Table 5-36 </p>
<p> </p>
<p>SetAbsAlarm........................................................................................... 202</p>
<p> </p>
<p>Table 5-37 </p>
<p> </p>
<p>CancelAlarm ........................................................................................... 203</p>
<p> </p>
<p>Table 5-38 </p>
<p> </p>
<p>GetResource .......................................................................................... 204</p>
<p> </p>
<p>Table 5-39 </p>
<p> </p>
<p>ReleaseResource ................................................................................... 205</p>
<p> </p>
<p>Table 5-40 </p>
<p> </p>
<p>StartScheduleTableRel ........................................................................... 206</p>
<p> </p>
<p>Table 5-41 </p>
<p> </p>
<p>StartScheduleTableAbs .......................................................................... 207</p>
<p> </p>
<p>Table 5-42 </p>
<p> </p>
<p>StopScheduleTable ................................................................................. 208</p>
<p> </p>
<p>Table 5-43 </p>
<p> </p>
<p>NextScheduleTable ................................................................................. 209</p>
<p> </p>
<p>Table 5-44 </p>
<p> </p>
<p>GetScheduleTableStatus ........................................................................ 210</p>
<p> </p>
<p>Table 5-45 </p>
<p> </p>
<p>StartScheduleTableSynchron .................................................................. 211</p>
<p> </p>
<p>Table 5-46 </p>
<p> </p>
<p>SyncScheduleTable ................................................................................ 212</p>
<p> </p>
<p>Table 5-47 </p>
<p> </p>
<p>SetScheduleTableAsync ......................................................................... 213</p>
<p> </p>
<p>Table 5-48 </p>
<p> </p>
<p>GetApplicationID ..................................................................................... 214</p>
<p> </p>
<p>Table 5-49 </p>
<p> </p>
<p>GetCurrentApplicationID ......................................................................... 215</p>
<p> </p>
<p>Table 5-50 </p>
<p> </p>
<p>GetApplicationState ................................................................................ 216</p>
<p> </p>
<p>Table 5-51 </p>
<p> </p>
<p>CheckObjectAccess ................................................................................ 217</p>
<p> </p>
<p>Table 5-52 </p>
<p> </p>
<p>CheckObjectOwnership .......................................................................... 218</p>
<p> </p>
<p>Table 5-53 </p>
<p> </p>
<p>AllowAccess ........................................................................................... 219</p>
<p> </p>
<p>Table 5-54 </p>
<p> </p>
<p>TerminateApplication .............................................................................. 220</p>
<p> </p>
<p>Table 5-55 </p>
<p> </p>
<p>CallTrustedFunction ................................................................................ 221</p>
<p> </p>
<p>Table 5-56 </p>
<p> </p>
<p>API Service CheckTaskMemoryAccess .................................................. 222</p>
<p> </p>
<p>Table 5-57 </p>
<p> </p>
<p>API Service CheckISRMemoryAccess .................................................... 223</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>22 </p>
<p>based on template version 6.0.1 </p>
<p>Table 5-58 </p>
<p> </p>
<p>OSErrorGetServiceId .............................................................................. 224</p>
<p> </p>
<p>Table 5-59 </p>
<p> </p>
<p>OSError_Os_DisableInterruptSource_ISRID .......................................... 225</p>
<p> </p>
<p>Table 5-60 </p>
<p> </p>
<p>OSError_Os_EnableInterruptSource_ISRID ........................................... 225</p>
<p> </p>
<p>Table 5-61 </p>
<p> </p>
<p>OSError_Os_EnableInterruptSource_ClearPending ............................... 226</p>
<p> </p>
<p>Table 5-62 </p>
<p> </p>
<p>OSError_Os_ClearPendingInterrupt_ISRID ............................................ 226</p>
<p> </p>
<p>Table 5-63 </p>
<p> </p>
<p>OSError_Os_IsInterruptSourceEnabled_ISRID ...................................... 227</p>
<p> </p>
<p>Table 5-64 </p>
<p> </p>
<p>OSError_Os_IsInterruptSourceEnabled_IsEnabled ................................ 227</p>
<p> </p>
<p>Table 5-65 </p>
<p> </p>
<p>OSError_Os_IsInterruptPending_ISRID .................................................. 228</p>
<p> </p>
<p>Table 5-66 </p>
<p> </p>
<p>OSError_Os_IsInterruptPending_IsPending ........................................... 228</p>
<p> </p>
<p>Table 5-67 </p>
<p> </p>
<p>OSError_CallTrustedFunction_FunctionIndex ......................................... 229</p>
<p> </p>
<p>Table 5-68 </p>
<p> </p>
<p>OSError_CallTrustedFunction_FunctionParams ..................................... 229</p>
<p> </p>
<p>Table 5-69 </p>
<p> </p>
<p>OSError_CallNonTrustedFunction_FunctionIndex .................................. 230</p>
<p> </p>
<p>Table 5-70 </p>
<p> </p>
<p>OSError_CallNonTrustedFunction_FunctionParams ............................... 230</p>
<p> </p>
<p>Table 5-71 </p>
<p> </p>
<p>OSError_StartScheduleTableRel_ScheduleTableID ................................ 231</p>
<p> </p>
<p>Table 5-72 </p>
<p> </p>
<p>OSError_StartScheduleTableRel_Offset ................................................. 231</p>
<p> </p>
<p>Table 5-73 </p>
<p> </p>
<p>OSError_StartScheduleTableAbs_ScheduleTableID ............................... 232</p>
<p> </p>
<p>Table 5-74 </p>
<p> </p>
<p>OSError_StartScheduleTableAbs_Start .................................................. 232</p>
<p> </p>
<p>Table 5-75 </p>
<p> </p>
<p>OSError_StopScheduleTable_ScheduleTableID ..................................... 233</p>
<p> </p>
<p>Table 5-76 </p>
<p> </p>
<p>OSError_NextScheduleTable_ScheduleTableID_From ........................... 233</p>
<p> </p>
<p>Table 5-77 </p>
<p> </p>
<p>OSError_NextScheduleTable_ScheduleTableID_To................................ 234</p>
<p> </p>
<p>Table 5-78 </p>
<p> </p>
<p>OSError_StartScheduleTableSynchron_ScheduleTableID ...................... 234</p>
<p> </p>
<p>Table 5-79 </p>
<p> </p>
<p>OSError_SyncScheduleTable_ScheduleTableID ..................................... 235</p>
<p> </p>
<p>Table 5-80 </p>
<p> </p>
<p>OSError_SyncScheduleTable_Value....................................................... 235</p>
<p> </p>
<p>Table 5-81 </p>
<p> </p>
<p>OSError_SetScheduleTableAsync_ScheduleTableID .............................. 236</p>
<p> </p>
<p>Table 5-82 </p>
<p> </p>
<p>OSError_GetScheduleTableStatus_ScheduleTableID ............................. 236</p>
<p> </p>
<p>Table 5-83 </p>
<p> </p>
<p>OSError_GetScheduleTableStatus_ScheduleStatus ............................... 237</p>
<p> </p>
<p>Table 5-84 </p>
<p> </p>
<p>OSError_IncrementCounter_CounterID .................................................. 237</p>
<p> </p>
<p>Table 5-85 </p>
<p> </p>
<p>OSError_GetCounterValue_CounterID ................................................... 238</p>
<p> </p>
<p>Table 5-86 </p>
<p> </p>
<p>OSError_GetCounterValue_Value .......................................................... 239</p>
<p> </p>
<p>Table 5-87 </p>
<p> </p>
<p>OSError_GetElapsedValue_CounterID ................................................... 239</p>
<p> </p>
<p>Table 5-88 </p>
<p> </p>
<p>OSError_GetElapsedValue_Value .......................................................... 240</p>
<p> </p>
<p>Table 5-89 </p>
<p> </p>
<p>OSError_GetElapsedValue_ElapsedValue .............................................. 240</p>
<p> </p>
<p>Table 5-90 </p>
<p> </p>
<p>OSError_TerminateApplication_Application ............................................ 241</p>
<p> </p>
<p>Table 5-91 </p>
<p> </p>
<p>OSError_TerminateApplication_RestartOption ........................................ 241</p>
<p> </p>
<p>Table 5-92 </p>
<p> </p>
<p>OSError_GetApplicationState_Application .............................................. 242</p>
<p> </p>
<p>Table 5-93 </p>
<p> </p>
<p>OSError_GetApplicationState_Value ...................................................... 242</p>
<p> </p>
<p>Table 5-94 </p>
<p> </p>
<p>OSError_GetSpinlock_SpinlockId ........................................................... 243</p>
<p> </p>
<p>Table 5-95 </p>
<p> </p>
<p>OSError_ReleaseSpinlock_SpinlockId .................................................... 243</p>
<p> </p>
<p>Table 5-96 </p>
<p> </p>
<p>OSError_TryToGetSpinlock_SpinlockId .................................................. 244</p>
<p> </p>
<p>Table 5-97 </p>
<p> </p>
<p>OSError_TryToGetSpinlock_Success ..................................................... 244</p>
<p> </p>
<p>Table 5-98 </p>
<p> </p>
<p>OSError_ControlIdle_CoreID .................................................................. 245</p>
<p> </p>
<p>Table 5-99 </p>
<p> </p>
<p>OSError_Os_GetExceptionContext_Context .......................................... 245</p>
<p> </p>
<p>Table 5-100 </p>
<p> </p>
<p>OSError_Os_SetExceptionContext_Context ........................................... 246</p>
<p> </p>
<p>Table 5-101 </p>
<p> </p>
<p>OSError_ControlIdle_IdleMode ............................................................... 246</p>
<p> </p>
<p>Table 5-102 </p>
<p> </p>
<p>OSError_IocSend_IN .............................................................................. 247</p>
<p> </p>
<p>Table 5-103 </p>
<p> </p>
<p>OSError_IocWrite_IN .............................................................................. 247</p>
<p> </p>
<p>Table 5-104 </p>
<p> </p>
<p>OSError_IocSendGroup_IN .................................................................... 248</p>
<p> </p>
<p>Table 5-105 </p>
<p> </p>
<p>OSError_IocWriteGroup_IN .................................................................... 248</p>
<p> </p>
<p>Table 5-106 </p>
<p> </p>
<p>OSError_IocReceive_OUT ..................................................................... 249</p>
<p> </p>
<p>Table 5-107 </p>
<p> </p>
<p>OSError_IocRead_OUT .......................................................................... 249</p>
<p> </p>
<p>Table 5-108 </p>
<p> </p>
<p>OSError_IocReceiveGroup_OUT ............................................................ 250</p>
<p> </p>
<p>Table 5-109 </p>
<p> </p>
<p>OSError_IocReadGroup_OUT ................................................................ 250</p>
<p> </p>
<p>Table 5-110 </p>
<p> </p>
<p>OSError_StartOS_Mode ......................................................................... 251</p>
<p> </p>
<p>Table 5-111 </p>
<p> </p>
<p>OSError_ActivateTask_TaskID ................................................................ 251</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>23 </p>
<p>based on template version 6.0.1 </p>
<p>Table 5-112 </p>
<p> </p>
<p>OSError_ChainTask_TaskID ................................................................... 252</p>
<p> </p>
<p>Table 5-113 </p>
<p> </p>
<p>OSError_GetTaskID_TaskID ................................................................... 252</p>
<p> </p>
<p>Table 5-114 </p>
<p> </p>
<p>OSError_GetTaskState_TaskID .............................................................. 253</p>
<p> </p>
<p>Table 5-115 </p>
<p> </p>
<p>OSError_GetTaskState_State ................................................................. 253</p>
<p> </p>
<p>Table 5-116 </p>
<p> </p>
<p>OSError_SetEvent_TaskID ..................................................................... 254</p>
<p> </p>
<p>Table 5-117 </p>
<p> </p>
<p>OSError_SetEvent_Mask........................................................................ 254</p>
<p> </p>
<p>Table 5-118 </p>
<p> </p>
<p>OSError_ClearEvent_Mask .................................................................... 255</p>
<p> </p>
<p>Table 5-119 </p>
<p> </p>
<p>OSError_GetEvent_TaskID ..................................................................... 255</p>
<p> </p>
<p>Table 5-120 </p>
<p> </p>
<p>OSError_GetEvent_Mask ....................................................................... 256</p>
<p> </p>
<p>Table 5-121 </p>
<p> </p>
<p>OSError_WaitEvent_Mask ...................................................................... 256</p>
<p> </p>
<p>Table 5-122 </p>
<p> </p>
<p>OSError_GetAlarmBase_AlarmID ........................................................... 257</p>
<p> </p>
<p>Table 5-123 </p>
<p> </p>
<p>OSError_GetAlarmBase_Info ................................................................. 257</p>
<p> </p>
<p>Table 5-124 </p>
<p> </p>
<p>OSError_GetAlarm_AlarmID ................................................................... 258</p>
<p> </p>
<p>Table 5-125 </p>
<p> </p>
<p>OSError_GetAlarm_Tick ......................................................................... 258</p>
<p> </p>
<p>Table 5-126 </p>
<p> </p>
<p>OSError_SetRelAlarm_AlarmID .............................................................. 259</p>
<p> </p>
<p>Table 5-127 </p>
<p> </p>
<p>OSError_SetRelAlarm_increment ........................................................... 259</p>
<p> </p>
<p>Table 5-128 </p>
<p> </p>
<p>OSError_SetRelAlarm_cycle .................................................................. 260</p>
<p> </p>
<p>Table 5-129 </p>
<p> </p>
<p>OSError_SetAbsAlarm_AlarmID ............................................................. 260</p>
<p> </p>
<p>Table 5-130 </p>
<p> </p>
<p>OSError_SetAbsAlarm_start ................................................................... 261</p>
<p> </p>
<p>Table 5-131 </p>
<p> </p>
<p>OSError_SetAbsAlarm_cycle .................................................................. 261</p>
<p> </p>
<p>Table 5-132 </p>
<p> </p>
<p>OSError_CancelAlarm_AlarmID ............................................................. 262</p>
<p> </p>
<p>Table 5-133 </p>
<p> </p>
<p>OSError_GetResource_ResID ................................................................ 262</p>
<p> </p>
<p>Table 5-134 </p>
<p> </p>
<p>OSError_ReleaseResource_ResID ........................................................ 263</p>
<p> </p>
<p>Table 5-135 </p>
<p> </p>
<p>OSError_Os_GetUnhandledIrq_InterruptSource ..................................... 263</p>
<p> </p>
<p>Table 5-136 </p>
<p> </p>
<p>OSError_Os_GetUnhandledExc_ExceptionSource................................. 264</p>
<p> </p>
<p>Table 5-137 </p>
<p> </p>
<p>OSError_BarrierSynchronize_BarrierID .................................................. 264</p>
<p> </p>
<p>Table 5-138 </p>
<p> </p>
<p>Os_GetVersionInfo ................................................................................. 265</p>
<p> </p>
<p>Table 5-139 </p>
<p> </p>
<p>Read Peripheral API ............................................................................... 266</p>
<p> </p>
<p>Table 5-140 </p>
<p> </p>
<p>Write Peripheral APIs .............................................................................. 268</p>
<p> </p>
<p>Table 5-141 </p>
<p> </p>
<p>Bitmask Peripheral API ........................................................................... 271</p>
<p> </p>
<p>Table 5-142 </p>
<p> </p>
<p>API Service Os_EnterPreStartTask ......................................................... 272</p>
<p> </p>
<p>Table 5-143 </p>
<p> </p>
<p>Call Non-Trusted Function API ................................................................ 273</p>
<p> </p>
<p>Table 5-144 </p>
<p> </p>
<p>API Service Os_DisableInterruptSource ................................................. 275</p>
<p> </p>
<p>Table 5-145 </p>
<p> </p>
<p>API Service Os_EnableInterruptSource .................................................. 276</p>
<p> </p>
<p>Table 5-146 </p>
<p> </p>
<p>API Service Os_ClearPendingInterrupt ................................................... 277</p>
<p> </p>
<p>Table 5-147 </p>
<p> </p>
<p>API Service Os_IsInterruptSourceEnabled ............................................. 278</p>
<p> </p>
<p>Table 5-148 </p>
<p> </p>
<p>API Service Os_IsInterruptPending ........................................................ 279</p>
<p> </p>
<p>Table 5-149 </p>
<p> </p>
<p>API Service Os_GetDetailedError ........................................................... 280</p>
<p> </p>
<p>Table 5-150 </p>
<p> </p>
<p>API Service Os_GetUnhandledIrq .......................................................... 281</p>
<p> </p>
<p>Table 5-151 </p>
<p> </p>
<p>API Service Os_GetUnhandledExc ......................................................... 282</p>
<p> </p>
<p>Table 5-152 </p>
<p> </p>
<p>Overview: Stack Usage Functions .......................................................... 283</p>
<p> </p>
<p>Table 5-153 </p>
<p> </p>
<p>Conversion Macros from Time to Counter Ticks ...................................... 285</p>
<p> </p>
<p>Table 5-154 </p>
<p> </p>
<p>Conversion Macros from Counter Ticks to Time ...................................... 285</p>
<p> </p>
<p>Table 5-155 </p>
<p> </p>
<p>API Service Os_Init................................................................................. 286</p>
<p> </p>
<p>Table 5-156 </p>
<p> </p>
<p>API Service Os_InitMemory .................................................................... 286</p>
<p> </p>
<p>Table 5-157 </p>
<p> </p>
<p>Barriers ................................................................................................... 298</p>
<p> </p>
<p>Table 5-158 </p>
<p> </p>
<p>Os_GetExceptionContext ....................................................................... 299</p>
<p> </p>
<p>Table 5-159 </p>
<p> </p>
<p>Os_SetExceptionContext ........................................................................ 300</p>
<p> </p>
<p>Table 5-160 </p>
<p> </p>
<p>Calling Context Overview........................................................................ 301</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>24 </p>
<p>based on template version 6.0.1 </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p>This  document  describes  the  usage  and  functions  of  “MICROSAR  OS”,  an  operating </p>
<p>system which implements the AUTOSAR BSW module “OS” as specified in [1]. </p>
<p>This </p>
<p>documentation </p>
<p>assumes </p>
<p>that </p>
<p>the </p>
<p>reader </p>
<p>is </p>
<p>familiar </p>
<p>with </p>
<p>both </p>
<p>the </p>
<p>OSEK </p>
<p>OS</p>
<p>1</p>
<p> </p>
<p>specification and the AUTOSAR OS specification. </p>
<p><b>1.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>shows </p>
<p>the </p>
<p>location </p>
<p>of </p>
<p>the </p>
<p>OS </p>
<p>module </p>
<p>within </p>
<p>the </p>
<p>AUTOSAR </p>
<p>architecture. </p>
<p> </p>
<p>Figure 1-1 </p>
<p>AUTOSAR Architecture Overview </p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>1</p>
<p> OSEK is a registered trademark of Continental Automotive GmbH (until  2007: Siemens AG) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>25 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.2 </b></p>
<p><b>Abstract </b></p>
<p>The  MICROSAR  OS  operating  system  is  a  real  time  operating  system,  which  was </p>
<p>specified for the usage in electronic control. </p>
<p>As a requirement, there is no dynamic creation of new tasks at runtime; all tasks have to </p>
<p>be defined before compilation (pre-compile configuration variant). </p>
<p>The OS has no dynamic memory management and there is no shell for the control of tasks </p>
<p>by hand. </p>
<p>Typically  the  source  and  configuration  files  of  the  operating  system  and  the  application </p>
<p>source files are compiled and linked together to one executable file, which is loaded into </p>
<p>an emulator or is burned into an EPROM or Flash EEPROM. </p>
<p><b>1.3 </b></p>
<p><b>Characteristics </b></p>
<p>MICROSAR OS has the following characteristics: </p>
<p><b>Supported Scalability Classes </b></p>
<p>SC1, SC2, SC3, SC4 (as described in [1]) </p>
<p><b>Single Core ECUs </b></p>
<p>Supported </p>
<p><b>Multi Core ECUs </b></p>
<p>Supported </p>
<p><b>IOC </b></p>
<p>Supported </p>
<p>Table 1-1  </p>
<p>MICROSAR OS Characteristics </p>
<p>MICROSAR  OS  supports  various  different  processor  families  of  different  vendors  in </p>
<p>conjunction with multiple compilers. </p>
<p>The  availability  for  a  particular  processor  in  conjunction  with  a  specific  compiler  can  be </p>
<p>queried from Vector Informatik. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>26 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4 </b></p>
<p><b>Hardware Overview </b></p>
<p>The  following  table  summarizes  information  about  MICROSAR  OS.  It  gives  detailed </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>derivatives </p>
<p>and </p>
<p>compilers.  As </p>
<p>very </p>
<p>important </p>
<p>information </p>
<p>the </p>
<p>documentations of the hardware manufacturers are listed. MICROSAR OS is based upon </p>
<p>these documents in the given version. </p>
<p>Table Rows </p>
<p><b>&gt; </b></p>
<p><b>Compiler</b>: List of Compilers MICROSAR OS is working with. </p>
<p><b>&gt; </b></p>
<p><b>Derivative</b>: This can be a single information or a list of derivatives, MICROSAR OS </p>
<p>can be used on. </p>
<p><b>&gt; </b></p>
<p><b>Hardware Manufacturer Document Name</b>: List of hardware documentation </p>
<p>MICROSAR OS is based on. </p>
<p><b>&gt; </b></p>
<p><b>Document Version</b>: To be able to reference to this hardware documentation its </p>
<p>version is very important. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>27 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.1 </b></p>
<p><b>TriCore Aurix </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>TC21x </p>
<p>TC22x </p>
<p>TC23x </p>
<p>User Manual: tc23x_tc22x_tc21x_um_v1.1.pdf </p>
<p>V1.1 </p>
<p>Errata Sheet: TC22x_TC21x_AB_Errata_Sheet_v1_2_03804A.pdf </p>
<p>V1.2 </p>
<p>TC24x </p>
<p>Target Specification: tc24x_ts_v2.0_OPEN_MARKET.pdf </p>
<p>V2.0 </p>
<p>TC26x </p>
<p>User Manual: </p>
<p>tc26xB_um_v1.3._usermanual_rev1v3.pdf </p>
<p>V1.3 </p>
<p>Errata Sheet: </p>
<p>TC26x_BB_Errata_Sheet_rev1v2_03989A_2016-04-18.pdf </p>
<p>V1.2 </p>
<p>TC27x </p>
<p>User Manual: </p>
<p>tc27xD_um_v2.2_UserManual_rev2v2_2014-12.pdf </p>
<p>V2.2 </p>
<p>Errata Sheet: </p>
<p>TC27x_BC_Errata_Sheet_rev1v5_2015_09_16.pdf </p>
<p>V1.5 </p>
<p>TC29x </p>
<p>User Manual: </p>
<p>tc29xB_um_v1.3._TC29x_B-Step_User_Manual_rev_1v3_2014_12.pdf </p>
<p>V1.3 </p>
<p>Errata Sheet: </p>
<p>TC29x_BA_Errata_Sheet_v1_0.pdf </p>
<p>V1.0 </p>
<p>TC38x </p>
<p>User Manual:  </p>
<p>TC3XX_ts__TargetSpec_rev1v3v0.pdf V1.3.0, 2016-02 </p>
<p>V1.3 </p>
<p>Appendix: </p>
<p>TC38X_ts_appx_V2.3.0.pdf V2.3.0 2017-09 </p>
<p>V2.3 </p>
<p>TC39x </p>
<p>User Manual:  </p>
<p>TC3XX_ts__TargetSpec_rev1v3v0.pdf V1.3.0, 2016-02 </p>
<p>V1.3 </p>
<p>Errata Sheet:  </p>
<p>TC39x AA_Errata_Sheet_rev1v0_2016-06-08.pdf Rel. 1.0, 2016-06-08 </p>
<p>V1.0 </p>
<p>Table 1-2  </p>
<p>Supported TriCore Aurix Hardware </p>
<p> </p>
<p><b>Tasking </b></p>
<p>v4.2r2 (TC2xx only) </p>
<p>v6.0r1p2 (TC3xx only) </p>
<p><b>HighTec (GNU) </b></p>
<p>V4.6.3.0 </p>
<p>Table 1-3  </p>
<p>Supported TriCore Aurix Compilers </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>28 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.2 </b></p>
<p><b>Power PC </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>MPC560xB </p>
<p>Freescale Semiconductor MPC5607B  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 7.2, 05/2012 </p>
<p>Freescale Semiconductor e200z0  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 04/2008 </p>
<p>MPC560xC </p>
<p>Freescale Semiconductor MPC5604B/C  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 8.2, 09/2013 </p>
<p>Freescale Semiconductor e200z0  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 04/2008 </p>
<p>MPC564xB </p>
<p>Freescale Semiconductor MPC5646C  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 5, 11/2013 </p>
<p>Freescale Semiconductor e200z4  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 10/2009 </p>
<p>MPC564xC </p>
<p>Freescale Semiconductor MPC5646C  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 5, 11/2013 </p>
<p>Freescale Semiconductor e200z0  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 04/2008 </p>
<p>Freescale Semiconductor e200z4  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 10/2009 </p>
<p>MPC564xL </p>
<p>Freescale Semiconductor MPC5643L  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 10, 06/2013 </p>
<p>Freescale Semiconductor e200z4  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 0, 10/2009 </p>
<p>Freescale Semiconductor Safety Manual for Qorivva </p>
<p>MPC5643L </p>
<p>Rev. 2, 04/2013 </p>
<p>MPC567xF </p>
<p>Freescale Semiconductor MPC5674F  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 7, 02/2015 </p>
<p>Freescale Semiconductor e200z760n3  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 2, 06/2012 </p>
<p>MPC567xK </p>
<p>Freescale Semiconductor Qorivva MPC5675K  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 10, 11/2013 </p>
<p>Freescale Semiconductor e200z760n3  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 2, 06/2012 </p>
<p>Freescale Semiconductor Safety Manual for Qorivva </p>
<p>MPC567xK </p>
<p>Rev. 1, 12/2012 </p>
<p>MPC567xR </p>
<p>Freescale Semiconductors MPC5676R  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 5, 09/2012 </p>
<p>Freescale Semiconductor e200z759n3  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 2, 01/2015 </p>
<p>MPC574xBD </p>
<p>Freescale Semiconductor MPC5746C  </p>
<p>Rev. 2.1, 06/2015 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>29 </p>
<p>based on template version 6.0.1 </p>
<p>Reference Manual </p>
<p>MPC574xC1 </p>
<p>Freescale Semiconductor MPC5746C  </p>
<p>Reference Manual </p>
<p>Rev. 2.1, 06/2015 </p>
<p>MPC574xC2 </p>
<p>NXP MPC5748G Reference Manual </p>
<p>Rev. 4, 07/2015 </p>
<p>MPC574xG </p>
<p>NXP MPC5748G Reference Manual </p>
<p>Rev. 4, 07/2015 </p>
<p>NXP Safety Manual for MPC5748G </p>
<p>Rev. 2, 01/2016 </p>
<p>MPC574xK </p>
<p>ST SPC574Kxx  </p>
<p>Reference Manual </p>
<p>Rev. 5, 08/2015 </p>
<p>MPC574xM </p>
<p>Freescale Semiconductor MPC5746M  </p>
<p>Reference Manual </p>
<p>Rev. 5.1, 04/2014 </p>
<p>MPC574xP </p>
<p>Freescale Semiconductor MPC5744P </p>
<p>Reference Manual </p>
<p>Rev. 5.1, 02/2015 </p>
<p>NXP Safety Manual for MPC5744P </p>
<p>Rev. 3, 06/2014 </p>
<p>MPC574xR </p>
<p>NXP MPC5746R  </p>
<p>Reference Manual </p>
<p>Rev. 6, 03/2016 </p>
<p>MPC577xC </p>
<p>Freescale Semiconductors MPC5777C  </p>
<p>Microcontroller Reference Manual </p>
<p>Rev. 8, 11/2016 </p>
<p>Freescale Semiconductor e200z759n3  </p>
<p>Power Architecture Core Reference Manual </p>
<p>Rev. 2, 01/2015 </p>
<p>Freescale Semiconductor Safety Manual for MPC5777C </p>
<p>Rev. 2.1, 02/2017 </p>
<p>MPC577xK </p>
<p>Freescale Semiconductor MPC5775K  </p>
<p>Reference Manual </p>
<p>Rev. 4, 12/2015 </p>
<p>MPC577xM </p>
<p>NXP MPC5777M  </p>
<p>Reference Manual </p>
<p>Rev. 4, 04/2015 </p>
<p>MPC577xN </p>
<p>Freescale Semiconductor MPC5774N  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2014 </p>
<p>PC580000 </p>
<p>Freescale Semiconductor QUASAR0  </p>
<p>Reference Manual </p>
<p>Rev. 3, 03/2015 </p>
<p> </p>
<p>PC580002 </p>
<p>Freescale Semiconductor QUASAR2 Cut2  </p>
<p>Reference Manual </p>
<p>Rev. 5, 07/2014 </p>
<p>PC580002e </p>
<p>NXP QUASAR2e Reference Manual </p>
<p>Rev. 2, 06/2017 </p>
<p>PC580003 </p>
<p>NXP QUASAR3 Reference Manual </p>
<p>Rev. 5.2, 01/2017 </p>
<p>SPC58ECxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 2, 10/2016 </p>
<p>SPC58EGxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>SPC58NGxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>SPC582Bxx </p>
<p>ST SPC582Bx  </p>
<p>Reference Manual </p>
<p>Rev. 2, 09/2016 </p>
<p>SPC584Bxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 1, 10/2015 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>30 </p>
<p>based on template version 6.0.1 </p>
<p>SPC584Cxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 2, 10/2016 </p>
<p>SPC584Gxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>SPC574Sxx </p>
<p>ST SPC574Sx Reference Manual </p>
<p>Rev. 3, 05/2016 </p>
<p>Table 1-4  </p>
<p>Supported Power PC Hardware </p>
<p><b>Windriver DiabData </b></p>
<p>5.9.4.x </p>
<p><b>Green Hills (GHS) </b></p>
<p>2014.1.6 </p>
<p><b>HighTec (GNU) </b></p>
<p>4.6.6.1 </p>
<p>Table 1-5  </p>
<p>Supported Power PC compilers </p>
<p><b>1.4.3 </b></p>
<p><b>ARM </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>S6J32xx </p>
<p>Cypress S6J3200 Series Hardware Manual </p>
<p>Rev. 4.0, </p>
<p>09/2015 </p>
<p>ZUxxx </p>
<p>XILINX Zynq UltraScale+ MPSoc Technical Reference </p>
<p>Manual </p>
<p>v1.2, 06/2016 </p>
<p>iMX6xx </p>
<p>i.MX 6Dual/6Quad  Applications Processor Reference </p>
<p>Manual </p>
<p>Rev. 3, </p>
<p>07/2015 </p>
<p>ATSAMV7x </p>
<p>SAM v70 Datasheet </p>
<p>Rev.11297D, </p>
<p>06/2016 </p>
<p>S32K14x </p>
<p>NXP/Freescale - S32K14x Series Reference Manual - </p>
<p>Supports S32K142, S32K144, S32K146, and S32K148 </p>
<p>Rev. 3, </p>
<p>03/2017 </p>
<p>Generic Cortex-M </p>
<p>ARMv7-M Architecture Reference Manual </p>
<p>v.E.b </p>
<p>12/2015 </p>
<p>AR16xx </p>
<p>16xx Technical Reference Manual </p>
<p>SWRU431, </p>
<p>November </p>
<p>2016 </p>
<p>TDA2x </p>
<p>TDA2x Technical Reference Manual </p>
<p>SPRUI29D, </p>
<p>November </p>
<p>2015 </p>
<p>Table 1-6  </p>
<p>Supported ARM Hardware </p>
<p><b>Green Hills (GHS) </b></p>
<p>2013.5.4 </p>
<p><b>IAR </b></p>
<p>V7.50.1 </p>
<p><b>TI </b></p>
<p>v15.12.3.LTS </p>
<p><b>ARM CC </b></p>
<p>5.06u1 </p>
<p><b>GCC Linaro Distribution </b></p>
<p>gcc-linaro-7.1.1-2017.08-i686-mingw32_arm-eabi </p>
<p>Table 1-7  </p>
<p>Supported ARM compilers </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>31 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>32 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.4 </b></p>
<p><b>RH850 </b></p>
<p><b>Derivative Family </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document Version </b></p>
<p>RH850 C1M </p>
<p>RH850/C1x User’s Manual: Hardware </p>
<p>Rev.1.00 Mar 2015 </p>
<p>RH850 C1H </p>
<p>RH850/C1x User’s Manual: Hardware </p>
<p>Rev.1.00 Mar 2015 </p>
<p>RH850 D1x </p>
<p>RH850/D1L/D1M Group User’s Manual: Hardware </p>
<p>Rev.2.01 Aug 2016 </p>
<p>RH850 E1x FCC2 </p>
<p>RH850/E1x-FCC2 User’s Manual: Hardware </p>
<p>Rev.1.00 Jun 2016 </p>
<p>RH850 E1x FCC1 </p>
<p>RH850/E1x-FCC1 User’s Manual: Hardware </p>
<p>Rev.0.50 Jul 2014 </p>
<p>RH850 E1L </p>
<p>RH850/E1L User’s Manual: Hardware </p>
<p>Rev.1.10 Apr 2016 </p>
<p>RH850 E1M </p>
<p>RH850/E1M-S User’s Manual: Hardware </p>
<p>Rev.1.10 Apr 2016 </p>
<p>RH850 F1H </p>
<p>RH850/F1H Group User’s Manual: Hardware </p>
<p>Rev.1.12 May 2016 </p>
<p>RH850 F1L </p>
<p>RH850/F1L Group User’s Manual: Hardware </p>
<p>Rev.1.33 Apr 2016 </p>
<p>RH850 F1K </p>
<p>RH850/F1K Group User’s Manual: Hardware </p>
<p>Rev.1.00 Jun 2016 </p>
<p>RH850 F1KM </p>
<p>RH850/F1KM Group User’s Manual: Hardware </p>
<p>Rev.0.50 Jan 2017 </p>
<p>RH850 F1M </p>
<p>RH850/F1M Group User’s Manual: Hardware </p>
<p>Rev.1.03 May 2016 </p>
<p>RH850 P1HC </p>
<p>RH850/P1x-C Group User’s Manual: Hardware </p>
<p>Rev.1.10 Jul 2016 </p>
<p>RH850 P1MC </p>
<p>RH850/P1x-C Group User’s Manual: Hardware </p>
<p>Rev.1.10 Jul 2016 </p>
<p>RH850 P1M </p>
<p>RH850/P1x Group User’s Manual: Hardware </p>
<p>Rev.1.00 Jul, 2015 </p>
<p>RH850 R1L </p>
<p>RH850/R1x Group User’s Manual: Hardware </p>
<p>Rev.1.31 Jun 2016 </p>
<p>G3K Core </p>
<p>RH850G3K User’s Manual: Software </p>
<p>Rev.1.20 Apr 2016 </p>
<p>G3KH Core </p>
<p>RH850G3KH User’s Manual: Software </p>
<p>Rev.1.10 Jul 2016 </p>
<p>G3M Core </p>
<p>RH850G3M User’s Manual: Software </p>
<p>Rev.1.30 Jun 2016 </p>
<p>G3MH Core </p>
<p>RH850G3MH User’s Manual: Software </p>
<p>Rev.1.00 Mar 2015 </p>
<p>Table 1-8  </p>
<p>Supported RH850 Hardware </p>
<p><b>Green Hills (GHS) </b></p>
<p>V6.1.4 2013.5.4 </p>
<p>V6.1.4 2013.5.5 </p>
<p>V6.1.6 2014.1.7 </p>
<p>V6.1.6 2015.1.5 </p>
<p>V6.1.6 2015.1.7 </p>
<p>Table 1-9  </p>
<p>Supported RH850 Compilers </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>33 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.5 </b></p>
<p><b>VTT OS </b></p>
<p>VTT  OS  stands  for  “vVIRTUALtarget  Operating  System”.  It  runs  within  Vectors  CANoe </p>
<p>development tool. </p>
<p>Vectors CANoe is capable of simulating an entire ECU network. Within such a simulated </p>
<p>network the OS of each ECU can be simulated. </p>
<p>This is useful in early ECU development phases when no real hardware is available yet. </p>
<p>Application development can be started at once. </p>
<p>The VTT OS behaves as regular AUTOSAR OS. All OS objects (e.g. tasks or ISRs) are </p>
<p>simulated. </p>
<p>The VTT system is described in [6]. </p>
<p><b>1.4.5.1 </b></p>
<p><b>Characteristics of VTT OS </b></p>
<p><b>Supported Scalability Classes </b></p>
<p>SC1, SC2 </p>
<p><b>Single Core ECUs </b></p>
<p>Supported </p>
<p><b>Multi Core ECUs </b></p>
<p>Up to 32 cores are supported </p>
<p><b>IOC </b></p>
<p>Supported </p>
<p><b>Number of Simulated Interrupt Sources </b></p>
<p>Up to 10000 </p>
<p><b>Simulated Interrupt Levels </b></p>
<p>VTT OS allows interrupt levels from 1 .. 200 </p>
<p>Whereas 1 is the lowest priority and 200 is the </p>
<p>highest. </p>
<p><b>Memory Protection </b></p>
<p>Not supported</p>
<p>2</p>
<p> </p>
<p><b>Stack Protection </b></p>
<p>Not supported </p>
<p><b>Stack Usage Measurement </b></p>
<p>Not supported </p>
<p><b>Stack Sharing </b></p>
<p>Not supported </p>
<p>Table 1-10  </p>
<p>VTT OS characteristics </p>
<p><b>1.4.6 </b></p>
<p><b>POSIX OS </b></p>
<p>POSIX OS is an AUTOSAR Operating System running as a process in the user space of a </p>
<p>POSIX</p>
<p>3</p>
<p> host. </p>
<p>There </p>
<p>are </p>
<p>no </p>
<p>dependencies </p>
<p>with </p>
<p>the </p>
<p>underlying </p>
<p>hardware </p>
<p>or </p>
<p>with </p>
<p>specific </p>
<p>POSIX </p>
<p>conforming host OS (QNX, Linux…). </p>
<p>In the Adaptive AUTOSAR scenario, it is necessary to exploit new resources (i.e. pthreads) </p>
<p>offered by such environment and to deal with the new abstraction layers. </p>
<p> </p>
<p>                                            </p>
<p>2</p>
<p> The memory protection can be configured. However the actual protection mechanism is not executed. </p>
<p>3</p>
<p> Portable Operating System Interface </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>34 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.6.1 </b></p>
<p><b>Characteristic of POSIX OS </b></p>
<p><b>Supported Scalability Classes </b></p>
<p>SC1 </p>
<p><b>Single Core ECUs </b></p>
<p>Supported </p>
<p><b>Multi Core ECUs </b></p>
<p>Not supported </p>
<p><b>IOC </b></p>
<p>Supported </p>
<p><b>Number of Simulated Interrupt </b></p>
<p><b>Sources </b></p>
<p>Up to 10000 </p>
<p><b>Simulated Interrupt Levels </b></p>
<p>POSIX OS allows interrupt levels from 1 .. 100 </p>
<p>Whereas 1 is the lowest priority and 100 is the </p>
<p>highest. </p>
<p><b>Memory Protection </b></p>
<p>Not supported</p>
<p>4</p>
<p> </p>
<p><b>Stack Protection </b></p>
<p>Not supported </p>
<p><b>Stack Usage Measurement </b></p>
<p>Not supported </p>
<p><b>Stack Sharing </b></p>
<p>Not supported </p>
<p>Table 1-11  </p>
<p>POSIX OS characteristic </p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>4</p>
<p> The memory protection can be configured. However the actual protection mechanism is not executed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>35 </p>
<p>based on template version 6.0.1 </p>
<p><b>2 </b></p>
<p><b>Functional Description </b></p>
<p><b>2.1 </b></p>
<p><b>General </b></p>
<p>The  MICROSAR  OS  basically  implements  the  OS  according  to  the  AUTOSAR </p>
<p>OS </p>
<p>standard referred in [1]. </p>
<p>It  is  possible  that  MICROSAR  OS  deviates  from  specified  AUTOSAR  OS  behavior.  All </p>
<p>deviations from the standard are listed in the chapters hereafter. </p>
<p>On the other hand MICROSAR OS extends the AUTOSAR OS standard with numerous </p>
<p>functions. These extensions in function are described in detail in chapter 2.21.1. </p>
<p><b>2.2 </b></p>
<p><b>MICROSAR OS Deviations from AUTOSAR OS Specification </b></p>
<p><b>2.2.1 </b></p>
<p><b>Generic Deviation for API Functions </b></p>
<p><b>Specified Behavior </b></p>
<p>There are some API functions which are only available within specific </p>
<p>scalability classes (e.g. TerminateApplication() in SC3 and SC4 only). </p>
<p><b>Deviation Description </b></p>
<p>Within the MICROSAR OS all API functions are always available. </p>
<p><b>Deviation Reason </b></p>
<p>The static OS code gets more simplified for better maintainability (less </p>
<p>pre-processor statements are necessary). </p>
<p>Modern toolchains will remove unused function automatically. </p>
<p> </p>
<p><b>2.2.2 </b></p>
<p><b>Trusted Function API Deviations </b></p>
<p><b>Specified Behavior </b></p>
<p>The Operating System shall not schedule any other Tasks which </p>
<p>belong to the same OS-Application as the non-trusted caller of the </p>
<p>service. Also interrupts of Category 2 which belong to the same OS-</p>
<p>Application shall be disabled during the execution of the service. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS the re-scheduling of tasks in this particular case is </p>
<p>not suppressed. </p>
<p>The selective disabling of category 2 ISRs is also not done. </p>
<p><b>Deviation Reason </b></p>
<p>For a better runtime performance during trusted function calls the </p>
<p>specified behavior is not implemented in MICROSAR OS. </p>
<p>Data consistency problems can be solved in a more efficient way by </p>
<p>using the OS interrupt API and/or OS resource API. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>36 </p>
<p>based on template version 6.0.1 </p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case CallTrustedFunction() API is called with disabled interrupts it </p>
<p>returns the status code E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call CallTrustedFunction() API with disabled interrupts. </p>
<p>There is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call CallTrustedFunction() API where </p>
<p>interrupts may be disabled. This is more convenient and reasonable. </p>
<p> </p>
<p><b>2.2.3 </b></p>
<p><b>Service Protection Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>If an invalid address (address is not writable by this OS-Application) is </p>
<p>passed as an out-parameter to an Operating System service, the </p>
<p>Operating System module shall return the status code </p>
<p>E_OS_ILLEGAL_ADDRESS. </p>
<p><b>Deviation Description </b></p>
<p>The validity of out-parameters is checked automatically by the MPU. </p>
<p>Write accesses to such parameters are always done with the </p>
<p>accessing rights of the caller of the OS service. </p>
<p>If the address is invalid a MPU exception is raised. </p>
<p>The return value E_OS_ILLEGAL_ADDRESS is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>Hardware checks by the MPU are much more performant than </p>
<p>software memory checks. </p>
<p> </p>
<p><b>2.2.4 </b></p>
<p><b>Code Protection </b></p>
<p><b>Specified Behavior </b></p>
<p>The Operating System module may provide an OS-Application </p>
<p>the ability to protect its code sections against executing by non-</p>
<p>trusted OS-Applications.  </p>
<p><b>Deviation Description </b></p>
<p>The MICROSAR OS does not support code section protection. </p>
<p><b>Deviation Reason </b></p>
<p>Design decision. </p>
<p> </p>
<p><b>2.2.5 </b></p>
<p><b>SyncScheduleTable API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case SyncScheduleTable() is called with disabled interrupts it </p>
<p>returns the status code E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call SyncScheduleTable() with disabled interrupts. </p>
<p>There is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call SyncScheduleTable() where interrupts </p>
<p>may be disabled. This is more convenient and reasonable. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>37 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.6 </b></p>
<p><b>CheckTask/ISRMemoryAccess API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case one of these APIs is called with disabled interrupts it issues </p>
<p>the error E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call these API functions with disabled interrupts. There </p>
<p>is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call these functions e.g. from hardware </p>
<p>drivers where interrupts may be disabled. This is more convenient and </p>
<p>reasonable. </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>The API functions CheckTask/ISRMemoryAccess() are only allowed </p>
<p>within specific OS call contexts (Task/Cat2 </p>
<p>ISR/ErrorHook/ProtectionHook) </p>
<p>In case one of these APIs is called within the wrong OS call context it </p>
<p>issues the error E_OS_CALLEVEL. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call these API functions from all OS contexts. </p>
<p>The return value E_OS_CALLEVEL is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>Practically it is more reasonable to allow these APIs in all OS runtime </p>
<p>contexts. </p>
<p> </p>
<p><b>2.2.7 </b></p>
<p><b>Interrupt API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>The API functions SuspendOSInterrupts() and ResumeOSInterrupts() </p>
<p>are allowed within a category 1 ISR </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS it is not allowed to use SuspendOSInterrupts() and </p>
<p>ResumeOSInterrupts() within a category 1 ISR. </p>
<p><b>Deviation Reason </b></p>
<p>The function SuspendOSInterrupts() lowers the current interrupt level </p>
<p>when used in a category 1 ISR. This may lead to data inconsistencies </p>
<p>if another category 1 ISR occurs. </p>
<p>Therefore those functions are not allowed. </p>
<p> </p>
<p><b>2.2.8 </b></p>
<p><b>Cross Core Getter APIs </b></p>
<p><b>Specified Behavior </b></p>
<p>All getter APIs (e.g. GetTaskID()) may be called cross core within </p>
<p>hooks and non nestable category 2 ISRs. </p>
<p><b>Deviation Description </b></p>
<p>MICROSAR OS does not allow usage of those functions within OS </p>
<p>Hooks and non-nestable category 2 ISRs. </p>
<p><b>Deviation Reason </b></p>
<p>Deadlock avoidance due to disabled interrupts in case that there are </p>
<p>two simultaneous concurrent usages of those APIs from multiple </p>
<p>cores. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>38 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.9 </b></p>
<p><b>IOC </b></p>
<p><b>Specified Behavior </b></p>
<p>IocSend/IocWrite APIs have an IN parameter. The parameter will be </p>
<p>passed by value for primitive data elements and by reference for all </p>
<p>other types. The data type is configured in “OsIocDataTypeRef”. </p>
<p><b>Deviation Description </b></p>
<p>The configurator does not evaluate information in </p>
<p>“OsIocDataTypeRef”. Instead it evaluates the parameter </p>
<p>“OsIocDataType“. Primitive data types are passed by value. The </p>
<p>configurator identifies all primitive AUTOSAR and OS data types (e.g. </p>
<p>“uint8”, “sint32”, “TaskType”). All other data types are passed by </p>
<p>reference. </p>
<p><b>Deviation Reason </b></p>
<p>Usage of “OsIocDataType” reduces dependencies and complexity of </p>
<p>the OS configurator. </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>The configuration parameter “OsIocInitValue” is specified to be an </p>
<p>initialization value. </p>
<p><b>Deviation Description </b></p>
<p>If the used data is of a complex type the configuration parameter </p>
<p>“OsIocInitValue” holds the name of a constant, which contains the </p>
<p>initialization value. For integral types it can hold a value or the name of </p>
<p>a constant containing the value. </p>
<p><b>Deviation Reason </b></p>
<p>It enables the OS to initialize complex data types. </p>
<p> </p>
<p><b>2.2.10 </b></p>
<p><b>Return value upon stack violation </b></p>
<p><b>Specified Behavior </b></p>
<p>If a stack fault is detected by stack monitoring AND no ProtectionHook </p>
<p>is configured, the Operating System module shall call the </p>
<p>ShutdownOS() service with the status E_OS_STACKFAULT. </p>
<p><b>Deviation Description </b></p>
<p>Within a SC3 / SC4 system with MPU stack supervision: </p>
<p>If a stack fault is detected by stack monitoring AND no ProtectionHook </p>
<p>is configured, the Operating System module shall call the </p>
<p>ShutdownOS() service with the status </p>
<p>E_OS_PROTECTION_MEMORY. </p>
<p><b>Deviation Reason </b></p>
<p>With hardware stack supervision MICROSAR OS is not possible to </p>
<p>distinguish between stack violation and other memory violation </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>If a stack fault is detected by stack monitoring AND a ProtectionHook </p>
<p>is configured the Operating System module shall call the </p>
<p>ProtectionHook() with the status E_OS_STACKFAULT. </p>
<p><b>Deviation Description </b></p>
<p>Within a SC3 / SC4 system with MPU stack supervision: </p>
<p>If a stack fault is detected by stack monitoring AND a ProtectionHook </p>
<p>is configured the Operating System module shall call the </p>
<p>ProtectionHook() with the status E_OS_PROTECTION_MEMORY. </p>
<p><b>Deviation Reason </b></p>
<p>With hardware stack supervision MICROSAR OS is not possible to </p>
<p>distinguish between stack violation and other memory violation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>39 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.11 </b></p>
<p><b>Handling of OS internal errors </b></p>
<p><b>Specified Behavior </b></p>
<p>In cases where the OS detects a fatal internal error all cores shall be </p>
<p>shut down. </p>
<p><b>Deviation Description </b></p>
<p>In case that the OS detects an internal error the kernel panic mode is </p>
<p>entered. </p>
<p><b>Deviation Reason </b></p>
<p>In case of OS internal errors normal operations (e.g. calling the </p>
<p>protection hook) are possible no more, as the OS is in an inconsistent </p>
<p>state. </p>
<p> </p>
<p><b>2.2.12 </b></p>
<p><b>Forcible Termination of Applications </b></p>
<p><b>Specified Behavior </b></p>
<p>AUTOSAR does not specify the handling of “next” schedule tables in </p>
<p>case of forcible termination of applications. </p>
<p><b>Deviation Description </b></p>
<p>Use case: </p>
<p>An application has a running schedule table which itself has a nexted </p>
<p>schedule table of a foreign application. </p>
<p>The foreign application is forcibly terminated. </p>
<p> </p>
<p>The OS removes the “next” request from the running schedule table. </p>
<p><b>Deviation Reason </b></p>
<p>Clarification of behavior. </p>
<p>Impact on other applications should be minimal, therefore the current </p>
<p>schedule table is not stopped. This is different to the behavior of </p>
<p>StopScheduleTable(). </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>AUTOSAR does not specify the handling of “next” schedule tables in </p>
<p>case of forcible termination of applications. </p>
<p><b>Deviation Description </b></p>
<p>Use case: </p>
<p>An application has a running schedule table which itself has a nexted </p>
<p>schedule table of a foreign application. </p>
<p>The first application is forcibly terminated. </p>
<p> </p>
<p>The OS stops the current schedule table of the terminated application. </p>
<p>and removes the “next” request. </p>
<p>As a result it does not switch to the “next” schedule table of the foreign </p>
<p>application. </p>
<p><b>Deviation Reason </b></p>
<p>Clarification of behavior. </p>
<p>Impact on other applications should be minimal. The described </p>
<p>behavior is identical to the behavior of StopScheduleTable(). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>40 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.13 </b></p>
<p><b>OS Configuration </b></p>
<p><b>Specified Behavior </b></p>
<p>The generator shall print out information about timers used </p>
<p>internally by the OS during generation (e.g. on console, list file). </p>
<p><b>Deviation Description </b></p>
<p>In case of MICROSAR OS there is no such output. Instead the </p>
<p>timer is visible to the user as any other timer during configuration. </p>
<p><b>Deviation Reason </b></p>
<p>In order to increase the transparency, OS internal objects are </p>
<p>visible to the user during configuration time. </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>If ShutdownOS() is called and ShutdownHook() returns then the </p>
<p>Operating System module shall disable all interrupts and enter an </p>
<p>endless loop. </p>
<p><b>Deviation Description </b></p>
<p>If ShutdownOS() is called and ShutdownHook() returns then the </p>
<p>Operating System module enters the kernel panic mode. </p>
<p><b>Deviation Reason </b></p>
<p>In case of unusual situations the MICROSAR OS enters the </p>
<p>kernel panic mode. To keep the behaviour of the OS consistent, </p>
<p>the kernel panic mode is also applied in case that the </p>
<p>ShutdownHook() returns. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>41 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.3 </b></p>
<p><b>Stack Concept </b></p>
<p>MICROSAR OS implements a specific stack concept. </p>
<p>It  defines  different  stacks  which  may  be  used  by  stack  consumers  (runtime  contexts). </p>
<p>Whereas not all stacks may be used by all consumers. </p>
<p>The following table gives an overview. </p>
<p><b>Stack Type </b></p>
<p><b>Multiplicity </b></p>
<p><b>Possible Stack Consumers </b></p>
<p>Kernel stack </p>
<p>1 per core </p>
<p><b>&gt; </b></p>
<p>OS memory exception handling </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p><b>&gt; </b></p>
<p>Category 0 ISRs </p>
<p>Protection stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ProtectionHook() </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p><b>&gt; </b></p>
<p>Category 0 ISRs </p>
<p>Error stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ErrorHooks (global and OS-application specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Shutdown stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ShutdownHooks (global and OS-application </p>
<p>specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p><b>&gt; </b></p>
<p>Category 0 ISRs </p>
<p>Startup stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>StartupHooks (global and OS-application specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>NTF stacks </p>
<p>0..n </p>
<p><b>&gt; </b></p>
<p>Non-trusted functions </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Pre / PostTaskHook() </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>No nesting interrupt stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>No nesting category 2 ISRs </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>42 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Interrupt level stacks </p>
<p>0..n </p>
<p><b>&gt; </b></p>
<p>Nesting category 2 ISRs </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Task stacks </p>
<p>1..n </p>
<p><b>&gt; </b></p>
<p>Tasks </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Pre / PostTaskHook() </p>
<p><b>&gt; </b></p>
<p>Category 0/1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>IOC receiver pull callback </p>
<p>stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>IOC receiver pull callback functions  </p>
<p><b>&gt; </b></p>
<p>Category 0 ISRs </p>
<p>Table 2-1  </p>
<p>MICROSAR OS Stack Types </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The stack sizes of all stacks must be configured within the ECU configuration </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.1 </b></p>
<p><b>Task Stack Sharing </b></p>
<p><b>2.3.1.1 </b></p>
<p><b>Description </b></p>
<p>In order to save RAM it is possible that different basic tasks share the same task stack. </p>
<p>Tasks which fulfill the following requirements share a stack: </p>
<p><b>&gt; </b></p>
<p>Basic tasks which have the same configured priority. </p>
<p><b>&gt; </b></p>
<p>Basic tasks which are non-preemptive and are configured to share stacks. Within </p>
<p>such basic tasks the call of the OS service Schedule() is not allowed. </p>
<p><b>&gt; </b></p>
<p>Basic tasks which share an internal resource and are configured to share stacks. </p>
<p>Within such basic tasks the call of the OS service Schedule() is not allowed. </p>
<p><b>2.3.1.2 </b></p>
<p><b>Activation </b></p>
<p>The  attribute  “OsTaskStackSharing”  of  a  basic  task  has  to  be  set  to  TRUE.  The  OS </p>
<p>decides then in dependancy of the preemption settings and assigned internal resources </p>
<p>whether the stack of basic tasks may be shared or not. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>43 </p>
<p>based on template version 6.0.1 </p>
<p>The size of the shared task stack is the maximum of all stack sizes of tasks which share </p>
<p>the stack. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS activates stack sharing automatically for basic tasks with the same configured </p>
<p>priority regardless of the value of OsTaskStackSharing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>By setting “OsTaskStackSharing” to TRUE the OS API service Schedule() may not be </p>
<p>called within the corresponding basic task. </p>
<p>The OS throws an error if Schedule() is called within a task with activated stack </p>
<p>sharing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Stack sharing of tasks can only be achieved between tasks which are assigned to the </p>
<p>same core! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.1.3 </b></p>
<p><b>Usage </b></p>
<p>Tasks  which  are  cooperative  to  each  other  are  sharing  the  same  stack.  No  additional </p>
<p>actions are necessary. </p>
<p><b>2.3.2 </b></p>
<p><b>ISR Stack Sharing </b></p>
<p><b>2.3.2.1 </b></p>
<p><b>Description </b></p>
<p>In  order  to  save  RAM  it  is  possible  that  different  category  2  ISRs  share  the  same  ISR </p>
<p>stack. </p>
<p><b>&gt; </b></p>
<p>All category 2 ISRs which are not nestable can share one stack. </p>
<p><b>&gt; </b></p>
<p>All Category 2 ISRs which have the same priority can share one stack. </p>
<p><b>2.3.2.2 </b></p>
<p><b>Activation </b></p>
<p>The attribute “OsIsrEnableNesting” must be set to FALSE for a category 2 ISR. </p>
<p>The size of the shared ISR stack is the maximum of all configured ISR stack sizes of non-</p>
<p>nestable category 2 ISRs. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>44 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Stack sharing of ISRs can only be achieved between ISRs which are assigned to the </p>
<p>same core! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.2.3 </b></p>
<p><b>Usage </b></p>
<p>The feature is used automatically by the OS. All category 2 ISRs on the same core which </p>
<p>are not nestable are sharing the same stack. </p>
<p><b>2.3.3 </b></p>
<p><b>Stack Check Strategy </b></p>
<p>All OS stacks must be protected from overflowing. </p>
<p>MICROSAR  OS  offers  different  strategies  to  detect  stack  overflows  or  even  to  prevent </p>
<p>stacks from overflowing. </p>
<p>In dependency of the configured scalability class there are the following strategies: </p>
<p> </p>
<p><b>Scalability Class </b></p>
<p>Stack check strategy </p>
<p><b>SC1 / SC2 </b></p>
<p>Software stack check (see 2.3.4) </p>
<p><b>SC3 / SC4 </b></p>
<p>Stack supervision by memory protection unit (MPU) (see 2.3.5) </p>
<p> </p>
<p><b>2.3.4 </b></p>
<p><b>Software Stack Check </b></p>
<p><b>2.3.4.1 </b></p>
<p><b>Description </b></p>
<p>The OS initializes the very last  element of each stack to a specific stack check pattern. </p>
<p>Whenever a stack switch is performed (e.g. a task switch) the OS checks whether this last </p>
<p>element of the valid stack still holds the stack check pattern. </p>
<p>If the OS detects that the stack check pattern has been altered it assumes that the last </p>
<p>valid stack did overflow. </p>
<p><b> </b></p>
<p>Stack Check Pattern </p>
<p><b>32 Bit Microcontrollers </b></p>
<p>0xAAAAAAAA </p>
<p>Table 2-2  </p>
<p>Stack Check Patterns </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The software stack check is able to detect stack overflows. It is not capable to avoid </p>
<p>them! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>45 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The software stack check is not able to detect all stack overflows. There may be </p>
<p>scenarios where the memory of the adjacent stack is already overwritten, but the last </p>
<p>element of the current stack still holds the stack check pattern. </p>
<p>In such cases the software stack check is not able to detect the overflow. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The software stack check is not able to detect the amount memory which has been </p>
<p>destroyed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.4.2 </b></p>
<p><b>Activation </b></p>
<p>Within  a  SC1  or  SC2  configuration  the  attribute  “OsStackMonitoring”  has  to  be  set  to </p>
<p>TRUE to activate the software stack check feature. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>On platforms which disable the MPU in supervisor mode, the software stack check may </p>
<p>be activated also for SC3 and SC4 configurations. </p>
<p>On other platforms the software stack check should be switched off in a SC3 or SC4 </p>
<p>configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.4.3 </b></p>
<p><b>Usage </b></p>
<p>Once  the  feature  is  activated  the  OS  checks  the  stacks  automatically  upon  each  stack </p>
<p>switch. </p>
<p>If the OS detects a stack overflow it goes into shutdown. If a ShutdownHook is configured </p>
<p>it is invoked to inform the application about OS shutdown. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Debugging hint: The stack check pattern is restored by the OS before the </p>
<p>ShutdownHook() is called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>46 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.5 </b></p>
<p><b>Stack Supervision by MPU </b></p>
<p><b>2.3.5.1 </b></p>
<p><b>Description </b></p>
<p>During the whole runtime of the OS the current active stack is supervised by the MPU of </p>
<p>the microcontroller. Therefore the OS reserves one MPU region which is reprogrammed by </p>
<p>the OS with each stack switch. </p>
<p>Stack overflows  cannot happen  since  the MPU avoids  write  accesses beyond  the  stack </p>
<p>boundaries. </p>
<p>Whenever a memory violation is recognized (e.g. due to a stack violation) an exception is </p>
<p>raised. Within the exception handling the OS calls the ProtectionHook(). </p>
<p>The application decides in the ProtectionHook() how to deal with the memory protection </p>
<p>violation. If the application invokes the shutdown of the OS, the ShutdownHook() is called </p>
<p>as well (if configured). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The stack supervision recognizes write accesses beyond stack boundaries and </p>
<p>suppresses them. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.5.2 </b></p>
<p><b>Activation </b></p>
<p>The system must be configured as a SC3 or SC4 system. </p>
<p> </p>
<p><b>2.3.5.3 </b></p>
<p><b>Usage </b></p>
<p>In  a  SC3  /  SC4  system  the  OS  automatically  initializes </p>
<p>one  MPU  region  for  stack </p>
<p>supervision. </p>
<p>To  safely  detect  stack  violations  special  care  must  be  taken  with  configuring  additional </p>
<p>MPU regions and also with linking of sections: </p>
<p><b>&gt; </b></p>
<p>When configuring additional MPU regions included memory region must never overlap </p>
<p>with any OS stack sections. </p>
<p><b>&gt; </b></p>
<p>By using an OS generated linker command file (see 4.3.2) it is assured that the OS </p>
<p>stacks are linked consecutively into the RAM. </p>
<p><b>&gt; </b></p>
<p>A stack safety gap is needed which is linked adjacent to the stacks (in dependency of </p>
<p>the stack growth direction; see Figure 2-1). No software parts must have write access </p>
<p>to the stack safety gap. </p>
<p><b>&gt; </b></p>
<p>The size of the stack safety gap must be at least the granularity of the MPU. </p>
<p><b>&gt; </b></p>
<p>The linkage of the safety gap is mandatory. Otherwise a stack violation of the stack </p>
<p>with the lowest address cannot be detected. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>47 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p>Figure 2-1 </p>
<p>Stack Safety Gap </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Don’t configure MPU regions which grant access to any OS stacks </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Add a stack safety gap to the linkage scheme. The stack safety gap is a restricted </p>
<p>memory region. No software parts must have write access to this region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.6 </b></p>
<p><b>Stack Usage Measurement </b></p>
<p><b>2.3.6.1 </b></p>
<p><b>Description </b></p>
<p>During runtime of the OS the maximum stack usage can be obtained by the application. </p>
<p>The OS initializes all OS stacks with the stack check pattern (see Table 2-2). </p>
<p>There are API functions which are capable to return the maximum stack usage (since call </p>
<p>of StartOS()) for each stack (see 5.2.8). </p>
<p><b>2.3.6.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsStackUsageMeasurement” to TRUE </p>
<p><b>2.3.6.3 </b></p>
<p><b>Usage </b></p>
<p>The stack usage APIs can be used anywhere in application. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To save OS startup time, the feature can be deactivated in a productive environment. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Stack growth direction</p>
<p>OS stacks</p>
<p>stack safety gap</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>48 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.4 </b></p>
<p><b>Interrupt Concept </b></p>
<p><b>2.4.1 </b></p>
<p><b>Interrupt Handling API </b></p>
<p>The AUTOSAR OS standard specifies several APIs to disable / enable Interrupts.  </p>
<p>  </p>
<p><b>DisableAllInterrupts() </b></p>
<p><b>EnableAllInterrupts() </b></p>
<p>The functions disable all category 1 and </p>
<p>category 2 interrupts. </p>
<p><b>SuspendAllInterrupts() </b></p>
<p><b>ResumeAllInterrupts() </b></p>
<p><b>SuspendOSInterrupts() </b></p>
<p><b>ResumeOSInterrupts() </b></p>
<p>The functions disable category 2 </p>
<p>interrupts only. </p>
<p> </p>
<p><b>2.4.2 </b></p>
<p><b>Interrupt Levels </b></p>
<p>The OS defines several interrupt levels. </p>
<p> </p>
<p>Figure 2-2 </p>
<p>Interrupt Lock Levels </p>
<p><b>&gt; </b></p>
<p>Category 2 ISRs must have a lower priority than category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs must have a lower priority than the timing protection ISR (within an </p>
<p>SC2 / SC4 system) </p>
<p><b>&gt; </b></p>
<p>The timing protection ISR must have a lower priority than category 0 ISRs (category 0 </p>
<p>ISRs are described in detail in chapter 3.14) </p>
<p><b>&gt; </b></p>
<p>The TP Lock Level cannot be set by the user. Interrupts are disabled up to this level </p>
<p>OS internally whenever timing protection is handled. </p>
<p><b>&gt; </b></p>
<p>Category 0 ISRs are disabled OS internally for very short times only e.g. when </p>
<p>performing a stack switch (the locations where category 0 ISRs are locked can be </p>
<p>found in chapter 3.14.2.4). </p>
<p><b>Interrupt Priority</b></p>
<p><b>High</b></p>
<p><b>Low</b></p>
<p><b>Tasks</b></p>
<p><b>Category 2</b></p>
<p><b>ISRs</b></p>
<p><b>Category 1</b></p>
<p><b>ISRs</b></p>
<p><b>Timing </b></p>
<p><b>Protection</b></p>
<p><b>ISR</b></p>
<p><b>SuspendOSInterrupts()</b></p>
<p><b>ResumeOSInterrupts()</b></p>
<p><b>DisableAllInterrupts()</b></p>
<p><b>EnableAllInterrupts()</b></p>
<p><b>SuspendAllInterrupts()</b></p>
<p><b>ResumeAllInterrupts()</b></p>
<p><b>Category 0</b></p>
<p><b>ISRs</b></p>
<p><b>Category 2 Lock Level</b></p>
<p><b>Category 1 Lock Level</b></p>
<p><b>TP Lock Level</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>49 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.3 </b></p>
<p><b>Interrupt Vector Table </b></p>
<p>The </p>
<p>interrupt </p>
<p>vector </p>
<p>table </p>
<p>is </p>
<p>generated </p>
<p>by </p>
<p>MICROSAR </p>
<p>OS </p>
<p>with </p>
<p>respect </p>
<p>to </p>
<p>the </p>
<p>configuration, microcontroller family and used compiler. </p>
<p>In a multi core system multiple vector tables may be generated. </p>
<p>MICROSAR OS generates an interrupt vector for each possible interrupt source. </p>
<p><b>2.4.4 </b></p>
<p><b>Nesting of Category 2 Interrupts </b></p>
<p><b>2.4.4.1 </b></p>
<p><b>Description </b></p>
<p>To keep interrupt latency as low as possible it is possible that </p>
<p><b>&gt; </b></p>
<p>A higher priority category 2 ISR interrupts a lower priority category 2 ISR. </p>
<p><b>&gt; </b></p>
<p>A category 1 ISRs interrupts a category 2 ISR (category 1 ISR has always a higher </p>
<p>priority) </p>
<p><b>2.4.4.2 </b></p>
<p><b>Activation </b></p>
<p>When  setting  “OsIsrEnableNesting” to TRUE  the  category  2  ISR itself  is  interruptible  by </p>
<p>higher priority ISRs. </p>
<p><b>2.4.5 </b></p>
<p><b>Category 1 Interrupts </b></p>
<p><b>2.4.5.1 </b></p>
<p><b>Implementation of Category 1 ISRs </b></p>
<p>MICROSAR  OS  offers  a  macro  for  implementing  a  category  1  ISR.  This  is  a  similar </p>
<p>mechanism like the macro for a category 2 ISR defined by the AUTOSAR standard. </p>
<p>MICROSAR OS abstracts the needed compiler keywords. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Implement a category 1 ISR </b></p>
<p>OS_ISR1(&lt;MyCategory1ISR&gt;) </p>
<p>{ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.4.5.2 </b></p>
<p><b>Nesting of Category 1 ISRs </b></p>
<p>Since category 1 ISRs are directly called from interrupt vector table without any OS pro- </p>
<p>and epilogue, automatic nesting of category 1 ISRs cannot be supported. </p>
<p>The configuration attribute “OsIsrEnableNesting” is ignored for category 1 ISRs. </p>
<p>Nevertheless  the  interrupts  may  be  enabled  during  a  category  1  ISR  to  allow  interrupt </p>
<p>nesting but OS API functions cannot be used for this purpose. The application has to use </p>
<p>compiler intrinsic functions or inline assembler statements. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>50 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>OS_ISR1(&lt;MyCategory1ISR&gt;) </p>
<p>{ </p>
<p>   __asm(EI); /* enable nesting of this ISR */ </p>
<p> </p>
<p>   __asm(DI); /* disable nesting before leaving the function */ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.4.5.3 </b></p>
<p><b>Category 1 ISRs before StartOS </b></p>
<p>There may be the need to activate and serve category 1 ISRs before the OS has been </p>
<p>started. </p>
<p>The following sequence should be implemented: </p>
<p>1. </p>
<p>Call Os_InitMemory </p>
<p>2. </p>
<p>Call Os_Init (within the function the basic interrupt controller settings are initialized </p>
<p>e.g. priorities of interrupt sources). </p>
<p>3. </p>
<p>Enable the Interrupt sources of category 1 ISRs by directly manipulating the control </p>
<p>registers in the interrupt controller. </p>
<p>4. </p>
<p>Enable  the  interrupts  by  directly  manipulating  the  global  interrupt  flag  and  /  or </p>
<p>current interrupt priority to allow the category 1 ISRs </p>
<p> </p>
<p><b>2.4.5.4 </b></p>
<p><b>Notes on Category 1 ISRs </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>On platforms which have no automatic stack switch upon interrupt request there will be </p>
<p>no stack switch at all if a category 1 ISR occurs. Thus the stack consumption of a </p>
<p>category 1 ISR should be added to all stacks which are can be consumed by category </p>
<p>1 ISRs (see 2.3 for an overview). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Although the interrupt priorities are initialized by MICROSAR OS there is no API to </p>
<p>enable or acknowledge category 1 ISRs. The interrupt control registers have to be </p>
<p>accessed directly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>51 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The AUTOSAR OS standard does not allow OS API usage within category 1 ISRs (the </p>
<p>only exception is the interrupt handling API). </p>
<p>If a not allowed OS API is called anyway, MICROSAR OS is not able to detect this and </p>
<p>the called API may not work as expected. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Category 1 ISRs are always executed with trusted rights on supervisor level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The macro “OS_ISR1” abstracts the appropriate compiler keyword for implementing </p>
<p>the interrupt service routine. Thus the compiler generates code which safes and restore </p>
<p>a subset of the general purpose registers. </p>
<p>In certain usecases e.g. usage of the FPU or nested interrupts it may require the </p>
<p>application to save and restore more registers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.4.6 </b></p>
<p><b>Initialization of Interrupt Sources </b></p>
<p>Through the OS configuration MICROSAR OS knows the assignment of interrupt sources </p>
<p>and priorities to ISRs. In multi core system the core assignment of all ISRs is also known. </p>
<p>Based  on  these  configuration  information  MICROSAR  OS  generates  data  structures  for </p>
<p>initializing the interrupt controller. It initializes the interrupt priority and its core assignment. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p><b>Enabling of interrupt sources: </b></p>
<p>The OS enables the interrupt sources only for the OS generated timer ISRs. </p>
<p>Other user ISRs can be only be served if the corresponding interrupt sources are </p>
<p>enabled by the application. </p>
<p>This should be done by using the interrupt source API (see 5.2.6 for details; function </p>
<p>Os_EnableInterruptSource). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>52 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.7 </b></p>
<p><b>Unhandled Interrupts </b></p>
<p>Interrupt sources which are not assigned to a user defined ISR are assigned to a default </p>
<p>OS interrupt handler which collects those interrupt sources. </p>
<p>Thus interrupt requests from unassigned interrupt sources are handled by the OS. Within </p>
<p>OS  Hooks  (e.g.  ProtectionHook())  the  application  can  obtain  the  source  number  of  the </p>
<p>unhandled interrupt request by an OS API (see 5.2.7.1 for details). </p>
<p>In case of an unhandled interrupt request MICROSAR OS calls the ProtectionHook() with </p>
<p>the parameter E_OS_SYS_PROTECTION_IRQ. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>53 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.5 </b></p>
<p><b>Exception Concept </b></p>
<p><b>2.5.1 </b></p>
<p><b>Exception Vector Table </b></p>
<p>The </p>
<p>exception </p>
<p>vector </p>
<p>table </p>
<p>is </p>
<p>generated </p>
<p>by </p>
<p>MICROSAR </p>
<p>OS </p>
<p>with </p>
<p>respect </p>
<p>to </p>
<p>the </p>
<p>configuration, microcontroller family and used compiler. </p>
<p>In a multi core multiple vector tables may be generated. </p>
<p>MICROSAR OS generates an exception vector for each possible exception source. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In a SC3 and SC4 system MICROSAR OS defines OS exception handlers for memory </p>
<p>protection errors and for SYSCALL / TRAP instructions. </p>
<p>Exception sources which are used by the OS cannot be configured by the application. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.5.2 </b></p>
<p><b>Unhandled Exceptions </b></p>
<p>Exception </p>
<p>sources </p>
<p>which </p>
<p>are </p>
<p>not </p>
<p>assigned </p>
<p>to </p>
<p>user </p>
<p>defined </p>
<p>exception </p>
<p>handlers </p>
<p>are </p>
<p>assigned to a default OS exception handler which collects those exceptions. </p>
<p>Thus  exception  requests  from  unassigned  exception  sources  are  handled  by  the  OS. </p>
<p>Within  OS  Hooks  the  application  can  obtain  the  exception  number  of  the  unhandled </p>
<p>exception request by an OS API (see 5.2.7.3 for details). </p>
<p>In case of an unhandled exception request MICROSAR OS calls the ProtectionHook() with </p>
<p>the parameter E_OS_PROTECTION_EXCEPTION. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>54 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.6 </b></p>
<p><b>Timer Concept </b></p>
<p><b>2.6.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS can provide a time base generated from  timer hardware located on the </p>
<p>microcontroller. This time base can be used to drive alarms and schedule-tables. </p>
<p><b>2.6.2 </b></p>
<p><b>Activation </b></p>
<p>The  OS  configuration  may  define  an  OsCounter  Object  of  type  “HARDWARE”.  Then  a </p>
<p>driving hardware must be assigned to “OsDriver” attribute. </p>
<p><b>2.6.3 </b></p>
<p><b>Usage </b></p>
<p>Once the hardware counter is defined it can be assigned to alarms (“OsAlarmCounterRef”) </p>
<p>and schedule-tables (“OsScheduleTableCounterRef”). </p>
<p>Such alarms and schedule-tables are driven time based. </p>
<p>Additionally </p>
<p>MICROSAR </p>
<p>OS </p>
<p>provides </p>
<p>conversion </p>
<p>macros </p>
<p>(which </p>
<p>are </p>
<p>based </p>
<p>on </p>
<p>the </p>
<p>hardware counter configuration) to convert from hardware ticks to time and vice versa (see </p>
<p>for 5.2.10 details). </p>
<p><b>2.6.4 </b></p>
<p><b>Dependencies </b></p>
<p>A hardware counter can be driven in two modes: </p>
<p><b>&gt; </b></p>
<p>Periodical interrupt timer mode (see 2.7) </p>
<p><b>&gt; </b></p>
<p>High resolution timer mode (see 2.8) </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>55 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.7 </b></p>
<p><b>Periodical Interrupt Timer (PIT) </b></p>
<p><b>2.7.1 </b></p>
<p><b>Description </b></p>
<p>The  timer  hardware  is  set  up  to  generate  timer  interrupts  requests  in  a  strict  periodical </p>
<p>interval (e.g. 1ms). The interval does not change during OS runtime. </p>
<p>Within  each  timer  ISR  MICROSAR  OS  checks  for  alarm  and  schedule-table  expirations </p>
<p>and execute the configured OS action. </p>
<p><b>2.7.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define an OsCounter of type “HARDWARE” and select the timer Hardware in </p>
<p>“OsDriver”. </p>
<p><b>&gt; </b></p>
<p>Set the counter sub-attribute “OsDriverHighResolution” to FALSE. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsSecondsPerTick” specifies the cycle time of interrupt generation. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterTicksPerBase” specifies the number of timer counter cycles </p>
<p>which are necessary to reach “OsSecondsPerTick”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>56 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.8 </b></p>
<p><b>High Resolution Timer (HRT) </b></p>
<p><b>2.8.1 </b></p>
<p><b>Description </b></p>
<p>The  timer hardware  is set  up  to  generate  one  timer interrupt  request  when  an  alarm or </p>
<p>schedule-table action shall be executed. </p>
<p>Within each timer ISR MICROSAR OS performs that action, calculates the timer interval </p>
<p>for the next action and reprograms the timer hardware with the new expiration time. </p>
<p><b>2.8.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define an OsCounter of type “HARDWARE” and select the timer Hardware in </p>
<p>“OsDriver”. </p>
<p><b>&gt; </b></p>
<p>Set the counter sub-attribute “OsDriverHighResolution” to TRUE. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsSecondsPerTick” specifies the cycle time of the timer counter. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterTicksPerBase” must be set to “1”. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterMaxAllowedValue” must be set to 0x3FFFFFFF </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.9 </b></p>
<p><b>PIT versus HRT </b></p>
<p><b> </b></p>
<p>PIT </p>
<p>HRT </p>
<p><b>Interrupt Requests are generated … </b></p>
<p></p>
<p> Strictly periodical </p>
<p></p>
<p> On demand </p>
<p><b>Precision of Alarms / Schedule-</b></p>
<p><b>tables </b></p>
<p></p>
<p> Only multiples of the </p>
<p>attribute </p>
<p>OsSecondsPerTick are </p>
<p>possible for alarm / </p>
<p>schedule-table times. </p>
<p></p>
<p> Any times are possible. </p>
<p>With precision of the </p>
<p>cycle time of the used </p>
<p>timer hardware. </p>
<p><b>Interrupt Load </b></p>
<p></p>
<p> Generates a constant </p>
<p>interrupt load which is </p>
<p>equally distributed over </p>
<p>runtime. </p>
<p></p>
<p> Interrupt load is not </p>
<p>equally distributed over </p>
<p>runtime. </p>
<p></p>
<p> Interrupt bursts may be </p>
<p>possible. </p>
<p>Table 2-3  </p>
<p>PIT versus HRT </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>57 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.10 </b></p>
<p><b>Startup Concept </b></p>
<p>The following  figure  gives  an overview  of the  different  startup  phases  of  the  OS.  It  also </p>
<p>shows which OS API functions are available in the different phases. </p>
<p> </p>
<p>Figure 2-3 </p>
<p>API functions during startup </p>
<p> </p>
<p> </p>
<p><b> stm API Usage before StartOS</b></p>
<p>Ini ti al</p>
<p><b>Startup-Phase0</b></p>
<p><b>Startup-Phase1</b></p>
<p><b>Startup-Phases2and3</b></p>
<p>Ini ti al</p>
<p><b>Startup-Phase2</b></p>
<p>ExitPoint</p>
<p><b>Startup-Phase3</b></p>
<p>After StartOS() all API functions can be </p>
<p>called in exactly the contexts as </p>
<p>described in the AutosarOS standard. </p>
<p>Mind that StartNonAutosarCore() can still </p>
<p>be called.</p>
<p>Init-Step1</p>
<p>Init-Step2</p>
<p>Init-Step3</p>
<p>Init-Step4</p>
<p>Os_CallNonTrustedFunction(),</p>
<p>CallTrustedFunction,</p>
<p>Os_ReadPeripheral*,</p>
<p>Os_WritePeripheral*,</p>
<p>Os_ModifyPeripheral*</p>
<p>Os_EnterPreStartTask()</p>
<p>DisableAllInterrupts(),</p>
<p>EnableAllInterrupts(),</p>
<p>SuspendAllInterrupts(),</p>
<p>ResumeAllInterrupts(),</p>
<p>SuspendOSInterrupts(),</p>
<p>ResumeOSInterrupts(),</p>
<p>StartCore(), GetCoreID(),</p>
<p>StartNonAutosarCore()</p>
<p>StartOS()</p>
<p>Os_Init()</p>
<p>Os_InitMemory()</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>58 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.11 </b></p>
<p><b>Single Core Startup </b></p>
<p>This chapter shows some examples how MICROSAR OS is started as single core OS. </p>
<p><b>2.11.1 </b></p>
<p><b>Single Core Derivatives </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a single core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>   StartOS(OSDEFAULTAPPMODE); </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.11.2 </b></p>
<p><b>Multi Core Derivatives </b></p>
<p><b>2.11.2.1 </b></p>
<p><b>Examples for SC1 / SC2 Systems </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); /* call of StartNonAutosarCore is </p>
<p>                                                    optional the other core may also be </p>
<p>                                                    held in reset */ </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case OS_CORE_ID_1: </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the master core of a multi core derivative. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>59 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      case OS_CORE_ID_1: </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the slave core of a multi core derivative </p>
<p> </p>
<p><b>2.11.2.2 </b></p>
<p><b>Examples for SC3 / SC4 Systems </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The function GetCoreID requires a trap into the OS to be functional. Since the OS does </p>
<p>not initialize any trap tables on non-AUTOSAR cores GetCoreID cannot be used on </p>
<p>such cores. </p>
<p>Therefore it is not possible to use the API function GetCoreID within the main function. </p>
<p>A user function (e.g. UsrGetCoreID) is necessary which distinguishes the correct core </p>
<p>ID. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>60 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(UsrGetCoreID()) </p>
<p>   { </p>
<p>      case 0: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); /* call of StartNonAutosarCore is </p>
<p>                                                    optional the other core may also be </p>
<p>                                                    held in reset */ </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case 1: </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the master core of a multi core derivative. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>61 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.12 </b></p>
<p><b>Multi Core Startup </b></p>
<p>Within a multi core system each core has the following possibilities when entering the main </p>
<p>function: </p>
<p>1. </p>
<p>Mandatory: call to Os_InitMemory and Os_Init(). </p>
<p>2. </p>
<p>Optional: calls to StartCore() to start additional cores under control of MICROSAR </p>
<p>OS. </p>
<p>3. </p>
<p>Optional: calls to StartNonAutosarCore() to start additional cores which are </p>
<p>independent of MICROSAR OS. </p>
<p>4. </p>
<p>Optional: call StartOS() to start MICROSAR OS on the core  </p>
<p> </p>
<p>For a slave core this is only possible if the core once has been started with </p>
<p>StartCore() API from another core. </p>
<p> </p>
<p>For the master core this is only possible if the core itself is configured to be </p>
<p>an AUTOSAR core. </p>
<p><b>2.12.1 </b></p>
<p><b>Example for SC1 / SC2 Systems </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_1: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example shows a possible startup sequence for a quad core system. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>62 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.12.2 </b></p>
<p><b>Examples for SC3 / SC4 systems </b></p>
<p><b>2.12.2.1 </b></p>
<p><b>Only with AUTOSAR Cores </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_1: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The  example  shows  a  possible  startup  sequence  for  a  quad  core  system. All  cores  are </p>
<p>configured to be AUTOSAR cores. </p>
<p> </p>
<p><b>2.12.2.2 </b></p>
<p><b>Mixed Core System </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The function GetCoreID requires a trap into the OS to be functional. Since the OS does </p>
<p>not initialize any trap tables on non-AUTOSAR cores GetCoreID cannot be used on </p>
<p>such cores. </p>
<p>Therefore it is not possible to use the API function GetCoreID within the main function. </p>
<p>A user function (e.g. UsrGetCoreID) is necessary which distinguishes the correct core </p>
<p>ID. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>63 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(UsrGetCoreID()) </p>
<p>   { </p>
<p>      case 0: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case 1: </p>
<p>         /* not an AUTOSAR core; do something else */ </p>
<p>         break; </p>
<p>      case 2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case 3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example shows a possible startup sequence for a quad core system. Three cores are </p>
<p>AUTOSAR cores and one core is a non-AUTOSAR core. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>64 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.13 </b></p>
<p><b>Error Handling </b></p>
<p>MICROSAR OS is able to detect and handle the following types of errors: </p>
<p><b>Application Errors … </b></p>
<p></p>
<p> Are raised if the OS could not execute a requested OS API service </p>
<p>correctly. Typically the OS API is used wrong (e.g. invalid object </p>
<p>ID). </p>
<p></p>
<p> Do not corrupt the internal OS data. </p>
<p></p>
<p> Will result in call of the global ErrorHook() for centralized error </p>
<p>handling (if configured). </p>
<p></p>
<p> Will result in call of an application specific ErrorHook (if configured). </p>
<p></p>
<p> May not induce shutdown / terminate reactions. Instead the </p>
<p>application may continue execution by simply returning from the </p>
<p>ErrorHooks. </p>
<p><b>Protection Errors … </b></p>
<p></p>
<p> Are raised if the application violates its configured boundaries (e.g. </p>
<p>memory access violations, timing violations). </p>
<p></p>
<p> Do not corrupt OS internal data. </p>
<p></p>
<p> Are raised upon occurrence of unhandled exceptions and </p>
<p>interrupts. </p>
<p></p>
<p> Will result in call of the ProtectionHook() where a shutdown or </p>
<p>terminate handling (with or without restart) is induced. </p>
<p></p>
<p> If Shutdown is induced the ShutdownHook() is called (if </p>
<p>configured). </p>
<p></p>
<p> If no ProtectionHook() is configured shutdown is induced. </p>
<p><b>Kernel Errors … </b></p>
<p></p>
<p> Are raised if the OS cannot longer assume the correctness if its </p>
<p>internal data (e.g. memory access violation during </p>
<p>ProtectionHook()) </p>
<p></p>
<p> Will result in call of the Os_PanicHook() to inform the application. </p>
<p></p>
<p> Afterwards the OS disables all interrupts and enters an infinite loop. </p>
<p>Table 2-4  </p>
<p>Types of OS Errors </p>
<p><b>2.14 </b></p>
<p><b>Error Reporting </b></p>
<p>MICROSAR OS supports error reporting according to the AUTOSAR [1] and OSEK OS [2] </p>
<p>standard. </p>
<p>This includes </p>
<p><b>&gt; </b></p>
<p>StatusType return values of OS APIs </p>
<p><b>&gt; </b></p>
<p>Parameter passing of error codes error to ErrorHook() </p>
<p><b>&gt; </b></p>
<p>Service ID information provided by the macro OSErrorGetServiceId() </p>
<p><b>&gt; </b></p>
<p>Parameter access macros (e.g. OSError_ActivateTask_TaskID()) </p>
<p> </p>
<p><b>2.14.1 </b></p>
<p><b>Extension of Service IDs </b></p>
<p>MICROSAR OS introduces new service IDs for own services. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>65 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>All service IDs are listed in the OS header file </p>
<p>Os_Types.h</p>
<p> and may be looked up in </p>
<p>the enum data type </p>
<p>OSServiceIdType</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.14.2 </b></p>
<p><b>Extension of Error Codes </b></p>
<p>MICROSAR OS introduces new 8 bit error codes which extend the error codes which are </p>
<p>already defined by AUTOSAR OS and OSEK OS standard. </p>
<p><b>Type of Error </b></p>
<p><b>Related Error Code </b></p>
<p><b>Value </b></p>
<p>An internal OS buffer used for cross core </p>
<p>communication is full. </p>
<p>E_OS_SYS_OVERFLOW </p>
<p>0xF5 </p>
<p>A forcible termination of a kernel object has </p>
<p>been requested e.g. terminate system </p>
<p>applications. </p>
<p>E_OS_SYS_KILL_KERNEL_OBJ </p>
<p>0xF6 </p>
<p>An OS-Application has been terminated </p>
<p>with requested restart but no restart task </p>
<p>has been configured. </p>
<p>E_OS_SYS_NO_RESTARTTASK </p>
<p>0xF7 </p>
<p>The application tries to use an API cross </p>
<p>core, but the target core has not been </p>
<p>configured for cross core API </p>
<p>E_OS_SYS_CALL_NOT_ALLOWED </p>
<p>0xF8 </p>
<p>The triggered cross core function is not </p>
<p>available on the target core. </p>
<p>E_OS_SYS_FUNCTION_UNAVAILABLE  0xF9 </p>
<p>A syscall instruction has been executed </p>
<p>with an invalid syscall number. </p>
<p>E_OS_SYS_PROTECTION_SYSCALL </p>
<p>0xFA </p>
<p>An unhandled interrupt occurred. </p>
<p>E_OS_SYS_PROTECTION_IRQ </p>
<p>0xFB </p>
<p>The interrupt handling API is used wrong. </p>
<p>E_OS_SYS_API_ERROR </p>
<p>0xFC </p>
<p>Internal OS assertion (not issued to </p>
<p>customer). </p>
<p>E_OS_SYS_ASSERTION </p>
<p>0xFD </p>
<p>A system timer ISR was delayed too long. </p>
<p>E_OS_SYS_OVERLOAD </p>
<p>0xFE </p>
<p>Table 2-5  </p>
<p>Extension of Error Codes </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>All error codes and their values can be looked up in the header file </p>
<p>Os_Types.h</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.14.3 </b></p>
<p><b>Detailed Error Codes </b></p>
<p>MICROSAR  OS  provides  detailed  error  code  to  extend  the  standard  error  handling  of </p>
<p>AUTOSAR to uniquely identify each possible OS error. </p>
<p>The detailed error code is assembled from AUTOSAR StatusType error code and unique </p>
<p>error code. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>66 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p>Figure 2-4 </p>
<p>MICROSAR OS Detailed Error Code </p>
<p>Within OS Hook routines the error code can be obtained by calling Os_GetDetailedError() </p>
<p>(see 5.2.7.1 for details). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Vector OS experts always asks about the detailed error codes when supporting </p>
<p>customers in case of OS errors. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>The detailed error codes are listed in the file </p>
<p>Os_Types.h</p>
<p> and may be looked up in </p>
<p>the enum data type </p>
<p>Os_StatusType</p>
<p>. </p>
<p>Each detailed error code is preceded by a descriptive comment. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>0x</p>
<p>XXXXXX</p>
<p>YY</p>
<p>Autosar StatusType</p>
<p>MICROSAR OS</p>
<p>Error code extension</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>67 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.15 </b></p>
<p><b>Multi Core Concepts </b></p>
<p><b>2.15.1 </b></p>
<p><b>Scheduling and Dispatching </b></p>
<p>MICROSAR OS implements independent schedulers and dispatchers for each core. </p>
<p><b>2.15.2 </b></p>
<p><b>Multi Core Data Concepts </b></p>
<p>The multi core data concept of MICROSAR OS tries to avoid concurrent writing accesses </p>
<p>between cores. </p>
<p>Although  cores  may  read  all  OS  data  of  all  cores,  write  accesses  to  OS  data  are  only </p>
<p>performed locally from the owning core. </p>
<p>This data concept allows optimized linking: </p>
<p><b>&gt; </b></p>
<p>The data of a particular core may be linked into fast accessible memory </p>
<p><b>&gt; </b></p>
<p>The data of a particular core may be linked into cached memory </p>
<p>Only the variables related to spinlocks have to be linked into global memory which must be </p>
<p>accessible by all participating cores. </p>
<p><b>2.15.3 </b></p>
<p><b>X-Signals </b></p>
<p>To realize cross core service APIs MICROSAR OS offers the X-Signal concept (see 3.9 for </p>
<p>details). </p>
<p><b>2.15.4 </b></p>
<p><b>Master / Slave Core </b></p>
<p>In a real master / slave multi core architecture only one core is started upon reset. This is </p>
<p>the master core. All other cores are held in a reset state and must be explicitly started by </p>
<p>the master core. These are slave cores. </p>
<p>There  are  also  multi  core  systems  which  starts  all  cores  simultaneously.  There  is  no </p>
<p>hardware master / slave classification. </p>
<p>MICROSAR OS is capable to deal with both concepts. In a system with equal cores the </p>
<p>OS emulates master / slave behavior according to the core configurations. </p>
<p><b>2.15.5 </b></p>
<p><b>Hardware Init Core </b></p>
<p>To </p>
<p>initialize </p>
<p>the </p>
<p>system </p>
<p>peripherals </p>
<p>used </p>
<p>by </p>
<p>the </p>
<p>OS </p>
<p>(e.g. </p>
<p>System </p>
<p>MPU, </p>
<p>Interrupt </p>
<p>Controller), MICROSAR OS uses a dedicated so called Hardware Init Core. </p>
<p>MICROSAR  OS  offers  the  possibility  to  configure </p>
<p>one  core  as  Hardware </p>
<p>Init  Core </p>
<p>(&quot;/MICROSAR/Os/OsOS/OsHardwareInitCore&quot;).  If  the  user  does  not  configure  a  specific </p>
<p>core, the Master Core is used as Hardware Init Core. </p>
<p>In  safety-critical  environments  it  is  recommended  to  configure  the  core  with  the  highest </p>
<p>diagnostic coverage as Hardware Init Core. </p>
<p><b>2.15.6 </b></p>
<p><b>Startup of a Multi Core System </b></p>
<p>The startup of a multi core system is described in detail in 2.12. </p>
<p>MICROSAR OS offers the possibility to configure a startup symbol for each core. Within a </p>
<p>real master / slave system the OS needs this information for starting the slave cores. </p>
<p><b>2.15.7 </b></p>
<p><b>Spinlocks </b></p>
<p>Synchronization of cores is done by </p>
<p><b>&gt; </b></p>
<p>OS Spinlocks (see [1]) or </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>68 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>Optimized spinlocks (see 3.1) </p>
<p><b>2.15.7.1 </b></p>
<p><b>Linking of Spinlocks </b></p>
<p>To  achieve  freedom  from  interference  between  cores  with  different  diagnostic  coverage </p>
<p>capability, spinlocks are linked into different memory sections. </p>
<p>An MPU may be used to allow access from only specific cores or specific OS applications. </p>
<p>The used memory sections depend on the feature „OsForcibleTermination“ </p>
<p><b> </b></p>
<p>OS spinlocks </p>
<p>Optimized spinlocks </p>
<p><b>OsForcibleTermination = TRUE </b></p>
<p>Spinlocks variables are linked </p>
<p>into a core shared section </p>
<p>Spinlock variables are linked </p>
<p>into a core shared section </p>
<p><b>OsForcibleTermination = FALSE </b></p>
<p>Spinlock variables are linked </p>
<p>into an application shared </p>
<p>section </p>
<p>Table 2-6   Linking of spinlocks </p>
<p><b>2.15.8 </b></p>
<p><b>Cache </b></p>
<p>Due to cache coherency problems spinlock variables and other application variables which </p>
<p>are shared among cores must not be cached. </p>
<p><b>2.15.9 </b></p>
<p><b>Shutdown </b></p>
<p><b>2.15.9.1 </b></p>
<p><b>Shutdown of one Core </b></p>
<p>If ShutdownOS() is called on one core, it induces shutdown actions. </p>
<p><b>&gt; </b></p>
<p>The core terminates all its applications </p>
<p><b>&gt; </b></p>
<p>Application specific ShutdownHooks are called  </p>
<p><b>&gt; </b></p>
<p>The global ShutdownHook() is called </p>
<p><b>&gt; </b></p>
<p>Interrupts are disabled </p>
<p><b>&gt; </b></p>
<p>An endless loop is entered </p>
<p><b>2.15.9.2 </b></p>
<p><b>Shutdown of all Cores </b></p>
<p>Upon  call  to  ShutdownAllCores()  synchronized  shutdown  of  the  system  is  invoked.  An </p>
<p>asynchronous X-Signal is used for this purpose. </p>
<p>Synchronized shutdown is described in [1]. </p>
<p> </p>
<p><b>2.15.9.3 </b></p>
<p><b>Shutdown during Protection Violation </b></p>
<p>If  the  ProtectionHook()  returns  with  “PRO_SHUTDOWN”  a  shutdown  of  all  cores  is </p>
<p>invoked. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>69 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.16 </b></p>
<p><b>Debugging Concepts </b></p>
<p><b>2.16.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers two software utilities to support OS debugging. </p>
<p><b>ORTI </b></p>
<p>MICROSAR OS generates an ORTI debug file (<b>O</b>SEK <b>R</b>un<b>T</b>ime </p>
<p><b>I</b>nterface). Many debuggers are capable of loading such ORTI files </p>
<p>and provide comfortable debug means based upon the OS </p>
<p>configuration. </p>
<p>See chapter 2.16.3 for details </p>
<p><b>TimingHooks </b></p>
<p>MICROSAR OS provides macros which may be used for debugging </p>
<p>purposes (also suitable for third party tools). See chapter 3.10 for </p>
<p>details. </p>
<p> </p>
<p><b>2.16.2 </b></p>
<p><b>Activation </b></p>
<p>ORTI and TimingHooks may be switched on within the OsDebug container. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>There is an additional switch within the “OsDebug” container. It enables OS assertions. </p>
<p>They are intended for OS internal test purposes. If activated the OS performs additional </p>
<p>runtime checks on its own internal states. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.16.3 </b></p>
<p><b>ORTI Debugging </b></p>
<p>ORTI is the abbreviation of “OSEK Runtime Interface”. </p>
<p>When ORTI debugging is activated MICROSAR OS generates additional files with “</p>
<p>.ort</p>
<p>” </p>
<p>extension.  These  files  contain  information  about  the  whole  OS  configuration.  They  are </p>
<p>intended to be read by a debugger. </p>
<p>The  debugger  uses  the  information  from  the  ORTI  files  to  display  static  and  runtime </p>
<p>information about OS objects e.g. task states. </p>
<p>ORTI versions supported by MICROSAR OS: </p>
<p><b>ORTI 2.2 </b></p>
<p>As described in the OSEK standard [3] and [4] </p>
<p><b>ORTI 2.3 </b></p>
<p>Unofficial “Standard” based upon ORTI 2.2. It does contain extensions </p>
<p>for multi core OS and was proposed by “Lauterbach Development </p>
<p>Tools” (described in [5]). </p>
<p> </p>
<p>Both ORTI versions are capable to be used within single core and multi core systems. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>70 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for ORTI 2.2 multi core debugging </b></p>
<p>For each configured AUTOSAR core there is one separate ORTI file. </p>
<p>For multi core debugging, the debugger software must be capable to read several </p>
<p>ORTI files. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for ORTI 2.3 multi core debugging </b></p>
<p>The debug information for all configured cores is aggregated in one file. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Basically debuggers are capable to display the stack consumption for each stack </p>
<p>(OsStackUsageMeasurement must be switched on). </p>
<p>Please note that uninitialized OS stacks may show 100% stack usage within ORTI </p>
<p>debugging. Reliable information can only be given after the OS has initialized all </p>
<p>stacks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MESSAGE objects and CONTEXT information specified by ORTI 2.2 Standard are not </p>
<p>supported in MICROSAR OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The following OS services are not traced by ORTI service tracing: </p>
<p><b>&gt; </b></p>
<p>GetSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>TryToGetSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>ReleaseSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>IOC </p>
<p><b>&gt; </b></p>
<p>Os_GetVersionInfo </p>
<p><b>&gt; </b></p>
<p>Os_Init </p>
<p><b>&gt; </b></p>
<p>Os_InitMemory </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>71 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.17 </b></p>
<p><b>Memory Protection </b></p>
<p>MICROSAR OS uses memory protection facilities of a processor to achieve freedom from </p>
<p>interference between OS applications and cores. For this purpose it may use the system </p>
<p>MPU and the core MPUs. </p>
<p><b>2.17.1 </b></p>
<p><b>Usage of the System MPU </b></p>
<p>In  multi  core  systems  whereas  the  cores  have  different  levels  of  diagnostic  coverage  it </p>
<p>may  be  necessary  to  use  a  system  MPU  to  achieve  freedom  of  interference  between </p>
<p>cores. </p>
<p>A  system  MPU  allows  configuring  access  rights  for  cores  to  access  specific  memory </p>
<p>ranges. </p>
<p>The </p>
<p>system </p>
<p>MPU </p>
<p>is </p>
<p>only </p>
<p>initialized </p>
<p>once </p>
<p>during </p>
<p>startup </p>
<p>of </p>
<p>the </p>
<p>OS. </p>
<p>It </p>
<p>is </p>
<p>never </p>
<p>reprogrammed during runtime. </p>
<p>With  a  system  MPU  other  potential  bus  masters  (DMA,  FlexRay)  can  be  isolated  to </p>
<p>achieve freedom from interference. </p>
<p>This is done with the following steps: </p>
<p><b>Step </b></p>
<p>Toolchain phase </p>
<p><b>Set up a SC3 system </b></p>
<p>Configuration of OS </p>
<p><b>Configure memory regions </b></p>
<p><b>Assign the memory region to the system MPU </b></p>
<p> </p>
<p><b>2.17.2 </b></p>
<p><b>Usage of the Core MPUs </b></p>
<p>The  core  MPUs  are  used  to  achieve  freedom  from  interference  between  applications  / </p>
<p>tasks / ISRs on the same core. The basic concept is that access rights of these runtime </p>
<p>entities (read/write/executable) have to be granted explicitly to software parts. </p>
<p>This is done with the following steps: </p>
<p><b>Step </b></p>
<p>Toolchain phase </p>
<p><b>Set up a SC3 system </b></p>
<p>Configuration of OS </p>
<p><b>Configure memory regions </b></p>
<p><b>Assign the memory region to a core MPU </b></p>
<p><b>Assign the memory regions to OS applications / Tasks / ISRs </b></p>
<p><b>(optional) </b></p>
<p><b>Use the AUTOSAR MemMap mechanism to place code, constants and </b></p>
<p><b>variables into appropriate sections (see 4.3.1.1) </b></p>
<p>Compilation </p>
<p><b>Use OS generated linker command files to locate the sections into </b></p>
<p><b>memory (see 4.3.2) </b></p>
<p>Linkage </p>
<p> </p>
<p><b>2.17.3 </b></p>
<p><b>Configuration Aspects </b></p>
<p>A memory region is typically configured by </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>72 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>Specify a start and end address by number, or by linker labels (see 4.3.3 for OS </p>
<p>generated section labels) </p>
<p><b>&gt; </b></p>
<p>Specify access rights to this region (a pre-defined set of access rights is referable) </p>
<p><b>&gt; </b></p>
<p>Specify the validity of the region by ID (e.g. PID / ASID / Protection Set) </p>
<p><b>&gt; </b></p>
<p>Specify to which memory protection unit the region belongs (e.g. Core MPU / System </p>
<p>MPU) </p>
<p><b>&gt; </b></p>
<p>Specify the owner of the region </p>
<p>The owner of the memory region distinguishes the runtime behavior of the hardware MPU </p>
<p>regions (whether the region is static or dynamic). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The start and end addresses of configured memory region should always be a multiple </p>
<p>of the granularity of the hardware MPU. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The number of available hardware MPU regions is limited by hardware! </p>
<p>MICROSAR OS checks during code generation that the overall number of configured </p>
<p>memory regions does not exceed the number of available hardware MPU regions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.17.3.1 </b></p>
<p><b>Static MPU Regions </b></p>
<p>If no owner is specified, MICROSAR OS initializes a hardware MPU region to be static. It </p>
<p>is never reprogrammed during runtime of the OS. It is valid for all software parts. </p>
<p> </p>
<p><b>2.17.3.2 </b></p>
<p><b>Dynamic MPU Regions </b></p>
<p>If an owner is specified for a memory region MICROSAR OS initializes a hardware MPU </p>
<p>region to be dynamically reprogrammed during OS runtime. Whenever the owner of the </p>
<p>memory is active during runtime a specific hardware MPU region is programmed with the </p>
<p>configured values of the memory region. </p>
<p>Memory regions which are assigned to an OS application are reprogrammed whenever the </p>
<p>OS application is switched. </p>
<p>Memory regions which are assigned to tasks or ISRs are reprogrammed with each thread </p>
<p>switch. </p>
<p> </p>
<p><b>2.17.3.3 </b></p>
<p><b>Freedom from Interference </b></p>
<p>MICROSAR  OS  is  able  to  encapsulate  OS  application  data,  task  private  data  and  ISR </p>
<p>private data. This does also depend on the owner of the memory region. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>73 </p>
<p>based on template version 6.0.1 </p>
<p><b>Memory Region Owner </b></p>
<p><b>Access Granted To </b></p>
<p><b>Access Denied For </b></p>
<p>OS application </p>
<p>Runtime objects of this OS </p>
<p>application </p>
<p><b>&gt; </b></p>
<p>Tasks </p>
<p><b>&gt; </b></p>
<p>ISRs </p>
<p><b>&gt; </b></p>
<p>IOC callbacks </p>
<p><b>&gt; </b></p>
<p>Non-trusted functions </p>
<p><b>&gt; </b></p>
<p>Application specific hooks </p>
<p><b>&gt; </b></p>
<p>Other non-trusted OS </p>
<p>applications and its </p>
<p>applications objects </p>
<p>Task </p>
<p><b>&gt; </b></p>
<p>The owning task </p>
<p><b>&gt; </b></p>
<p>Other non-trusted OS </p>
<p>applications and its </p>
<p>applications objects </p>
<p><b>&gt; </b></p>
<p>Other runtime objects of the </p>
<p>belonging OS application </p>
<p>ISR </p>
<p><b>&gt; </b></p>
<p>The owning ISR </p>
<p> </p>
<p><b>2.17.4 </b></p>
<p><b>Stack Monitoring </b></p>
<p>MICROSAR OS uses one memory region of the MPU to supervise the current stack. This </p>
<p>is the default handling in SC3 and SC4 systems. See 2.3.5 for details. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Memory regions must not be configured to allow write access into any stack regions. </p>
<p>Otherwise the OS cannot ensure stack data integrity. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.17.5 </b></p>
<p><b>Protection Violation Handling </b></p>
<p>Upon any memory protection violation the OS </p>
<p><b>&gt; </b></p>
<p>Switches to the kernel stack </p>
<p><b>&gt; </b></p>
<p>Informs the application by execution of the ProtectionHook() </p>
<p><b>2.17.6 </b></p>
<p><b>Optimized / Fast Core MPU Handling </b></p>
<p>If the number of application / task / ISR specific memory regions is small, MICROSAR OS </p>
<p>may have the possibility to initialize the MPU entirely with static MPU regions. </p>
<p>By  utilize  memory  protection  identifiers  different  access  rights  may  still  be  achieved </p>
<p>between different applications. </p>
<p>MICROSAR OS switches access rights by simply switching the protection identifier. This </p>
<p>will result in a very fast MPU handling. </p>
<p><b>&gt; </b></p>
<p>Configure only memory regions which are static (no owner is assigned). </p>
<p><b>&gt; </b></p>
<p>Use “OsMemoryRegionIdentifier” to assign a protection identifier to that region. </p>
<p><b>&gt; </b></p>
<p>Assign either OS applications or Tasks and ISRs to use a specific protection identifier </p>
<p>(OsAppMemoryProtectionIdentifier, OsTaskMemoryProtectionIdentifier, </p>
<p>OsIsrMemoryProtectionIdentifier) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>74 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Depending on the used platform protection identifiers are also referred as PID (MPC), </p>
<p>ASID (RH850) or protection sets (TriCore). But the basic technique is the same. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.17.7 </b></p>
<p><b>Recommended Configuration </b></p>
<p>MICROSAR OS offers a recommended MPU configuration which contains a basic setup. </p>
<p>It configures the MPU to achieve the access rights as follows </p>
<p><b>Access Rights </b></p>
<p>Trusted Software </p>
<p>Non-Trusted Software </p>
<p>Executable rights to whole memory </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Read access to whole RAM / ROM </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Write access to whole RAM (except </p>
<p>stack regions) </p>
<p><b>X </b></p>
<p><b>- </b></p>
<p>Read / Write access to peripheral </p>
<p>registers </p>
<p><b>X </b></p>
<p><b>- </b></p>
<p>Read / Write access to global shared </p>
<p>memory </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Write access to current active stack </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Table 2-7  </p>
<p>Recommended Configuration MPU Access Rights </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>75 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.18 </b></p>
<p><b>Memory Access Checks </b></p>
<p><b>2.18.1 </b></p>
<p><b>Description </b></p>
<p>AUTOSAR OS specifies functions for checking memory access rights of an ISR or task to </p>
<p>a specific memory region. </p>
<p><b>&gt; </b></p>
<p>CheckTaskMemoryAccess </p>
<p><b>&gt; </b></p>
<p>CheckISRMemoryAccess </p>
<p><b>2.18.2 </b></p>
<p><b>Activation </b></p>
<p>No </p>
<p>explicit </p>
<p>activation </p>
<p>of </p>
<p>these  API </p>
<p>service </p>
<p>functions </p>
<p>necessary. </p>
<p>They </p>
<p>are </p>
<p>provided </p>
<p>automatically by the OS. </p>
<p><b>2.18.3 </b></p>
<p><b>Usage </b></p>
<p>The  API  service  functions  CheckTaskMemoryAccess()  and  CheckISRMemoryAccess() </p>
<p>work on additional configuration data which has to be provided by the user. </p>
<p>Therefore  additional  regions  (“OsAccessCheckRegion“)  may  be  configured.  Tasks  and </p>
<p>ISRs may be assigned to each access check region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All memory access checks are based upon the configured “OsAccessCheckRegion” </p>
<p>objects. They are not based upon current MPU values during runtime! </p>
<p>OsAccessCheckRegions and OsMemoryRegions contain redundant information. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.18.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>76 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.19 </b></p>
<p><b>Timing Protection Concept </b></p>
<p><b>2.19.1 </b></p>
<p><b>Description </b></p>
<p>To implement timing protection, MICROSAR OS needs a timer hardware which is able to </p>
<p>generate an interrupt with high priority. This interrupt is never disabled by the OS interrupt </p>
<p>handling API. </p>
<p>Two concepts may be implemented within MICROSAR OS: </p>
<p><b></b></p>
<p><b> </b></p>
<p>The timing protection interrupt request is non-maskable (NMI request) </p>
<p><b></b></p>
<p><b> </b></p>
<p>The timing protection interrupt request is maskable </p>
<p>The consequences of both concepts are shown in the comparison: </p>
<p><b> </b></p>
<p>Timing Protection IRQ is </p>
<p>Maskable </p>
<p>Timing Protection IRQ is NMI </p>
<p><b>Level of timing </b></p>
<p><b>protection IRQ </b></p>
<p>The level of the interrupt source </p>
<p>is chosen to be higher than the </p>
<p>highest category 1 ISR. </p>
<p>The exception source has no </p>
<p>interrupt level. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Any category 1 ISR bypasses the OS. For this reason such an ISR may get terminated </p>
<p>in case it is executed, while the budget of a monitored entity is exhausted. </p>
<p>Thus the AUTOSAR OS specification advises not to use category 1 ISRs within a </p>
<p>system which uses timing protection. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>In case of an inter-arrival time violation MICROSAR OS does currently not provide the </p>
<p>information which task or ISR did violate its inter-arrival time. GetTaskID() and </p>
<p>GetISRID() return the current task / ISR. The suppressed task / ISR ID is not returned </p>
<p>by these APIs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.19.2 </b></p>
<p><b>Activation </b></p>
<p>Timing  protection  features  are  activated  by  setting  the  scalability  class  to  SC2  or  SC4 </p>
<p>(OsScalabilityClass). </p>
<p>Afterwards </p>
<p>timing </p>
<p>protection </p>
<p>containers </p>
<p>may </p>
<p>be </p>
<p>configured </p>
<p>for </p>
<p>tasks </p>
<p>or </p>
<p>ISRs </p>
<p>(OsTaskTimingProtection / OsIsrTimingProtection). Observed  times  are  configured  within </p>
<p>these containers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>77 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.19.3 </b></p>
<p><b>Usage </b></p>
<p>Once the timing protection feature is active tasks and ISRs are observed automatically by </p>
<p>the OS. </p>
<p>Observation  of  a  particular  OS  object  (task  /  ISR)  only  takes  place  if  any  execution </p>
<p>budgets or locking times are configured for this object. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>78 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.20 </b></p>
<p><b>IOC </b></p>
<p><b>2.20.1 </b></p>
<p><b>Description </b></p>
<p>The Inter OS-Application Communicator (IOC) is responsible for data exchange between </p>
<p>OS applications. It handles two important tasks </p>
<p><b>&gt; </b></p>
<p>Data exchange across core boundaries </p>
<p><b>&gt; </b></p>
<p>Data exchange across memory protection boundaries </p>
<p>Parts of the IOC API services are generated. </p>
<p>MICROSAR OS always tries to generate IOC API services and data structures to minimize </p>
<p>resource usage. </p>
<p>Especially the runtime of IOC API services is influenced by the configuration of IOC </p>
<p>objects. For the customer it is important how configuration aspects minimize the IOC </p>
<p>runtime. </p>
<p>For each IOC object MICROSAR OS decides during runtime whether </p>
<p><b>&gt; </b></p>
<p>Interrupt locks </p>
<p><b>&gt; </b></p>
<p>Spinlocks </p>
<p>Are used or not. </p>
<p><b>2.20.2 </b></p>
<p><b>Unqeued (Last Is Best) Communication </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Whenever the data of a last is best IOC object can be written / read atomically (integral </p>
<p>data type) no spinlocks are used at all. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.20.2.1 </b></p>
<p><b>1:1 Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p><b>2.20.2.2 </b></p>
<p><b>N:1 Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Used </p>
<p>Used </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>79 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.20.2.3 </b></p>
<p><b>N:M Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p><b>2.20.3 </b></p>
<p><b>Queued Communication </b></p>
<p>For 1:1 and N:1 Communication the following table is applied: </p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Not Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p><b>2.20.4 </b></p>
<p><b>Notification </b></p>
<p>MICROSAR OS provides configurable receiver callback functions for notification purposes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case an IOC object has a configured receiver callback function a system call trap is </p>
<p>needed in any case. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.20.5 </b></p>
<p><b>Particularities </b></p>
<p><b>2.20.5.1 </b></p>
<p><b>N:1 Queued Communication </b></p>
<p>N:1 queued commination is realized with multiple sender queues. The receiver application </p>
<p>does  an  even  multiplexing  on  all  sender  queues  when  calling  the  receive  function  (see </p>
<p>figure). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>80 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p>Figure 2-5 </p>
<p>N:1 Multiple Sender Queues </p>
<p><b>2.20.5.2 </b></p>
<p><b>IOC Spinlocks </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During generation of OS data structures, if MICROSAR OS detects that a spinlock is </p>
<p>needed for a particular IOC object, it automatically creates a spinlock object within the </p>
<p>OS configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.20.5.3 </b></p>
<p><b>Notification </b></p>
<p>Based  on  the  core  assignment  of  sender  and  receiver  of  an  IOC  object,  two  possible </p>
<p>scenarios for callback handling are possible. </p>
<p><b>Sender and Receiver are located on </b></p>
<p><b>the same core </b></p>
<p><b>&gt; </b></p>
<p>The callback notification function is called within the </p>
<p>IOC send function </p>
<p><b>Sender and Receiver are located on </b></p>
<p><b>different cores </b></p>
<p><b>&gt; </b></p>
<p>The sender triggers an X-Signal request on the </p>
<p>receiving core </p>
<p><b>&gt; </b></p>
<p>The callback notification function is called within the </p>
<p>X-Signal ISR </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>81 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p><b>&gt; </b></p>
<p>All callback functions are using the cores IOC receiver pull callback stack. </p>
<p><b>&gt; </b></p>
<p>During execution of the IOC receiver pull callback function category 2 ISRs are </p>
<p>disabled. </p>
<p><b>&gt; </b></p>
<p>Within IOC receiver pull callback functions only other IOC API functions and </p>
<p>interrupt dis/enable API functions are allowed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.20.5.4 </b></p>
<p><b>Complex Data Types </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If “OsIocDataType” of an IOC object is a complex data type, MICROSAR OS uses a </p>
<p>memcpy function of the VStdLib Module for data transfer and initialization. </p>
<p>See VStdLib Technical Reference [8]. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>82 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.21 </b></p>
<p><b>Trusted OS Applications </b></p>
<p>Trusted  OS  Applications  are  basically  executed  in  supervisor  mode.  They  can  have </p>
<p>read/write access to nearly the whole memory (except stack regions). </p>
<p>MICROSAR OS allows gradually restricting of access rights of trusted OS applications. </p>
<p>Trusted OS applications may be restricted by memory access or by processor mode. </p>
<p><b>2.21.1 </b></p>
<p><b>Trusted OS Applications with Memory Protection </b></p>
<p><b>2.21.1.1 </b></p>
<p><b>Description </b></p>
<p>Runtime objects (Tasks / ISRs / Trusted functions) of trusted OS applications with enabled </p>
<p>memory protection have the following behavior </p>
<p><b>&gt; </b></p>
<p>They run in supervisor mode </p>
<p><b>&gt; </b></p>
<p>Memory access has to be granted explicitly (in the same way as for a non-trusted OS </p>
<p>application) </p>
<p><b>&gt; </b></p>
<p>The MPU is re-programmed whenever software of the OS application is executed. </p>
<p><b>2.21.1.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsTrustedApplicationWithProtection” to TRUE. </p>
<p><b>2.21.1.3 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p><b>2.21.2 </b></p>
<p><b>Trusted OS Applications in User Mode </b></p>
<p><b>2.21.2.1 </b></p>
<p><b>Description </b></p>
<p>Such  OS  applications  can  have  read/write  access  to  nearly  the  whole  memory  (except </p>
<p>stack  regions),  but  they  are  running  in  user  mode.  This  is  also  applied  to  all  runtime </p>
<p>objects (Tasks / ISRs / Trusted functions) assigned to this OS application. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>API runtimes for OS applications which run in user mode are longer. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.21.2.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsApplicationIsPrivileged” to FALSE. </p>
<p><b>2.21.2.3 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>83 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.21.3 </b></p>
<p><b>Trusted Functions </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>The interrupt state of the caller is preserved when entering the trusted function. </p>
<p>&gt; </p>
<p>The trusted function may manipulate the interrupt state by using OS services. The changed </p>
<p>interrupt state is preserved upon return from the trusted function. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Nesting level of trusted functions is limited to 255. </p>
<p>The application has to ensure that this limitation is held. There is no error detection </p>
<p>within the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>84 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.22 </b></p>
<p><b>OS Hooks </b></p>
<p><b>2.22.1 </b></p>
<p><b>Runtime Context </b></p>
<p>MICROSAR  OS  implements  the  runtime  context  and  accessing  rights  of  OS  Hooks </p>
<p>according to the following table </p>
<p><b>Hook Name </b></p>
<p><b>Processor Mode  Access Rights </b></p>
<p><b>Interrupt State </b></p>
<p>StartupHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Category 2 lock </p>
<p>level </p>
<p>ErrorHook </p>
<p>ShutdownHook </p>
<p>Category 1 lock </p>
<p>level </p>
<p>ProtectionHook </p>
<p>StartupHook_&lt;OS application name&gt; </p>
<p>Depending on the configuration of </p>
<p>the owning OS application </p>
<p>Category 2 lock </p>
<p>level </p>
<p>ErrorHook_&lt;OS application name&gt; </p>
<p>ShutdownHook_&lt;OS application name&gt; </p>
<p>TP lock level </p>
<p>Os_PanicHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>TP lock level </p>
<p>PreTaskHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>TP lock level </p>
<p>PostTaskHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>TP lock level </p>
<p>AlarmCallbacks </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Category 1 lock </p>
<p>level </p>
<p>IOC receiver pull callbacks </p>
<p>Depending on the configuration of </p>
<p>the owning OS application </p>
<p>Category 2 lock </p>
<p>level </p>
<p> </p>
<p><b>2.22.2 </b></p>
<p><b>Nesting behavior </b></p>
<p>It is possible that OS hooks may be nested by other OS hooks according to the following </p>
<p>table </p>
<p><b>Nested by </b></p>
<p><b>OS Hook </b></p>
<p>ErrorHook(s) </p>
<p>ProtectionHook </p>
<p>StartupHook(s) </p>
<p>ShutdownHook(s))  IOC Callbacks </p>
<p>ErrorHook(s) </p>
<p>Not possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>ProtectionHook </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>StartupHook(s) </p>
<p>possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>ShutdownHook(s) </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>possible </p>
<p>IOC Callbacks </p>
<p>possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>Not possible </p>
<p> </p>
<p> </p>
<p><b>2.22.3 </b></p>
<p><b>Hints </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within OS Hooks the interrupts must not be enabled again! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>85 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Hooks must never be called by application code directly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for SC2 or SC4 </b></p>
<p>Hooks don’t have any own runtime budgets. OS Hooks consume the budget of the </p>
<p>current task / ISR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note: Protection violations during OS Hooks </b></p>
<p>If any protection violation occurs during the hooks </p>
<p></p>
<p> PreTaskHook </p>
<p></p>
<p> PostTaskHook </p>
<p>the OS will always go into shutdown! </p>
<p>The return value of the ProtectionHook (e.g. PRO_TERMINATEAPPL) will be ignored </p>
<p>and overwritten by the OS to PRO_SHUTDOWN. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>86 </p>
<p>based on template version 6.0.1 </p>
<p><b>3 </b></p>
<p><b>Vector Specific OS Features </b></p>
<p>This chapter describes functions which are available only in MICROSAR OS. They extend </p>
<p>the standardized OS functions from the AUTOSAR and OSEK OS standard [1] [2]. </p>
<p><b>3.1 </b></p>
<p><b>Optimized Spinlocks </b></p>
<p><b>3.1.1 </b></p>
<p><b>Description </b></p>
<p>For  core  synchronization  in  multi  core  systems,  MICROSAR  OS  offers  (beneath  the </p>
<p>AUTOSAR specified OS spinlocks) additional optimized spinlocks. </p>
<p>They are able to reduce the runtime of the Spinlock API. Configuration is also easier. </p>
<p>AUTOSAR  specified  OS  spinlocks  cannot  cause  any  deadlocks  between  cores  (see </p>
<p>unique order of nesting OS spinlocks in AUTOSAR OS standard). Therefore some error </p>
<p>checks on OS configuration data are necessary. </p>
<p>The error checks are not performed with optimized spinlocks. </p>
<p><b> </b></p>
<p>OS Spinlocks </p>
<p>Optimized Spinlocks </p>
<p><b>Deadlocks </b></p>
<p>No deadlocks possible </p>
<p>Deadlocks are possible </p>
<p><b>Runtime </b></p>
<p>Longer runtime due to more error </p>
<p>checks </p>
<p>Smaller runtime due to less error </p>
<p>checks </p>
<p><b>Configuration </b></p>
<p>OsSpinlockSuccessor must be </p>
<p>configured if spinlocks must be </p>
<p>nested </p>
<p>OsSpinlockSuccessor need not to </p>
<p>be configured </p>
<p><b>Nesting </b></p>
<p>Can be nested by other OS </p>
<p>spinlocks </p>
<p>Nesting of optimized spinlock </p>
<p>should be avoided or at least be </p>
<p>used with caution </p>
<p><b>Linking </b></p>
<p>OS and optimized spinlock variables are placed into different </p>
<p>dedicated memory sections (see 4.3.1). </p>
<p>Table 3-1  </p>
<p>Differences of OS and Optimized Spinlocks </p>
<p><b>3.1.2 </b></p>
<p><b>Activation </b></p>
<p>The spinlock attribute “OsSpinlockLockType” may be set to “OPTIMIZED”. </p>
<p>The “OsSpinlockSuccessor” attribute should not be configured for an optimized spinlock. </p>
<p><b>3.1.3 </b></p>
<p><b>Usage </b></p>
<p>Once a spinlock object is configured to be an optimized spinlock the application may use </p>
<p>the  Spinlock  API  as  usual.  The  Spinlock  service  functions  are  capable  to  deal  with </p>
<p>optimized and OS spinlocks. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>87 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.2 </b></p>
<p><b>Barriers </b></p>
<p><b>3.2.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  the  feature  to  synchronize  participating  tasks  at  a  referenced </p>
<p>barrier. The calling task is blocked until the required numbers of tasks have also called the </p>
<p>method referencing the same barrier. </p>
<p><b>3.2.2 </b></p>
<p><b>Activation </b></p>
<p>Within OS configuration “Barrier” objects may be specified. A barrier consists of a list of </p>
<p>tasks that participate the barrier. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Only one task per core may be assigned to a barrier object. The assigned task must </p>
<p>also be the task that calls the API. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.2.3 </b></p>
<p><b>Usage </b></p>
<p>If  one  or  more  barriers  are  configured  Os_BarrierSynchronize  may  be  called  inside  the </p>
<p>tasks  that  are  configured  to  participate  the  barrier.  Tasks  can  participate  in  multiple </p>
<p>barriers. Per core only one task can participate a single barrier. </p>
<p>The core on which a task calls Os_BarrierSynchronize gets blocked inside the API until all </p>
<p>other participating tasks have called the API for the same BarrierID. </p>
<p> </p>
<p> </p>
<p>Figure 3-1 </p>
<p>Barriers </p>
<p>Os_BarrierSynchronize(Barrier2)</p>
<p>Os_BarrierSynchronize(Barrier1</p>
<p>)</p>
<p>Task2</p>
<p>Os_BarrierSynchronize(Barrier2</p>
<p>)</p>
<p>Os_BarrierSynchronize(Barrier1</p>
<p>)</p>
<p>Task3</p>
<p>Barrier2</p>
<p>Barrier1</p>
<p>Os_BarrierSynchronize(Barrier1</p>
<p>)</p>
<p>Task1</p>
<p>(</p>
<p>Waiting</p>
<p>for other cores)</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>88 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Deadlock may occur if one task has called Os_BarrierSynchronize and one of the other </p>
<p>participants don’t calls the API for the same barrier. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>89 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.3 </b></p>
<p><b>Peripheral Access API </b></p>
<p><b>3.3.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers peripheral access services for manipulating registers of peripheral </p>
<p>units.  The  application  may  delegate  such  accesses  to  the  OS  in  case  that  its  own </p>
<p>accessing rights are not sufficient to manipulate specific peripheral registers. </p>
<p><b>3.3.2 </b></p>
<p><b>Activation </b></p>
<p>The API service functions themselves do not need any activation. </p>
<p>But within the OS configuration “OsPeripheralRegion” objects may be specified. They are </p>
<p>needed for error and access checking by the OS. </p>
<p>An OsPeripheralRegion object consists of the start address, end address and a list of OS </p>
<p>applications which have accessing rights to the peripheral region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Access to a peripheral region is granted if the following constraint is held </p>
<p>Start address of peripheral region &lt;= Accessed address &lt;= End address of peripheral region </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.3.3 </b></p>
<p><b>Usage </b></p>
<p>Once peripheral regions are configured they may be passed to the API functions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference</b> </p>
<p>The API service functions themselves are described in chapter 5.2.2. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.3.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p><b>3.3.5 </b></p>
<p><b>Alternatives </b></p>
<p>The access rights to peripheral registers may also be granted by configure an additional </p>
<p>MPU region for the accessing OS application. </p>
<p><b>3.3.6 </b></p>
<p><b>Common Use Cases </b></p>
<p>The peripheral access APIs may be used … </p>
<p><b>&gt; </b></p>
<p>… if the accessing OS application runs in user mode but the register to be </p>
<p>manipulated can only be accessed in supervisor mode. </p>
<p><b>&gt; </b></p>
<p>… if the application does not want to spend a whole MPU region to grant access </p>
<p>rights. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>90 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.4 </b></p>
<p><b>Trusted Function Call Stubs </b></p>
<p><b>3.4.1 </b></p>
<p><b>Description </b></p>
<p>Since the OS service CallTrustedFunction() is very generic, there is the need to implement </p>
<p>a  stub-interface  which  does  the  packing  and  unpacking  of  the  arguments  for  trusted </p>
<p>functions. </p>
<p>MICROSAR OS is able to generate these stub functions. </p>
<p><b>3.4.2 </b></p>
<p><b>Activation </b></p>
<p>The OS application attribute “OsAppUseTrustedFunctionStubs” must be set to TRUE. Data </p>
<p>types </p>
<p>must </p>
<p>be </p>
<p>defined </p>
<p>in </p>
<p>the </p>
<p>header </p>
<p>file </p>
<p>which </p>
<p>is </p>
<p>referred </p>
<p>by </p>
<p>“OsAppCalloutStubsIncludeHeader”. </p>
<p><b>3.4.3 </b></p>
<p><b>Usage </b></p>
<p>A particular trusted function is called with the following syntax: </p>
<p>&lt;configured return type&gt; Os_Call_&lt;trusted function name&gt; </p>
<p>(&lt;configured parameters&gt;); </p>
<p>Parameter packing, unpacking and return value handling is done by the stub function. </p>
<p><b>3.4.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>91 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.5 </b></p>
<p><b>Non-Trusted Functions (NTF) </b></p>
<p><b>3.5.1 </b></p>
<p><b>Description </b></p>
<p>Service  functions  which  are  provided  by  non-trusted  OS  applications  are  called  non-</p>
<p>trusted functions. They have the following characteristics: </p>
<p><b>&gt; </b></p>
<p>They run in user mode. </p>
<p><b>&gt; </b></p>
<p>They run with the MPU access rights of the owning OS application. </p>
<p><b>&gt; </b></p>
<p>They perform a stack switch to specific non-trusted function stacks. </p>
<p><b>&gt; </b></p>
<p>They run on an own secured stack. </p>
<p><b>&gt; </b></p>
<p>They can safely provide non-trusted code to other OS applications. </p>
<p><b>&gt; </b></p>
<p>Parameters are passed to the NTF with a reference to a data structure provided by </p>
<p>the caller. </p>
<p><b>&gt; </b></p>
<p>Returning of values is only possible if the caller passes the non-trusted functions </p>
<p>parameters as pointer to global accessible data. </p>
<p><b>3.5.2 </b></p>
<p><b>Activation </b></p>
<p>They are defined within an OsApplication container (“OsApplicationNonTrustedFunction”). </p>
<p>The attribute “OsTrusted” for this OS application must be set to FALSE. </p>
<p><b>3.5.3 </b></p>
<p><b>Usage </b></p>
<p>Similar to the  CallTrustedFunction() API  of the AUTOSAR  OS  standard  MICROSAR  OS </p>
<p>implements </p>
<p>an </p>
<p>additional </p>
<p>service </p>
<p>which </p>
<p>is </p>
<p>called </p>
<p>Os_CallNonTrustedFunction() </p>
<p>(see </p>
<p>chapter 5.2.4 for Details). </p>
<p>Configured non-trusted functions are called with this API. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>The interrupt state of the caller is preserved when entering the non-trusted function </p>
<p>&gt; </p>
<p>The non-trusted function may manipulate the interrupt state by using OS services. The </p>
<p>changed interrupt state is preserved upon return from the non-trusted function. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Non-trusted functions currently cannot be terminated without termination of the caller. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.5.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>92 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.6 </b></p>
<p><b>Fast Trusted Functions </b></p>
<p><b>3.6.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  the  feature  of  runtime  optimized  trusted  functions  (fast  trusted </p>
<p>functions). </p>
<p>The  speedup  of  the  runtime  is  achieved  by  removing  most  of  the  OS  error  checks,  the </p>
<p>application switch and the MPU reprogramming. </p>
<p>Fast trusted functions have the following characteristics: </p>
<p><b>&gt; </b></p>
<p>They may be called with disabled interrupts. </p>
<p><b>&gt; </b></p>
<p>They run in supervisor mode. </p>
<p><b>&gt; </b></p>
<p>They run with the application ID of the caller. </p>
<p><b>&gt; </b></p>
<p>They run on the stack of the caller. </p>
<p><b>&gt; </b></p>
<p>They run with the MPU settings of the caller. </p>
<p><b>&gt; </b></p>
<p>Parameters are passed to the fast trusted function with a reference to a data </p>
<p>structure provided by the caller. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Calls to other OS API services are not allowed within a fast trusted function! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.6.2 </b></p>
<p><b>Activation </b></p>
<p>They are defined within an OsApplication container (“OsApplicationFastTrustedFunction”). </p>
<p>The attribute “OsTrusted” for this OS application must be set to TRUE. </p>
<p><b>3.6.3 </b></p>
<p><b>Usage </b></p>
<p>Similar to the  CallTrustedFunction() API  of the AUTOSAR  OS  standard  MICROSAR OS </p>
<p>implements </p>
<p>an </p>
<p>additional </p>
<p>service </p>
<p>which </p>
<p>is </p>
<p>called </p>
<p>Os_CallFastTrustedFunction() </p>
<p>(see </p>
<p>chapter 5.2.5 for Details). </p>
<p>Configured fast trusted functions are called with this API. </p>
<p><b>3.6.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>93 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.7 </b></p>
<p><b>Interrupt Source API </b></p>
<p><b>3.7.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  additional API  services  for  category  2  ISRs  and  their  respective </p>
<p>interrupt sources. </p>
<p>The services include </p>
<p><b>&gt; </b></p>
<p>Enable of an interrupt source </p>
<p><b>&gt; </b></p>
<p>Disable of an interrupt source </p>
<p><b>&gt; </b></p>
<p>Clearing of the interrupt pending bit </p>
<p><b>&gt; </b></p>
<p>Checking if the interrupt source is enabled </p>
<p><b>&gt; </b></p>
<p>Checking of interrupt pending bit status </p>
<p>(See 5.2.6 for API details). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>94 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.8 </b></p>
<p><b>Pre-Start Task </b></p>
<p><b>3.8.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers the possibility to provide a set of OS API functions for initialization </p>
<p>purposes before StartOS has been called. </p>
<p>Therefore a pre-start task may be configured which is capable to run before the OS has </p>
<p>been started. Within this task stack protection is enabled and particular OS APIs can be </p>
<p>used. </p>
<p>The table in 5.2.15 lists the OS API functions which may be used within the Pre-Start task. </p>
<p><b>3.8.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define a basic task </p>
<p><b>&gt; </b></p>
<p>Within a core object this basic task has to be referred to be the pre-start task of this </p>
<p>core (attribute “OsCorePreStartTask”). Only one pre-start task per core is possible. </p>
<p><b>&gt; </b></p>
<p>Start the OS as described below </p>
<p><b>3.8.3 </b></p>
<p><b>Usage </b></p>
<p>1. </p>
<p>Execute Startup Code </p>
<p>2. </p>
<p>Call </p>
<p>Os_InitMemory()</p>
<p> </p>
<p>3. </p>
<p>Call </p>
<p>Os_Init()</p>
<p> </p>
<p>4. </p>
<p>Call </p>
<p>Os_EnterPreStartTask() </p>
<p>(see 5.2.3 for Details) </p>
<p>5. </p>
<p>The OS schedules and dispatches to the task which has been referred as pre-start </p>
<p>task. </p>
<p>6. </p>
<p>The pre-start task has to be left by a call to </p>
<p>StartOS()</p>
<p>  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The pre-start task may only be active once prior to StartOS() call. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within the pre-start task the getter OS API services (e.g. GetActiveApplicationMode()) </p>
<p>neither return a valid result nor a valid error code. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>95 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If MICROSAR OS encounters an error within the pre-start task, only the global hooks </p>
<p>(ErrorHook(), ProtectionHook() and ShutdownHook()) are executed. OS application </p>
<p>specific hooks won’t be executed. </p>
<p>Consider that the StartupHook() did not yet run when the Pre-Start Task is executed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the Pre-Start Task is used, global hooks have to consider that the OS might not be </p>
<p>completely initialized. OS APIs which are allowed after normal initialization (e.g. </p>
<p>TerminateApplication()) are not allowed within global hooks, if the error occurred in the </p>
<p>Pre-Start Task. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the ProtectionHook() is triggered within the Pre-Start Task, the OS ignores its return </p>
<p>value. The only valid return value is PRO_SHUTDOWN. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.8.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>96 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.9 </b></p>
<p><b>X-Signals </b></p>
<p><b>3.9.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS uses cross core signaling (X-Signals) to realize API service calls between </p>
<p>cores. </p>
<p>The next figure shows the basic principles of an X-Signal </p>
<p> </p>
<p>Figure 3-2 </p>
<p>X-Signal </p>
<p>Whenever a core executes a service API cross core it writes this request into its own send </p>
<p>port queue. Then it signals this request by an interrupt request (X-Signal) to the serving </p>
<p>core. </p>
<p>The serving core reads the request from the send port queue and executes the requested </p>
<p>service API. The result of the service API is provided in the receive port queue. </p>
<p> </p>
<p>X-Signals have the following characteristics: </p>
<p><b>&gt; </b></p>
<p>An X-Signal is a unidirectional request from one core to another (1:1). </p>
<p><b>&gt; </b></p>
<p>For each core interconnection one X-Signal is needed. </p>
<p><b>&gt; </b></p>
<p>All accesses to the (sender / receiver) port queues are lock free. </p>
<p><b>&gt; </b></p>
<p>Queue Sizes must be configured. </p>
<p><b>&gt; </b></p>
<p>The Queues may be protected by MPU to achieve freedom of interference between </p>
<p>cores. </p>
<p><b>&gt; </b></p>
<p>X-Signals may be configured to offer only a subset of possible cross core API services. </p>
<p>Not configured API services are refused to be served. </p>
<p><b>Requesting</b></p>
<p><b>Core</b></p>
<p><b>Serving</b></p>
<p><b>Core</b></p>
<p><b>X-Signal</b></p>
<p><b>Send Port Queue</b></p>
<p><b>Receive Port Queue</b></p>
<p><b>R/W access</b></p>
<p><b>Read only access</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>97 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>The API error codes for cross core API services are extended. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Additional error codes for queue handling. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Additional error code if the requested service is refused to be served. </p>
<p><b>&gt; </b></p>
<p>X-Signals can be configured to be synchronous or asynchronous. </p>
<p><b> </b></p>
<p><b>Synchronous X-Signal </b></p>
<p><b>Asynchronous X-Signal </b></p>
<p>Call behavior </p>
<p>After the cross core service API has </p>
<p>been requested the requester core </p>
<p>goes into active waiting loop and </p>
<p>polls for the result from the server </p>
<p>core (remote procedure call). </p>
<p><b>Note: </b>During active wait the </p>
<p>interrupts are enabled. </p>
<p>After the cross core service API has </p>
<p>been requested the requester core </p>
<p>continues its own program execution.  </p>
<p>Error signaling </p>
<p>Error handling is induced on the </p>
<p>requester core immediately, if the </p>
<p>polled API result is not E_OK. </p>
<p>Error handling is induced with the </p>
<p>next X-Signal request on the </p>
<p>requester core, if the result of the </p>
<p>previously requested API is not </p>
<p>E_OK. </p>
<p><b>Note</b>: Upon potential errors of the </p>
<p>previously requested API the current </p>
<p>application ID on sender and receiver </p>
<p>side meanwhile may have changed. </p>
<p>AUTOSAR standard </p>
<p>compliance </p>
<p>Compliant to the AUTOSAR </p>
<p>Standard </p>
<p>Deviation to the AUTOSAR Standard </p>
<p>Table 3-2  </p>
<p>Comparison between Synchronous and Asynchronous X-Signal </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Any cross core “getter” APIs e.g. GetTaskState() are always executed with a </p>
<p>synchronous X-Signal. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The sender core as well as the receiver core may cause protection violations. </p>
<p>Protection error handling is performed on the core where the violation is detected. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>98 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>When a cross core API is induced by an X-Signal, all static error checks (e.g. validity of </p>
<p>parameters) are done on the caller side. </p>
<p>All dynamic error checks (which depend on runtime states) are executed on the </p>
<p>receiver side. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>For correct X-Signal function it is essentially that a sender core of an X-Signal must </p>
<p>have read access to the receiver core data structure. Especially if the data is mapped </p>
<p>into core local RAM. </p>
<p>There are some platforms e.g. RH850 which does not grant cross core read access to </p>
<p>core local RAM out of reset. Within such platforms it is the duty of the application to set </p>
<p>up these cross core read accesses before the OS is started. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.9.1.1 </b></p>
<p><b>Notes on Synchronous X-Signals </b></p>
<p>The priority of the receiver ISR determines which other category 2 ISRs of one core may </p>
<p>use cross core API services. </p>
<p>Additionally category 2 ISRs may only use cross core API services if they allow nesting. </p>
<p>The following table gives an overview. </p>
<p><b>Logical Priority </b></p>
<p><b>ISR Nesting </b></p>
<p><b>Synchronous Cross </b></p>
<p><b>Core API Calls </b></p>
<p>ISR with higher priority than X-Signal priority </p>
<p>ISR nesting is allowed </p>
<p>Not allowed </p>
<p>ISR with higher priority than X-Signal priority </p>
<p>ISR nesting is disabled </p>
<p>Not allowed </p>
<p>X-Signal ISR priority </p>
<p>- </p>
<p>- </p>
<p>ISR with lower priority than X-Signal priority </p>
<p>ISR nesting is allowed </p>
<p>Allowed </p>
<p>ISR with lower priority than X-Signal priority </p>
<p>ISR nesting is disabled </p>
<p>Not allowed </p>
<p>Table 3-3  </p>
<p>Priority of X-Signal receiver ISR </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the priority and nesting requirements from the previous table are not fulfilled there </p>
<p>may be deadlocks within a multicore system! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.9.1.2 </b></p>
<p><b>Notes on Mixed Criticality Systems </b></p>
<p>MICROSAR  OS  checks  application  access  rights  on  sender  and  on  receiver  side.  This </p>
<p>increases  isolation  of  safety-critical  parts  in  mixed  criticality  systems  (e.g.  protect  a </p>
<p>lockstep core from a non-lockstep core). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>99 </p>
<p>based on template version 6.0.1 </p>
<p>Consider that these application access checks are not performed for ShutdownAllCores(). </p>
<p>Thus </p>
<p>switching </p>
<p>off </p>
<p>the </p>
<p>usage </p>
<p>of </p>
<p>ShutdownAllCores </p>
<p>API </p>
<p>for </p>
<p>non-lockstep </p>
<p>cores </p>
<p>is </p>
<p>recommended. This can be done within the X-Signal configuration. </p>
<p><b>3.9.2 </b></p>
<p><b>Activation </b></p>
<p>X-Signals must be configured explicitly  in a multi core environment. See chapter 4.5 for </p>
<p>details. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>100 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.10 </b></p>
<p><b>Timing Hooks </b></p>
<p><b>3.10.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS supports timing measurement and analysis by external tools. Therefor it </p>
<p>provides timing hooks. Timing hooks inform the external tools about several events within </p>
<p>the OS: </p>
<p><b>&gt; </b></p>
<p>Activation (arrival) of a task or ISR </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow an external tool to trace all activations of task as well as further arrivals </p>
<p>(e.g. setting of an event or the release of a semaphore with transfer to another task. </p>
<p><b></b></p>
<p><b> </b></p>
<p>They allow external tools to visualize the arrivals and to measure the time between </p>
<p>them in order to allow a schedule-ability analysis. </p>
<p><b>&gt; </b></p>
<p>Context switch </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow external tools to trace all context switches from task to ISR and back as </p>
<p>well as between tasks. So external tools may visualize the information or measure </p>
<p>the execution time of tasks and ISRs.  </p>
<p><b>&gt; </b></p>
<p>Locking of interrupts, resources or spinlocks </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow an external tool to trace locks. This is important as locking times of </p>
<p>tasks and ISRs influence the execution of other tasks and ISRs. The kind of </p>
<p>influence is different for different locks. </p>
<p>Within MICROSAR OS code the timing hooks are called. Additionally it provides empty </p>
<p>hooks by default. </p>
<p>The application may decide to implement any of the hooks by itself. The empty OS default </p>
<p>hook is then replaced by the application implemented hook. </p>
<p><b>3.10.2 </b></p>
<p><b>Activation </b></p>
<p>An  include  header  has  to  be  specified  in  the  attribute  “OsTimingHooksIncludeHeader” </p>
<p>located in the “OsDebug” container. </p>
<p><b>3.10.3 </b></p>
<p><b>Usage </b></p>
<p>The timing hooks may be implemented in the configuration specified header. All available </p>
<p>macros are introduced in chapter 5.2.12. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within the timing hooks trusted access rights are active e.g. access rights to OS </p>
<p>variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>101 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note: Protection violations during Timing Hooks </b></p>
<p>If any protection violation occurs during any of the timing hooks the OS will always go </p>
<p>into shutdown! </p>
<p>The return value of the ProtectionHook (e.g. PRO_TERMINATEAPPL) will be ignored </p>
<p>and overwritten by the OS to PRO_SHUTDOWN. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>102 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.11 </b></p>
<p><b>Kernel Panic </b></p>
<p>If  MICROSAR  OS  recognizes  an  inconsistent  internal  state  it  enters  the  kernel  panic </p>
<p>mode. In such cases, the OS does not know how to correctly continue execution. Even a </p>
<p>regular shutdown cannot be reached. E.g.: </p>
<p><b>&gt; </b></p>
<p>The protection hook itself causes errors </p>
<p><b>&gt; </b></p>
<p>The shutdown hook itself causes errors </p>
<p>MICROSAR OS goes into freeze as fast as possible </p>
<p>1. </p>
<p>Disable all interrupts </p>
<p>2. </p>
<p>Inform the application about the kernel panic by calling the Os_PanicHook() (see </p>
<p>5.2.13) </p>
<p>3. </p>
<p>Enter an endless loop </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>&gt; </p>
<p>The OS cannot recover from kernel panic. </p>
<p>&gt; </p>
<p>ProtectionHook() is not called </p>
<p>&gt; </p>
<p>ErrorHook() is not called </p>
<p>&gt; </p>
<p>There is no stack switch. The Os_PanicHook() runs on the current active stack </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>103 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.12 </b></p>
<p><b>Generate callout stubs </b></p>
<p><b>3.12.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  the  feature  to  generate  the  function  bodies  of  all  configured  OS </p>
<p>hook functions (all global hooks and application specific hooks). </p>
<p>The function bodies are generated into the file “Os_Callout_Stubs.c”. </p>
<p><b>3.12.2 </b></p>
<p><b>Activation </b></p>
<p>The Configuration attribute “OsGenerateCalloutStubs” has to be set to TRUE. </p>
<p><b>3.12.3 </b></p>
<p><b>Usage </b></p>
<p>Once the C-File has been generated it may be altered by the user. Code parts between </p>
<p>certain  special  comments  are  permanent  and  won’t  get  lost  between  two  generation </p>
<p>processes. </p>
<p>If a hook is switched off, the corresponding function body  is also removed. But the user </p>
<p>code (between the special comments) is preserved. Once the hook is switched on again, </p>
<p>the preserved user code is also restored. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>FUNC(void, OS_STARTUPHOOK_CODE) StartupHook(void) </p>
<p>{ </p>
<p>/*********************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!           &lt;USERBLOCK OS_Callout_Stubs_StartupHook&gt; </p>
<p> **********************************************************************/ </p>
<p> </p>
<p>   /* user code starts here */ </p>
<p>   /* code between those comments is preserved even if the file is newly generated  </p>
<p>      Or even if the hook is switched off in the meanwhile */ </p>
<p> </p>
<p>/*********************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!           &lt;/USERBLOCK&gt; </p>
<p> **********************************************************************/ </p>
<p> </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>104 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.13 </b></p>
<p><b>Exception Context Manipulation </b></p>
<p><b>3.13.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers the feature to read and modify the interrupted context in case of a </p>
<p>hardware  exception.  This  feature  shall  be  applied  in  ProtectionHook  in  the  combination </p>
<p>with PRO_IGNORE_EXCEPTION as the return value. One typical use case for this feature </p>
<p>is to recover from an ECC error in memory. </p>
<p><b>3.13.2 </b></p>
<p><b>Usage </b></p>
<p>The following figure shows the usage of this feature. </p>
<p> </p>
<p>Figure 3-3 </p>
<p>Usage of manipulating exception context </p>
<p>Inside  ProtectiohHook  the  user  first  needs  to  call  Os_GetExceptionContext  to  read  the </p>
<p>previous  context. Then  the  context  may  be  investigated  and  modified  according  to  user </p>
<p>requirements. For instance, the program counter may be adapted to the instruction, which </p>
<p>is  to  be  executed  directly  after  the  exception.  Note  that  the  content  of  the  context  is </p>
<p>depending on the platform. In general, the context contains all the processor registers and </p>
<p>some other relevant information. More detailed information can be found in the static code, </p>
<p>where the type Os_ExceptionContextType is defined. Finally the modified context can be </p>
<p>written </p>
<p>back </p>
<p>via </p>
<p>Os_SetExceptionContext. </p>
<p>When </p>
<p>ProtectionHook </p>
<p>returns </p>
<p>with </p>
<p>PRO_IGNORE_EXCEPTION, the processor continues its execution with the manipulated </p>
<p>context. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Currently this feature is supported on PowerPC platform. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>105 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This feature may only be used within ProtectionHook when the error status is either </p>
<p>E_OS_PROTECTION_MEMORY or E_OS_PROTECTION_EXCEPTION </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.14 </b></p>
<p><b>Category 0 Interrupts </b></p>
<p><b>3.14.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  implements  category  0  ISRs  to  have  minimal  interrupt  latency  time </p>
<p>especially in SC2 or SC4 systems. This is an extension to the OS standard. </p>
<p><b>3.14.2 </b></p>
<p><b>Usage </b></p>
<p><b>3.14.2.1 </b></p>
<p><b>Implement Category 0 ISRs </b></p>
<p>MICROSAR  OS  offers  a  macro  for  implementing  a  category  0  ISR.  This  is  a  similar </p>
<p>mechanism like the macro for a category 2 ISR defined by the AUTOSAR standard. </p>
<p>MICROSAR OS abstracts the needed compiler keywords. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Implement a category 0 ISR </b></p>
<p>OS_ISR0(&lt;MyCategory0ISR&gt;) </p>
<p>{ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.14.2.2 </b></p>
<p><b>Nesting of Category 0 ISRs </b></p>
<p>Since category 0 ISRs are directly called from interrupt vector table without any OS pro- </p>
<p>and epilogue, automatic nesting of category 0 ISRs cannot be supported. </p>
<p>The configuration attribute “OsIsrEnableNesting” is ignored for category 0 ISRs. </p>
<p>Nevertheless  the  interrupts  may  be  enabled  during  a  category  0  ISR  to  allow  interrupt </p>
<p>nesting but OS API functions cannot be used for this purpose. The application has to use </p>
<p>compiler intrinsic functions or inline assembler statements. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>OS_ISR0(&lt;MyCategory0ISR&gt;) </p>
<p>{ </p>
<p>   __asm(EI); /* enable nesting of this ISR */ </p>
<p> </p>
<p>   __asm(DI); /* disable nesting before leaving the function */ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>106 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.14.2.3 </b></p>
<p><b>Category 0 ISRs before StartOS </b></p>
<p>There may be the need to activate and serve category 0 ISRs before the OS has been </p>
<p>started. </p>
<p>The following sequence should be implemented: </p>
<p><b>&gt; </b></p>
<p>Call Os_InitMemory </p>
<p><b>&gt; </b></p>
<p>Call Os_Init (within the function the basic interrupt controller settings are initialized </p>
<p>e.g. priorities of interrupt sources). </p>
<p><b>&gt; </b></p>
<p>Enable the interrupt sources of category 0 ISRs by directly manipulating the control </p>
<p>registers in the interrupt controller. </p>
<p><b>&gt; </b></p>
<p>Enable the interrupts by directly manipulating the global interrupt flag and / or current </p>
<p>interrupt priority to allow the category 0 ISRs </p>
<p> </p>
<p><b>3.14.2.4 </b></p>
<p><b>Locations where category 0 ISRs are locked </b></p>
<p>Category 0 interrupts are disabled OS internally for very short times only. </p>
<p>The following list mentions the locations of these locks: </p>
<p><b>&gt; </b></p>
<p>Inside APIs that cause a context switch e.g. TerminateTask </p>
<p><b>&gt; </b></p>
<p>Partial termination due to exception handled by ProtectionHook </p>
<p><b>&gt; </b></p>
<p>On Interrupt, Exception and Trap entry and return </p>
<p><b>&gt; </b></p>
<p>OS initialization routines inside Os_Init and StartOS </p>
<p> </p>
<p><b>3.14.3 </b></p>
<p><b>Notes on Category 0 ISRs </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>On platforms which have no automatic stack switch upon interrupt request there will be </p>
<p>no stack switch at all if a category 0 ISR occurs. Thus the stack consumption of a </p>
<p>category 0 ISR should be added to all stacks which can be consumed by category 0 </p>
<p>ISRs (see 2.3 for an overview). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Category 0 ISRs are consuming timing protection budgets (execution budgets and </p>
<p>locking times) of the interrupted Task or category 2 ISR </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>107 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Although the interrupt priorities are initialized by MICROSAR OS there is no API to </p>
<p>enable or acknowledge category 0 ISRs. The interrupt control registers have to be </p>
<p>accessed directly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the timing protection interrupt occurs during the runtime of a category 0 ISR, its </p>
<p>execution (the timing protection violation handling/protection hook) is delayed until the </p>
<p>category 0 ISR has finished. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR OS does not allow OS API usage within category 0 ISRs. </p>
<p>If any OS API is called anyway, MICROSAR OS is not able to detect this and the called </p>
<p>API may not work as expected. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Category 0 ISRs are always executed with trusted rights on supervisor level.<b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>A category 0 ISR may never lower the interrupt priority of the CPU or the interrupt </p>
<p>controller. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Category 0 ISRs may still occur in case of a shutdown of the OS or even in case the </p>
<p>OS has entered the panic hook. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>108 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Be aware that a category 0 ISR will interrupt category 2 ISRs even if they are </p>
<p>configured to be non-nestable! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the owner application of a category 0 ISR is terminated for any reason, assigned </p>
<p>category 0 ISRs are not disabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The macro “OS_ISR0” abstracts the appropriate compiler keyword for implementing </p>
<p>the interrupt service routine. Thus the compiler generates code which safes and restore </p>
<p>a subset of the general purpose registers. </p>
<p>In certain usecases e.g. usage of the FPU or nested interrupts it may require the user </p>
<p>application to save and restore more registers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>109 </p>
<p>based on template version 6.0.1 </p>
<p><b>4 </b></p>
<p><b>Integration </b></p>
<p><b>4.1 </b></p>
<p><b>Compiler Optimization Assumptions </b></p>
<p>MICROSAR OS makes the following assumptions for compiler optimization: </p>
<p><b>&gt; </b></p>
<p>Inlining of functions is active </p>
<p><b>&gt; </b></p>
<p>Not used functions are removed </p>
<p><b>&gt; </b></p>
<p>If statements with a constant condition (due to configuration) are optimized </p>
<p><b>4.1.1 </b></p>
<p><b>Compile Time </b></p>
<p>To shorten the compile time of the OS the following measures can be taken within the OS </p>
<p>configuration: </p>
<p><b>Systems without active memory </b></p>
<p><b>protection (SC1/SC2) </b></p>
<p>Set “OsGenerateMemMap” to “EMPTY” </p>
<p><b>Systems with memory protection </b></p>
<p><b>(SC3/SC4) </b></p>
<p>Set “OsGenerateMemMap” to “COMPLETE” and </p>
<p>&quot;OsGenerateMemMapForThreads” to “FALSE” </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Hardware Software Interfaces (HSI) </b></p>
<p>The </p>
<p>following </p>
<p>chapter </p>
<p>describes </p>
<p>the </p>
<p>Hardware-Software </p>
<p>Interface </p>
<p>for </p>
<p>the </p>
<p>supported </p>
<p>processor families of the MICROSAR OS. </p>
<p>The HSI describes all hardware registers which are used by the OS. Such registers must </p>
<p>not be altered by user software. </p>
<p>Included within the HSI is the context of the OS. The context is the sum of all registers </p>
<p>which are preserved upon a task switch and ISR execution. </p>
<p>Additionally platform specific characteristics of the OS are described here. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>110 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.1 </b></p>
<p><b>TriCore Aurix Family </b></p>
<p><b>4.2.1.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>A0-A15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>D0-D15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PCXI </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPR0L, DPR0H </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register A8 is exclusively used by the OS to hold the pointer to the current thread. </p>
<p>Thus any addressing modes which would use A8 register are not possible. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.1.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>ICR </p>
<p><b></b></p>
<p><b> </b></p>
<p>SYSCON </p>
<p><b></b></p>
<p><b> </b></p>
<p>PCXI </p>
<p><b></b></p>
<p><b> </b></p>
<p>FCX </p>
<p><b></b></p>
<p><b> </b></p>
<p>LCX </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>DBGSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPRxL, DPRxH </p>
<p><b></b></p>
<p><b> </b></p>
<p>CPRxL, CPRxH </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPREx </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPWEx </p>
<p><b></b></p>
<p><b> </b></p>
<p>CPXEx </p>
<p><b>4.2.1.3 </b></p>
<p><b>Interrupt Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>INT_SRC0 – INTSRC255 (Aurix TC2xx) </p>
<p><b></b></p>
<p><b> </b></p>
<p>INT_SRC0 – INTSRC1023 (Aurix TC3xx) </p>
<p><b>4.2.1.4 </b></p>
<p><b>GPT Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>T2, T3, T6 </p>
<p><b></b></p>
<p><b> </b></p>
<p>T2CON, T3CON, T6CON </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>111 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>CAPREL </p>
<p><b>4.2.1.5 </b></p>
<p><b>STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>TIM0, TIM5, TIM6 </p>
<p><b></b></p>
<p><b> </b></p>
<p>CMCON </p>
<p><b></b></p>
<p><b> </b></p>
<p>CAP </p>
<p><b></b></p>
<p><b> </b></p>
<p>CMP0, CMP1 </p>
<p><b>4.2.1.6 </b></p>
<p><b>Aurix Special Characteristics </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for trap class 1 is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for trap class 6 is implemented by the OS </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The TriCore Hardware enforces that a configured MPU region must be followed by at </p>
<p>least 15 padding bytes before the next region may be started. </p>
<p>MICROSAR OS obey to this rule within the generated linker scripts. For other </p>
<p>additional configured MPU regions the user has to take care to fulfill this requirement </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Figure 4-1 </p>
<p>Padding bytes between MPU regions </p>
<p>Start Address of adjacent MPU Region</p>
<p>End Address of adjacent MPU Region</p>
<p>At least 15 padding bytes</p>
<p>Start Address of MPU Region</p>
<p>End Address of MPU Region</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>112 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity all start addresses and end addresses of configured MPU </p>
<p>regions must be a multiple of 8. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address itself is granted </p>
<p>&gt; </p>
<p>Access to configured end address is prohibited </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR OS does not use the System MPU to achieve freedom of interference </p>
<p>between cores. </p>
<p>This has to be done by the application. </p>
<p>The system MPU has to be initialized by a lockstep core. It must not be accessed by </p>
<p>non-lockstep cores. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 8 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>For proper context management exception handling the LCX should be initialized </p>
<p>during startup code that it does not point to the last available CSA. </p>
<p>In this way some CSAs are reserved which can be used within the context exception </p>
<p>handling for further function calls. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>113 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with HighTec (GNU) Compiler </b></p>
<p>The interrupt vector table (used in BIV) and exception vector table (used in BTV) must </p>
<p>be aligned manually in the user linker script. </p>
<p>The following example shows how the interrupt vector table (of Core0) can be included </p>
<p>and aligned to a 0x2000 byte boundary: </p>
<p>. = ALIGN(8192); </p>
<p>#define OS_LINK_INTVEC_CODE </p>
<p>#include &quot;Os_Link_Core0.ld&quot; </p>
<p>The following example shows how the exception vector table (of Core0) can be </p>
<p>included and aligned to a 0x100 byte boundary: </p>
<p>. = ALIGN(256); </p>
<p>#define OS_LINK_EXCVEC_CODE </p>
<p>#include &quot;Os_Link_Core0.ld&quot;</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>114 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.1.7 </b></p>
<p><b>PSW handling </b></p>
<p><b>PSW.RM bit handling </b></p>
<p>MICROSAR OS sets the rounding mode bits to 0 upon start of a </p>
<p>thread. </p>
<p><b>PSW.S bit handling </b></p>
<p>MICROSAR OS sets the safety task identifier bit to 1 for trusted </p>
<p>software parts and to 0 for non-trusted software parts. </p>
<p><b>PSW.IS bit handling </b></p>
<p>MICROSAR OS sets the interrupt stack bit to 1. </p>
<p>Thus automatic hardware stack switch is not supported. </p>
<p><b>PSW.GW bit handling </b></p>
<p>MICROSAR OS sets the global address register write permission to 0. </p>
<p>Write permission to A0, A1, A8 and A9 are not allowed. </p>
<p><b>PSW.CDE bit handling </b></p>
<p>MICROSAR OS sets the call depth enable bit to 1 upon start of a </p>
<p>thread. </p>
<p>Call depth counting is enabled. </p>
<p><b>PSW.CDC bits handling </b></p>
<p>MICROSAR OS sets the call depth counter to 1 upon start of a thread. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>115 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.2 </b></p>
<p><b>RH850 Family </b></p>
<p><b>4.2.2.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>R1 ... R31 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PMR </p>
<p><b></b></p>
<p><b> </b></p>
<p>LP </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPC, EIPSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPSR, FPEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>ASID </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPLA0, MPUA0 </p>
<p><b>4.2.2.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PMR </p>
<p><b></b></p>
<p><b> </b></p>
<p>LP </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ASID </p>
<p><b></b></p>
<p><b> </b></p>
<p>SCCFG </p>
<p><b></b></p>
<p><b> </b></p>
<p>SCBP </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIWR </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EBASE </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTBP </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTCFG </p>
<p><b></b></p>
<p><b> </b></p>
<p>CTPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIIC </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEIC </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>116 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEPSW  </p>
<p><b></b></p>
<p><b> </b></p>
<p>HTCFG0 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register EIWR is exclusively used by the OS to hold the pointer to the current </p>
<p>thread. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.2.3 </b></p>
<p><b>MPU Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>MPM </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPRC </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPLA0 ... MPLA15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPUA0 ... MPUA15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPAT0 ... MPAT15 </p>
<p><b>4.2.2.4 </b></p>
<p><b>INTC Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>EIC0 ... EIC511 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IBD0 … IBD511 </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEINTFMSK0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEINTFMSK1 </p>
<p><b>4.2.2.5 </b></p>
<p><b>Inter Processor Interrupt Control Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH3 </p>
<p><b>4.2.2.6 </b></p>
<p><b>Timer TAUJ Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCDR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCMUR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCSC </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>117 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCMOR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTPS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTPS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>118 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM1 </p>
<p><b>4.2.2.7 </b></p>
<p><b>Timer STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCKSEL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCSTR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnSTR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnSTC </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnIS </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnRM </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT0L </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT0H </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0AL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0AH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0BL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0BH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0CL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0CH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0DL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0DH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1A </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>119 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1D </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2A </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2D </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT3 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3A </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3D </p>
<p><b>4.2.2.8 </b></p>
<p><b>Timer OSTM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCMP </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTO </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTOE </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTE </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCTL </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnEMU </p>
<p><b>4.2.2.9 </b></p>
<p><b>RH850 Special Characteristics </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p><b>&gt; </b></p>
<p>The exception handler for TRAP1 (offset = 0x50) is implemented by the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>120 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In SC3 / SC4 systems </p>
<p><b>&gt; </b></p>
<p>The exception handler for TRAP0 (offset = 0x40) is implemented by the OS. </p>
<p><b>&gt; </b></p>
<p>The exception handler for MIP/MDP (offset = 0x90) is implemented by the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The MPU in RH850 has a granularity of 4Byte. Each data section must have 4Byte </p>
<p>address alignement. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity the start address of any configured MPU region must be a </p>
<p>multiple of 4Byte. </p>
<p>The end address of any configured MPU region must be the address of the last valid </p>
<p>Byte of the section. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region from start </p>
<p>address and end address. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 4 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Tiny data area (TDA) and zero data area (ZDA) addressing are not supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For multicore-core derivatives, the stack used before StartOS should be linked into the </p>
<p>respective core local RAM areas. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>121 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.2.10 </b></p>
<p><b>PSW Register Handling </b></p>
<p><b>PSW.EBV </b></p>
<p>MICROSAR OS sets PSW.EBV to 1 upon Os_Init(). </p>
<p><b>PSW.UM </b></p>
<p>MICROSAR OS sets PSW.UM to 0 for trusted software parts and to 1 for non-</p>
<p>trusted software parts. </p>
<p><b>PSW.NP </b></p>
<p>MICROSAR OS sets PSW.NP to 1 to disable FE level interrupts and to 0 to </p>
<p>enable FE level interrupts. </p>
<p><b>PSW.ID </b></p>
<p>MICROSAR OS sets PSW.ID to 1 to disable EI level interrupts and to 0 to </p>
<p>enable EI level interrupts. </p>
<p><b>PSW.CU0 </b></p>
<p>MICROSAR OS sets PSW.CU0  to 1 in order to support FPU. </p>
<p> </p>
<p><b>4.2.2.11 </b></p>
<p><b>Instructions </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>&gt; The instructions &quot;trap 16&quot; … “trap 31” used for TRAP1 are exclusively used by the </p>
<p>OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>In SC3 / SC4 systems </p>
<p><b>&gt; </b></p>
<p>The instructions &quot;trap 0&quot; … “trap 15” used for TRAP0 are exclusively used by the </p>
<p>OS. </p>
<p><b>&gt; </b></p>
<p>The instruction &quot;syscall&quot; is not supported and therefore shall not be used. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.2.12 </b></p>
<p><b>Exception and Interrupt Cause Address </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p>The exception and interrupt cause address from EIPC and FEPC is stored in register </p>
<p>CTPC when unhandled EIINT, unhandled SYSCALL, MIP/MDP exception (SC3/SC4) </p>
<p>or unhandled core exception is reported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>122 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.3 </b></p>
<p><b>Power PC Family </b></p>
<p> </p>
<p><b>4.2.3.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>R2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>R13-R31 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PID </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>LR </p>
<p><b></b></p>
<p><b> </b></p>
<p>MSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_CPR[0|1|2] </p>
<p><b></b></p>
<p><b> </b></p>
<p>SPEFSCR</p>
<p>5</p>
<p> </p>
<p> </p>
<p><b>4.2.3.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>SPRG0, SPRG1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>SRR0, SRR1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IVPR </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIR </p>
<p><b></b></p>
<p><b> </b></p>
<p>SIR</p>
<p>5</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>IVOR0 – 35</p>
<p>5</p>
<p> </p>
<p> </p>
<p><b>4.2.3.3 </b></p>
<p><b>Interrupt Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_BCR</p>
<p>5</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_MCR</p>
<p>5</p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_CPRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_IACKRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_EOIRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_SSCIRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_PSRn </p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>5</p>
<p> Only used if the register is available on hardware. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>123 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.3.4 </b></p>
<p><b>PIT Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_MCR </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_LDVALn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_CVALn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_TCTRLn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_TFLGn </p>
<p> </p>
<p><b>4.2.3.5 </b></p>
<p><b>STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CCRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CIRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CMPn </p>
<p> </p>
<p><b>4.2.3.6 </b></p>
<p><b>MPU Registers </b></p>
<p><b>Core MPU </b></p>
<p><b>System MPU </b></p>
<p><b>&gt; </b></p>
<p>CMPU_MAS0 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS1 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS2 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS3 </p>
<p><b>&gt; </b></p>
<p>CMPU_MPU0CSR0 </p>
<p><b>&gt; </b></p>
<p>SMPU_CESR0 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRDn  </p>
<p>(number of used region words depends on </p>
<p>system MPU hardware) </p>
<p> </p>
<p><b>4.2.3.7 </b></p>
<p><b>SEMA4 Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>SEMA42_GATE0 </p>
<p> </p>
<p><b>4.2.3.8 </b></p>
<p><b>MC_ME Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>MC_ME_MCTL </p>
<p><b></b></p>
<p><b> </b></p>
<p>MC_MC_CCTLn </p>
<p><b></b></p>
<p><b> </b></p>
<p>MC_ME_CADDRn </p>
<p> </p>
<p><b>4.2.3.9 </b></p>
<p><b>SSCM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>SSCM_DPMBOOT </p>
<p><b></b></p>
<p><b> </b></p>
<p>SSCM_DPMKEY </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>124 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.3.10 </b></p>
<p><b>Power PC Special Characteristics </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Machine check is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Data Storage is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Instruction Storage is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for External Input is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Program is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for System call is implemented by the OS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register SPRG0 is exclusively used by the OS to hold the identifier of the current </p>
<p>thread. </p>
<p>The register SPRG1 is exclusively used by the OS to hold the address of the </p>
<p>INTC_CPR register. </p>
<p>The register SEMA42_GATE0 is exclusively used by the OS to provide mutual </p>
<p>exclusion in multicore systems for spinlock handling. </p>
<p>Thus these registers must not be used otherwise. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity all start addresses of configured MPU regions for the </p>
<p>SystemMPU must be a multiple of 32. The configured end addresses must be a </p>
<p>multiple of 32 minus one byte. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address and end address itself is granted </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For the CoreMPU, no restrictions on start address and end address apply. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address and end address itself is granted </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>125 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 8 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR OS assumes that Power PC multi core derivatives are booted as a master </p>
<p>/ slave system (as described in 2.15.4). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For System MPU regions only the format FMT1 is supported to setting up the </p>
<p>SMPUx_RGDn_WORD2. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>MICROSAR OS does not change the target chip mode of register MC_ME_MCTL. </p>
<p>Furthermore, user software may change this register. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the user software changes the target chip mode of register MC_ME_MCTL, it must </p>
<p>ensure that all running cores are allowed to run in the new target chip mode by setting </p>
<p>appropriate flags in MC_ME_CCTLn. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Only 32-Bit GPR registers are saved during context switch. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>126 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.3.11 </b></p>
<p><b>Derivative Special Characteristics </b></p>
<p>The following table shows special characeristics of the MICROSAR OS for different Power </p>
<p>PC derivative groups. </p>
<p><b>MPC564xL </b></p>
<p><b>&gt; </b></p>
<p>Only LS-Mode supported </p>
<p><b>MPC567xK </b></p>
<p><b>&gt; </b></p>
<p>Only LS-Mode supported </p>
<p><b>MPC577xC </b></p>
<p><b>&gt; </b></p>
<p>Stacks for physical core 0 need to be mapped to PRAMC_0 </p>
<p><b>&gt; </b></p>
<p>Stacks for physical core 0 need to be mapped to PRAMC_1 </p>
<p> </p>
<p><b>4.2.3.12 </b></p>
<p><b>MSR Handling </b></p>
<p><b>MSR.SPV bit handling </b></p>
<p>MICROSAR OS sets the SPV bit to 1 upon start of a thread. </p>
<p><b>MSR.EE bit handling </b></p>
<p>MICROSAR OS sets the external interrupt enable bit to 0 for non-</p>
<p>interruptible threads without TimingProtection supervision, and to 1 for </p>
<p>interruptible or TimingProtection supervised threads. </p>
<p><b>MSR.PR bit handling </b></p>
<p>MICROSAR OS sets the problem state bit to 0 for trusted software </p>
<p>parts and to 1 for non-trusted software parts. </p>
<p><b>MSR.ME bit handling </b></p>
<p>MICROSAR OS sets the machine check enable bit to 1. </p>
<p>Asynchronous Machine Check interrupts are enabled. </p>
<p><b>MSR remaining bits </b></p>
<p><b>handling </b></p>
<p>MICROSAR OS sets all other MSR bits to 0 upon start of a thread. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>127 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4 </b></p>
<p><b>ARM Family </b></p>
<p><b>4.2.4.1 </b></p>
<p><b>Cortex-R derivatives </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Cortex-R Limitations  </b></p>
<p>MICROSAR OS does not support the configuration of ISRs with parameter </p>
<p>OsIsrEnableNesting = TRUE in combination with timing protection (SC2 or SC4). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.4.1.1 </b></p>
<p><b>Generic Cortex-R </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>128 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.1.2 </b></p>
<p><b>Traveo Family </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>IRQPLM </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p><b>Bootrom Registers </b></p>
<p><b>&gt; </b></p>
<p>UNLOCK </p>
<p><b>&gt; </b></p>
<p>CNFG </p>
<p><b>&gt; </b></p>
<p>UNDEFINACT </p>
<p><b>&gt; </b></p>
<p>SVCINACT </p>
<p><b>&gt; </b></p>
<p>PABORTINACT </p>
<p><b>&gt; </b></p>
<p>DABORTINACT </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>NMIST </p>
<p><b>&gt; </b></p>
<p>IRQST </p>
<p><b>&gt; </b></p>
<p>NMIVAn </p>
<p><b>&gt; </b></p>
<p>IRQVAn </p>
<p><b>&gt; </b></p>
<p>NMIPLn </p>
<p><b>&gt; </b></p>
<p>IRQPLn </p>
<p><b>&gt; </b></p>
<p>NMIS </p>
<p><b>&gt; </b></p>
<p>NMIR </p>
<p><b>&gt; </b></p>
<p>IRQSn </p>
<p><b>&gt; </b></p>
<p>IRQRn </p>
<p><b>&gt; </b></p>
<p>IRQCESn </p>
<p><b>&gt; </b></p>
<p>IRQCERn </p>
<p><b>&gt; </b></p>
<p>NMIHC </p>
<p><b>&gt; </b></p>
<p>IRQHC </p>
<p><b>&gt; </b></p>
<p>UNLOCK </p>
<p><b>FRT Registers </b></p>
<p><b>&gt; </b></p>
<p>TCDT </p>
<p><b>&gt; </b></p>
<p>TCCS </p>
<p><b>&gt; </b></p>
<p>TCCSC </p>
<p><b>&gt; </b></p>
<p>TCCSS </p>
<p><b>Output Compare Registers </b></p>
<p><b>&gt; </b></p>
<p>OCCP0, OCCP1 </p>
<p><b>&gt; </b></p>
<p>OCS </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>129 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>OCSC </p>
<p><b>&gt; </b></p>
<p>OCSS </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>130 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.1.3 </b></p>
<p><b>Ultrascale Family </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>ICCICR </p>
<p><b>&gt; </b></p>
<p>ICCBPR </p>
<p><b>&gt; </b></p>
<p>ICCIAR </p>
<p><b>&gt; </b></p>
<p>ICCEOIR </p>
<p><b>&gt; </b></p>
<p>ICDDCR </p>
<p><b>&gt; </b></p>
<p>ICDISRn </p>
<p><b>&gt; </b></p>
<p>ICDISERn </p>
<p><b>&gt; </b></p>
<p>ICDICERn </p>
<p><b>&gt; </b></p>
<p>ICDISPRn </p>
<p><b>&gt; </b></p>
<p>ICDICPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPTRn </p>
<p><b>&gt; </b></p>
<p>ICDSGIR </p>
<p><b>TTC Registers </b></p>
<p><b>&gt; </b></p>
<p>Clock_Control </p>
<p><b>&gt; </b></p>
<p>Counter_Control </p>
<p><b>&gt; </b></p>
<p>Counter_Value </p>
<p><b>&gt; </b></p>
<p>Interval_Counter </p>
<p><b>&gt; </b></p>
<p>Match_1_Counter </p>
<p><b>&gt; </b></p>
<p>Match_2_Counter </p>
<p><b>&gt; </b></p>
<p>Match_3_Counter </p>
<p><b>&gt; </b></p>
<p>Interrupt_Register </p>
<p><b>&gt; </b></p>
<p>Interrupt_Enable </p>
<p><b>&gt; </b></p>
<p>Event_Control_Timer </p>
<p><b>&gt; </b></p>
<p>Event_Register </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>131 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.1.4 </b></p>
<p><b>TI AR 16xx </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>FIRQPR </p>
<p><b>&gt; </b></p>
<p>CHANNCTRL </p>
<p><b>&gt; </b></p>
<p>REQENASET </p>
<p><b>&gt; </b></p>
<p>REQENACLR </p>
<p><b>&gt; </b></p>
<p>INTREQ </p>
<p><b>RTI Registers </b></p>
<p><b>&gt; </b></p>
<p>Global Control </p>
<p><b>&gt; </b></p>
<p>Timebase Control </p>
<p><b>&gt; </b></p>
<p>Capture Control  </p>
<p><b>&gt; </b></p>
<p>Compare Control </p>
<p><b>&gt; </b></p>
<p>Counter 0/1 </p>
<p><b>&gt; </b></p>
<p>Up Counter 0/1 </p>
<p><b>&gt; </b></p>
<p>Compare Up Counter 0/1 </p>
<p><b>&gt; </b></p>
<p>Capture Free Running Counter 0/1 </p>
<p><b>&gt; </b></p>
<p>Capture Up Counter 0/1 </p>
<p><b>&gt; </b></p>
<p>Compare 0/1/2/3 </p>
<p><b>&gt; </b></p>
<p>Update Compare 0/1/2/3 </p>
<p><b>&gt; </b></p>
<p>Timebase Low Compare </p>
<p><b>&gt; </b></p>
<p>Timebase High Compare </p>
<p><b>&gt; </b></p>
<p>Set Interrupt Enable </p>
<p><b>&gt; </b></p>
<p>Clear Interrupt Enable </p>
<p><b>&gt; </b></p>
<p>Interrupt Flag </p>
<p><b>Software Interrupt </b></p>
<p><b>Registers </b></p>
<p><b>&gt; </b></p>
<p>MSS_RCM_SWIRQA </p>
<p><b>&gt; </b></p>
<p>MSS_RCM_SWIRQB </p>
<p><b>&gt; </b></p>
<p>MSS_RCM_SWIRQC </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>132 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.1.5 </b></p>
<p><b>Renesas R-Car H3 (Cortex-R7) </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p><b>Core GIC Registers </b></p>
<p><b>&gt; </b></p>
<p>ICCICR </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>&gt; </b></p>
<p>ICCBPR </p>
<p><b>&gt; </b></p>
<p>ICCIAR </p>
<p><b>&gt; </b></p>
<p>ICCEOIR </p>
<p><b>&gt; </b></p>
<p>ICCRPR </p>
<p><b>&gt; </b></p>
<p>ICCHPIR </p>
<p><b>&gt; </b></p>
<p>ICCIIDR </p>
<p><b>&gt; </b></p>
<p>ICDDCR </p>
<p><b>&gt; </b></p>
<p>ICDICTR </p>
<p><b>&gt; </b></p>
<p>ICDIIDR </p>
<p><b>&gt; </b></p>
<p>ICDISERn </p>
<p><b>&gt; </b></p>
<p>ICDICERn </p>
<p><b>&gt; </b></p>
<p>ICDISPRn </p>
<p><b>&gt; </b></p>
<p>ICDICPRn </p>
<p><b>&gt; </b></p>
<p>ICDABRn </p>
<p><b>&gt; </b></p>
<p>ICDIPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPTRn </p>
<p><b>&gt; </b></p>
<p>ICDICFRn </p>
<p><b>&gt; </b></p>
<p>PPISR </p>
<p><b>&gt; </b></p>
<p>SPISRn </p>
<p><b>&gt; </b></p>
<p>ICDSGIR </p>
<p><b>&gt; </b></p>
<p>PIDR0 ... PIDR4 </p>
<p><b>&gt; </b></p>
<p>CIDR0 ... CIDR3 </p>
<p><b>INTC-RT Registers </b></p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICC_CTLR </p>
<p><b>&gt; </b></p>
<p>GICC_PMR </p>
<p><b>&gt; </b></p>
<p>GICC_BPR </p>
<p><b>&gt; </b></p>
<p>GICC_IAR </p>
<p><b>&gt; </b></p>
<p>GICC_EOIR </p>
<p><b>&gt; </b></p>
<p>GICC_RPR </p>
<p><b>&gt; </b></p>
<p>GICC_HPPIR </p>
<p><b>&gt; </b></p>
<p>GICC_ABPR </p>
<p><b>&gt; </b></p>
<p>GICC_AIAR </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>133 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>GICC_AEOIR </p>
<p><b>&gt; </b></p>
<p>GICC_AHPPIR </p>
<p><b>&gt; </b></p>
<p>GICC_APR0 </p>
<p><b>&gt; </b></p>
<p>GICC_NSAPR0 </p>
<p><b>&gt; </b></p>
<p>GICC_IIDR </p>
<p><b>&gt; </b></p>
<p>GICC_DIR</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_CTLR</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_TYPER</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_IIDR</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_IGROUPRn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ISENABLERn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ICENABLERn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ISPENDRn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ICPENDRn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ISACTIVERn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_ICACTIVERn</p>
<p> </p>
<p><b>&gt; </b></p>
<p>GICD_IPRIORITYRn </p>
<p><b>&gt; </b></p>
<p>GICD_ITARGETSRn </p>
<p><b>&gt; </b></p>
<p>GICD_ICFGRn </p>
<p><b>&gt; </b></p>
<p>GICD_PPISR </p>
<p><b>&gt; </b></p>
<p>GICD_SPISRn </p>
<p><b>&gt; </b></p>
<p>GICD_SGIR </p>
<p><b>&gt; </b></p>
<p>GICD_CPENDSGIRn </p>
<p><b>&gt; </b></p>
<p>GICD_SPENDSGIRn </p>
<p><b>&gt; </b></p>
<p>GICD_PIDR0 ... GICD_PIDR7 </p>
<p><b>&gt; </b></p>
<p>GICD_CIDR0 ... GICD_CIDR3</p>
<p> </p>
<p><b>Timer Unit (TMU) </b></p>
<p><b>Registers </b></p>
<p><b>&gt; </b></p>
<p>TSTRm (m = 0 ... 4) </p>
<p><b>&gt; </b></p>
<p>TCORn (n = 0 ... 14) </p>
<p><b>&gt; </b></p>
<p>TCNTn (n = 0 ... 14) </p>
<p><b>&gt; </b></p>
<p>TCRn (n = 0 ... 14)</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>134 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.2 </b></p>
<p><b>Cortex-A derivatives </b></p>
<p><b> </b></p>
<p>Generic Cortex-A </p>
<p>iMX6 Family </p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>VBAR </p>
<p><b>INTC Registers </b></p>
<p>---</p>
<p> </p>
<p><b>&gt; </b></p>
<p>ICCICR </p>
<p><b>&gt; </b></p>
<p>ICCBPR </p>
<p><b>&gt; </b></p>
<p>ICCIAR </p>
<p><b>&gt; </b></p>
<p>ICCEOIR </p>
<p><b>&gt; </b></p>
<p>ICDDCR </p>
<p><b>&gt; </b></p>
<p>ICDISRn </p>
<p><b>&gt; </b></p>
<p>ICDISERn </p>
<p><b>&gt; </b></p>
<p>ICDICERn </p>
<p><b>&gt; </b></p>
<p>ICDISPRn </p>
<p><b>&gt; </b></p>
<p>ICDICPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPRn </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>&gt; </b></p>
<p>ICDIPTRn </p>
<p><b>&gt; </b></p>
<p>ICDSGIR </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>135 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.3 </b></p>
<p><b>Cortex-M derivatives </b></p>
<p> </p>
<p><b>4.2.4.3.1 </b></p>
<p><b>Generic Cortex-M </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>CONTROL  </p>
<p><b>&gt; </b></p>
<p>BASEPRI </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>MPIDR </p>
<p><b>&gt; </b></p>
<p>PRIMASK </p>
<p><b>&gt; </b></p>
<p>FAULTMASK </p>
<p><b>&gt; </b></p>
<p>CCR </p>
<p><b>&gt; </b></p>
<p>SHPR1 </p>
<p><b>&gt; </b></p>
<p>SHPR2 </p>
<p><b>&gt; </b></p>
<p>SHPR3 </p>
<p><b>&gt; </b></p>
<p>SHCSR </p>
<p><b>&gt; </b></p>
<p>SYST_CSR </p>
<p><b>&gt; </b></p>
<p>SYST_RVR </p>
<p><b>&gt; </b></p>
<p>SYST_CVR </p>
<p><b>&gt; </b></p>
<p>SYST_CALIB </p>
<p><b>Core MPU </b></p>
<p><b>Registers </b></p>
<p>(Optional) </p>
<p><b>&gt; </b></p>
<p>MPU_TYPE </p>
<p><b>&gt; </b></p>
<p>MPU_CTRL </p>
<p><b>&gt; </b></p>
<p>MPU_RNR </p>
<p><b>&gt; </b></p>
<p>MPU_RBAR </p>
<p><b>&gt; </b></p>
<p>MPU_RASR </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>SHPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ISER </p>
<p><b>&gt; </b></p>
<p>NVIC_ICER </p>
<p><b>&gt; </b></p>
<p>NVIC_ISPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ICPR </p>
<p><b>&gt; </b></p>
<p>NVIC_IABR </p>
<p><b>&gt; </b></p>
<p>NVIC_IPR </p>
<p><b>&gt; </b></p>
<p>ICSR </p>
<p><b>&gt; </b></p>
<p>VTOR </p>
<p><b>&gt; </b></p>
<p>STIR </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>136 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.3.2 </b></p>
<p><b>ATSAMv7x Family </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>CONTROL  </p>
<p><b>&gt; </b></p>
<p>BASEPRI </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>MPIDR </p>
<p><b>&gt; </b></p>
<p>PRIMASK </p>
<p><b>&gt; </b></p>
<p>FAULTMASK </p>
<p><b>&gt; </b></p>
<p>CCR </p>
<p><b>&gt; </b></p>
<p>SHPR1 </p>
<p><b>&gt; </b></p>
<p>SHPR2 </p>
<p><b>&gt; </b></p>
<p>SHPR3 </p>
<p><b>&gt; </b></p>
<p>SHCSR </p>
<p><b>&gt; </b></p>
<p>SYST_CSR </p>
<p><b>&gt; </b></p>
<p>SYST_RVR </p>
<p><b>&gt; </b></p>
<p>SYST_CVR </p>
<p><b>&gt; </b></p>
<p>SYST_CALIB </p>
<p><b>Core MPU </b></p>
<p><b>Registers </b></p>
<p><b>&gt; </b></p>
<p>MPU_TYPE </p>
<p><b>&gt; </b></p>
<p>MPU_CTRL </p>
<p><b>&gt; </b></p>
<p>MPU_RNR </p>
<p><b>&gt; </b></p>
<p>MPU_RBAR </p>
<p><b>&gt; </b></p>
<p>MPU_RASR </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>SHPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ISER </p>
<p><b>&gt; </b></p>
<p>NVIC_ICER </p>
<p><b>&gt; </b></p>
<p>NVIC_ISPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ICPR </p>
<p><b>&gt; </b></p>
<p>NVIC_IABR </p>
<p><b>&gt; </b></p>
<p>NVIC_IPR </p>
<p><b>&gt; </b></p>
<p>ICSR </p>
<p><b>&gt; </b></p>
<p>VTOR </p>
<p><b>&gt; </b></p>
<p>STIR </p>
<p><b>RTT Registers </b></p>
<p><b>&gt; </b></p>
<p>RTT_MR </p>
<p><b>&gt; </b></p>
<p>RTT_SR </p>
<p><b>&gt; </b></p>
<p>RTT_AR </p>
<p><b>&gt; </b></p>
<p>RTT_VR </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>137 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.3.3 </b></p>
<p><b>S32K14x Family </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>CONTROL  </p>
<p><b>&gt; </b></p>
<p>BASEPRI </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>MPIDR </p>
<p><b>&gt; </b></p>
<p>PRIMASK </p>
<p><b>&gt; </b></p>
<p>FAULTMASK </p>
<p><b>&gt; </b></p>
<p>CCR </p>
<p><b>&gt; </b></p>
<p>SHPR1 </p>
<p><b>&gt; </b></p>
<p>SHPR2 </p>
<p><b>&gt; </b></p>
<p>SHPR3 </p>
<p><b>&gt; </b></p>
<p>SHCSR </p>
<p><b>&gt; </b></p>
<p>SYST_CSR </p>
<p><b>&gt; </b></p>
<p>SYST_RVR </p>
<p><b>&gt; </b></p>
<p>SYST_CVR </p>
<p><b>&gt; </b></p>
<p>SYST_CALIB </p>
<p><b>System MPU </b></p>
<p><b>Registers </b></p>
<p><b>&gt; </b></p>
<p>SMPU_CESR </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WORD0 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WORD1 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WORD2 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WORD3 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDAAC0 </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>SHPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ISER </p>
<p><b>&gt; </b></p>
<p>NVIC_ICER </p>
<p><b>&gt; </b></p>
<p>NVIC_ISPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ICPR </p>
<p><b>&gt; </b></p>
<p>NVIC_IABR </p>
<p><b>&gt; </b></p>
<p>NVIC_IPR </p>
<p><b>&gt; </b></p>
<p>ICSR </p>
<p><b>&gt; </b></p>
<p>VTOR </p>
<p><b>&gt; </b></p>
<p>STIR </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>138 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.3.4 </b></p>
<p><b>TDA2x </b></p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>&gt; </b></p>
<p>CONTROL  </p>
<p><b>&gt; </b></p>
<p>BASEPRI </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>MPIDR </p>
<p><b>&gt; </b></p>
<p>PRIMASK </p>
<p><b>&gt; </b></p>
<p>FAULTMASK </p>
<p><b>&gt; </b></p>
<p>CCR </p>
<p><b>&gt; </b></p>
<p>SHPR1 </p>
<p><b>&gt; </b></p>
<p>SHPR2 </p>
<p><b>&gt; </b></p>
<p>SHPR3 </p>
<p><b>&gt; </b></p>
<p>SHCSR </p>
<p><b>&gt; </b></p>
<p>SYST_CSR </p>
<p><b>&gt; </b></p>
<p>SYST_RVR </p>
<p><b>&gt; </b></p>
<p>SYST_CVR </p>
<p><b>&gt; </b></p>
<p>SYST_CALIB </p>
<p><b>INTC Registers </b></p>
<p><b>&gt; </b></p>
<p>SHPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ISER </p>
<p><b>&gt; </b></p>
<p>NVIC_ICER </p>
<p><b>&gt; </b></p>
<p>NVIC_ISPR </p>
<p><b>&gt; </b></p>
<p>NVIC_ICPR </p>
<p><b>&gt; </b></p>
<p>NVIC_IABR </p>
<p><b>&gt; </b></p>
<p>NVIC_IPR </p>
<p><b>&gt; </b></p>
<p>ICSR </p>
<p><b>&gt; </b></p>
<p>VTOR </p>
<p><b>&gt; </b></p>
<p>STIR </p>
<p><b>IPU Registers </b></p>
<p><b>&gt; </b></p>
<p>CORTEXM4_CTRL_REG </p>
<p><b>&gt; </b></p>
<p>CORTEXM4_RW_PID1 </p>
<p><b>Spinlock Registers </b></p>
<p><b>&gt; </b></p>
<p>SPINLOCK_SYSCONFIG </p>
<p><b>&gt; </b></p>
<p>SPINLOCK_SYSTATUS </p>
<p><b>&gt; </b></p>
<p>SPINLOCK_LOCK_REG_0 </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>139 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.4 </b></p>
<p><b>ARM Special Characteristics </b></p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Supervisor Call is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Undefined Instruction is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Prefetch Abort is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Data Abort is implemented by the OS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU hardware restriction the sizes of MPU regions and stack sizes must be </p>
<p>configured with power of 2 values. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The MPU configuration must not contain the regions with the number higher than the </p>
<p>number of available MPU regions minus 2. One region with the highest number is </p>
<p>always reserved for the stack protection.  </p>
<p>E.g. if 16 regions are available, only the region numbers from 0 to 14 (inclusive) are </p>
<p>allowed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with UltraScale derivatives </b></p>
<p>The exception vector table of each core must be located in tightly coupled RAM </p>
<p>memory at address 0x0. </p>
<p>Either the debugger or the startup code has to copy the exception vector table from </p>
<p>ROM section “OS_EXCVEC_CORE&lt;core ID&gt;_CODE” to address 0x0. </p>
<p>During OS startup OS code assumes that the exception vector table has already been </p>
<p>copied. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with S32K derivatives </b></p>
<p>Region 0 of the System MPU is reserved for debugging functionality and could not be </p>
<p>written by the core. This region is not available for user configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>140 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with Cortex-M derivatives exception vector table address </b></p>
<p>To avoid memory violations directly after boot phase, the exception vector table has to </p>
<p>be linked correctly (derivative specific) by the user linker script. </p>
<p>e.g. ATSAMv7 Derivative expects that section OS_INTVEC_CORE&lt;core ID&gt;_CODE is </p>
<p>linked to address 0x00400000 (first available internal flash address). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Limitations in TI derivatives with VIM interrupt controller </b></p>
<p>MICROSAR OS has limited interrupt priority support because VIM interrupt controllers </p>
<p>do not provide interrupt priority levels: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Category 1 ISRs can interrupt category 2 ISRs, but ISRs of the same </p>
<p>category cannot interrupt each other. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Interrupt resources disable all category 2 ISRs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with GCC compiler </b></p>
<p>If the feature “Stack Usage Measurement” is activated and one of the OS stacks </p>
<p>(managed by the OS) is applied before calling Os_Init, then the optimization option </p>
<p>tree-loop-distribute-patterns needs to be disabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for Cortex-M derivatives with GCC compiler </b></p>
<p>The interrupt vector tables are in the sections with the name </p>
<p>“&lt;Core_Name&gt;_VectorTable_Section”. These sections need to be 128 bytes aligned. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with TDA2x derivatives </b></p>
<p>MICROSAR OS expects that register CORTEXM4_RW_PID1 is initialized with the </p>
<p>physical core id, before starting.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>141 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3 </b></p>
<p><b>Memory Mapping Concept </b></p>
<p>MICROSAR OS uses the AUTOSAR MemMap mechanism to locate its own variables but </p>
<p>also application variables. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To use the OS memory mapping concept within the AUTOSAR MemMap mechanism </p>
<p>the generated OS file “Os_MemMap.h” has to be included into “MemMap.h”. </p>
<p>It should be included after the inclusion of the MemMap headers of all other basic </p>
<p>software components. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.1 </b></p>
<p><b>Provided MemMap Section Specifiers </b></p>
<p>MICROSAR  OS  uses  and  specifies  section  specifiers  as  described  in  the  AUTOSAR </p>
<p>specification of memory mapping. All section specifiers have one of the following forms: </p>
<p>OS_START_SEC_&lt;SectionType&gt;[_&lt;InitPolicy&gt;][_&lt;Alignment&gt;] </p>
<p>OS_STOP_SEC_&lt;SectionType&gt;[_&lt;InitPolicy&gt;][_&lt;Alignment&gt;] </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Due to clarity and understanding this chapter does only refer to section specifiers that </p>
<p>shall be handled by the application. </p>
<p>The OS internally used section specifiers are not listed here. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p>&lt;Callout&gt;_CODE </p>
<p>- </p>
<p>- </p>
<p>NONAUTOSAR_CORE&lt;Core Id&gt;_CONST </p>
<p>- </p>
<p>UNSPECIFIED </p>
<p>NONAUTOSAR_CORE&lt;Core Id&gt;_VAR </p>
<p>NOINIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>- </p>
<p>NOINIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>142 </p>
<p>based on template version 6.0.1 </p>
<p>ZERO_INIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p>&lt;Task/IsrName&gt;_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p>GLOBALSHARED_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>143 </p>
<p>based on template version 6.0.1 </p>
<p>GLOBALSHARED_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_VAR_NOCACHE </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>APPSHARED_0X&lt;application bitmask&gt;_VAR_NOCACHE </p>
<p>NOINIT </p>
<p>UNSPECIFIED </p>
<p>CORESHARED_0X&lt;core bitmask&gt;_VAR_NOCACHE </p>
<p>NOINIT </p>
<p>UNSPECIFIED </p>
<p>Table 4-1  </p>
<p>Provided MemMap Section Specifiers </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The &lt; application bitmask &gt;: Is a bitmask that specifes all OS applications which are </p>
<p>sharing the section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The &lt; core bitmask &gt;: Is a bitmask that specifes all cores which are sharing the </p>
<p>section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>144 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.1.1 </b></p>
<p><b>Usage of MemMap Macros </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_START_SEC_MyAppl_VAR_FAST_NOINIT_UNSPECIFIED </p>
<p>#include “MemMap.h” </p>
<p>uint16 MyApplicationVariable; </p>
<p>#define OS_STOP_SEC_MyAppl_VAR_FAST_NOINIT_UNSPECIFIED </p>
<p>#include “MemMap.h” </p>
<p> </p>
<p>This code snippet puts the user variable into an OS application section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.1.2 </b></p>
<p><b>Resulting sections </b></p>
<p>The usage of the above described macros will result in the following memory sections: </p>
<p><b>SectionType </b></p>
<p><b>Content / Description </b></p>
<p>OS_CODE </p>
<p>&gt; </p>
<p>OS Code </p>
<p>OS_INTVEC_CODE </p>
<p>&gt; </p>
<p>Interrupt vector table in case the system needs </p>
<p>one generic vector table for all cores </p>
<p>OS_INTVEC_CORE&lt;Core Id&gt;_CODE </p>
<p>&gt; </p>
<p>Interrupt vector table of one specific core </p>
<p>OS_EXCVEC_CORE&lt;Core Id&gt;_CODE </p>
<p>&gt; </p>
<p>Exception vector table of one core </p>
<p>Table 4-2  </p>
<p>MemMap Code Sections Descriptions </p>
<p>The  resulting  sections  for  callouts  are  generated  in  dependency  of  the  configuration </p>
<p>attribute “/MICROSAR/Os/OsOS/OsGenerateMemMap”. </p>
<p><b>OsGenerateMemMap </b></p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>USERCODE_AND_STAC</p>
<p>KS_GROUPED_PER_C</p>
<p>ORE </p>
<p>OS_USER_CORE&lt;Core Id&gt;_CODE </p>
<p>&gt; </p>
<p>Code of all Tasks, </p>
<p>ISRs and all other </p>
<p>user callouts which </p>
<p>are mapped on one </p>
<p>core. </p>
<p>COMPLETE </p>
<p>OS_&lt;Callout&gt;_CODE </p>
<p>&gt; </p>
<p>Code of one Task or </p>
<p>one ISR or one OS </p>
<p>Hook or other callouts. </p>
<p>Table 4-3  </p>
<p>MemMap Callout Code Sections Descriptions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The MPU may be set up to grant execution from the whole address space. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>145 </p>
<p>based on template version 6.0.1 </p>
<p><b>SectionType </b></p>
<p><b>Content / Description </b></p>
<p>OS_CONST </p>
<p>&gt; </p>
<p>OS constant data </p>
<p>OS_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data for fast memory </p>
<p>OS_INTVEC_CONST </p>
<p>&gt; </p>
<p>Interrupt vector table in case the system needs </p>
<p>one generic vector table for all cores </p>
<p>OS_CORE&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>OS constant data related to one specific core </p>
<p>OS_CORE&lt;Core Id&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data related to one specific for fast </p>
<p>memory </p>
<p>OS_INTVEC_CORE&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>Interrupt vector table of one specific core </p>
<p>OS_EXCVEC_CORE&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>Exception vector table of one core </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>OS constant data of a non-AUTOSAR core </p>
<p>OS_NONAUTOSAR_CORE&lt;Core </p>
<p>Id&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data of a non-AUTOSAR core with </p>
<p>shord addressing </p>
<p>OS_GLOBALSHARED_CONST </p>
<p>&gt; </p>
<p>Constants which shall be shared among core </p>
<p>boundaries </p>
<p>OS_GLOBALSHARED_CONST_FAST </p>
<p>&gt; </p>
<p>Constants which shall be shared among core </p>
<p>boundaries and which use short addressing </p>
<p>accesses (e.g. by base address pointer) </p>
<p>OS_&lt;Task/IsrName&gt;_CONST </p>
<p>&gt; </p>
<p>Thread specific constants </p>
<p>OS_&lt;Task/IsrName&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>Thread specific constants which use short </p>
<p>addressing accesses (e.g. by base address </p>
<p>pointer) </p>
<p>OS_&lt;ApplicationName&gt;_CONST </p>
<p>&gt; </p>
<p>Application specific constants </p>
<p>OS_&lt;ApplicationName&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>Application specific constants which use short </p>
<p>addressing accesses (e.g. by base address </p>
<p>pointer) </p>
<p>Table 4-4  </p>
<p>MemMap Const Sections Descriptions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The MPU may be set up to grant read access to const sections from all runtime </p>
<p>contexts (trusted and non-trusted) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_VAR_NOCACHE </p>
<p>OS global variables. All cores may </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>146 </p>
<p>based on template version 6.0.1 </p>
<p>OS_VAR_NOCACHE_NOINIT </p>
<p>have to access these variables. </p>
<p>OS_VAR_FAST_NOCACHE </p>
<p>OS_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR </p>
<p>OS core local variables. These </p>
<p>variables are never accessed from </p>
<p>foreign cores. </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS core local variables. These </p>
<p>variables may also be accessed </p>
<p>from foreign cores </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_APPSHARED_0X&lt;application </p>
<p>bitmask&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS optimized spinlock variables. </p>
<p>Only OS applications specified by </p>
<p>&lt;application bitmask&gt; have access </p>
<p>to them. </p>
<p>OS_CORESHARED_0X&lt;core </p>
<p>bitmask&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS Standard/Optimized spinlock </p>
<p>variables. </p>
<p>IOC data structures. </p>
<p>All cores wich are specified by &lt;core </p>
<p>bitmask&gt; have access to them. </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR </p>
<p>User core local variables of non-</p>
<p>AUTOSAR cores. Access to these </p>
<p>from foreign cores may be allowed. </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p> </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_GLOBALSHARED_VAR </p>
<p>User global shared variables. All </p>
<p>cores have access to them. </p>
<p>OS_GLOBALSHARED_VAR_FAST </p>
<p>OS_GLOBALSHARED_VAR_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_ZERO_INIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>147 </p>
<p>based on template version 6.0.1 </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR </p>
<p>User application private variables. </p>
<p>Only application members and </p>
<p>other trusted software may have </p>
<p>access to them. </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_ZERO_INIT </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>148 </p>
<p>based on template version 6.0.1 </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_&lt;Task/IsrName&gt;_VAR </p>
<p>User thread private </p>
<p>variables. Only the owning </p>
<p>thread and other trusted </p>
<p>software may have </p>
<p>access to them </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_ZERO_INIT </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS synchronization </p>
<p>barriers. Only the OS </p>
<p>must have access to </p>
<p>them. They will be </p>
<p>accessed from all cores </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORESTATUS_CORE&lt;Core Id&gt;_VAR_ NOCACHE_NOINIT </p>
<p>Startup state of each </p>
<p>physical core. Only the </p>
<p>OS must have access to </p>
<p>them. They will be written </p>
<p>by the master core and </p>
<p>the owning core itself, and </p>
<p>read from all cores. </p>
<p>OS_CORESTATUS_CORE&lt;Core </p>
<p>Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>Table 4-5  </p>
<p>MemMap Variable Sections Descriptions </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>149 </p>
<p>based on template version 6.0.1 </p>
<p>The  resulting  sections  for  stacks  are  generated  in  dependency  of  the  configuration </p>
<p>attribute “/MICROSAR/Os/OsOS/OsGenerateMemMap”. </p>
<p><b>OsGenerateMemMap </b></p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>USERCODE_AND_STAC</p>
<p>KS_GROUPED_PER_C</p>
<p>ORE </p>
<p>OS_STACK_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>Contains all stacks of </p>
<p>one core. </p>
<p>Only the current </p>
<p>running software has </p>
<p>access to the stack. </p>
<p>Software which runs on </p>
<p>a foreign core must not </p>
<p>have access to it. </p>
<p>COMPLETE </p>
<p>OS_STACK_&lt;StackName&gt;_VAR_NOINIT </p>
<p>Contains one OS </p>
<p>stack. </p>
<p>Only the current </p>
<p>running software has </p>
<p>access to the stack. </p>
<p>Software which runs on </p>
<p>a foreign core must not </p>
<p>have access to it. </p>
<p>Table 4-6  </p>
<p>MemMap Variable Stack Sections Descriptions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Notes </b></p>
<p>Sections which contain the keyword “FAST” are intended to be linked into fast RAM. </p>
<p>Sections which contain the keyword “NOCACHE” must never be linked into cacheable </p>
<p>memory. </p>
<p>Sections which contain the keyword “NOINIT” contain non-initialized variables. </p>
<p>Sections which contain the keyword “ZERO_INIT” contain zero initialized variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>150 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.1.3 </b></p>
<p><b>Access Rights to Variable Sections </b></p>
<p>The table shows the recommended access rights to the sections. </p>
<p><b>Section </b></p>
<p><b>Local Core </b></p>
<p><b>Trusted </b></p>
<p><b>Local core non </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>non trusted </b></p>
<p>OS_VAR_NOCACHE </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_VAR_NOCACHE_NOINIT </p>
<p>OS_VAR_FAST_NOCACHE </p>
<p>OS_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR </p>
<p>RW </p>
<p>RO </p>
<p>RO </p>
<p>RO </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>OS_GLOBALSHARED_VAR_FAST </p>
<p>OS_GLOBALSHARED_VAR_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_ZERO_INIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_ZERO_INIT </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>151 </p>
<p>based on template version 6.0.1 </p>
<p><b>Section </b></p>
<p><b>Local Core </b></p>
<p><b>Trusted </b></p>
<p><b>Local core non </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>non trusted </b></p>
<p>OS_&lt;ApplicationName&gt;_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RO </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_ZERO_INIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RO </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_ZERO_INIT </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORESTATUS_CORE&lt;Core Id&gt;_VAR_ NOCACHE_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_CORESTATUS_CORE&lt;Core </p>
<p>Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>Table 4-7  </p>
<p>Recommended Section Access Rights </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The access to the stack section is handled completely by MICROSAR OS </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The table is only valid for cores which have the same diagnostic level. Cores with a </p>
<p>lower diagnostic level must never interact with data from a core with a higher diagnostic </p>
<p>level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>152 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.1.4 </b></p>
<p><b>Access Rights to Shared Data Sections </b></p>
<p><b>Section </b></p>
<p><b>Access Rights </b></p>
<p>OS_APPSHARED_0X&lt;application </p>
<p>bitmask&gt;_VAR_NOCACHE_NOINIT </p>
<p>Only applications which are specified by the </p>
<p>&lt;application bitmask&gt; shall have read / write </p>
<p>access. </p>
<p>The bitmasks of applications may be looked up </p>
<p>in “Os_Types_Lcfg.h” &gt; &quot;ApplicationType&quot; </p>
<p>OS_CORESHARED_0X&lt;core </p>
<p>bitmask&gt;_VAR_NOCACHE_NOINIT </p>
<p>Only cores which are specified by the &lt;core </p>
<p>bitmask&gt; shall have read / write access. </p>
<p>The bitmasks of cores may be looked up in </p>
<p>“Os_Hal_Lcfg.h” &gt; &quot;CoreIdType&quot; </p>
<p>Table 4-8  </p>
<p>Recommended Spinlock Section Access Rights </p>
<p><b>4.3.2 </b></p>
<p><b>Link Sections </b></p>
<p>Once  variables  have  been  put  into  OS  sections  (by  usage  of  the  section  specifiers </p>
<p>described in 4.3.1.1) the sections would have to be linked. </p>
<p>Therefore  MICROSAR  OS  generates  linker  command  files  which  utilize  the  linkage  of </p>
<p>those sections. </p>
<p><b>Linker Command Filename </b></p>
<p>Content </p>
<p><b>Os_Link_&lt;Core&gt;.&lt;FileSuffix&gt; </b></p>
<p>All data and code sections which are bound to a </p>
<p>core </p>
<p><b>Os_Link.&lt;FileSuffix&gt; </b></p>
<p>All data and code sections which are global </p>
<p><b>Os_Link_&lt;Core&gt;_Stacks.&lt;FileSuffix&gt; </b></p>
<p>all stacks of a core </p>
<p>Table 4-9  </p>
<p>List of Generated Linker Command Files </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&lt;Core&gt; is the logical core ID </p>
<p>&lt;FileSuffix&gt; is the suffix for linker command files. It depends on the used compiler. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.2.1 </b></p>
<p><b>Pre-Process Linker Command Files </b></p>
<p>The generated linker command files uses C pre-processor statements. Some Linkers don’t </p>
<p>understand pre-processor statements. These Linkers require a pre-processing step on the </p>
<p>linker command files. </p>
<p><b>Windriver DiabData </b></p>
<p>The pre-processor should be used on command line to pre-process </p>
<p>the linker command files e.g.: </p>
<p>dcc.exe –P Os_Link.dld –o Os_Link_new.dld </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>153 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.3.2.2 </b></p>
<p><b>Simple Linker Defines </b></p>
<p>The following defines are used to select groups of OS sections from the linker command </p>
<p>files. </p>
<p><b>Select OS code </b></p>
<p>OS_LINK_CODE </p>
<p><b>Select an interrupt vector table </b></p>
<p>OS_LINK_INTVEC_CODE </p>
<p><b>Select an exception vector table </b></p>
<p>OS_LINK_EXCVEC_CODE </p>
<p><b>Select user callouts (Tasks, ISRs, Hooks) </b></p>
<p>OS_LINK_CALLOUT_CODE </p>
<p><b>Select constants related to an interrupt vector table </b></p>
<p>OS_LINK_INTVEC_CONST </p>
<p><b>Select constants related to an exception vector table </b></p>
<p>OS_LINK_EXCVEC_CONST </p>
<p><b>Select OS stacks </b></p>
<p>OS_LINK_KERNEL_STACKS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_INTVEC_CODE </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects the interrupt vector table from the included linker command file for linking. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.2.3 </b></p>
<p><b>Hierachical Linker Defines </b></p>
<p>The linker command files are intended to be included into a main linker command file. </p>
<p>Single sections or group of sections can be selected for linkage by usage of C-like defines. </p>
<p>This mechanism is similar to the MemMap mechanism of AUTOSAR. </p>
<p>The linker defines of MICROSAR OS uses a hierarchical syntax. </p>
<p>The more one walks down in the hierarchy the less sections are selected. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Once one have made the decision for a specific hierarchical level one will have to stick </p>
<p>to this level throughout the linker defines group. Otherwise there may be multiple </p>
<p>section definitions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.2.4 </b></p>
<p><b>Selecting OS constants </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p>OS_LINK_CONST_KERNEL </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>Table 4-10  </p>
<p>OS constants linker define group </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>154 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_KERNEL </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all OS constants. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_KERNEL_NEAR </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all near addressable OS constants only. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.2.5 </b></p>
<p><b>Selecting OS variables </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 1 </b></p>
<p><b>Optional </b></p>
<p><b>Hierarchy level </b></p>
<p><b>2 </b></p>
<p><b>Optional </b></p>
<p><b>Hierarchy level 3 </b></p>
<p>OS_LINK_VAR_KERNEL </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_CACHE </p>
<p>_NOCACHE </p>
<p>_INIT </p>
<p>_NOINIT </p>
<p>Table 4-11  </p>
<p>OS variables linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_KERNEL </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all OS variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_KERNEL_NEAR_CACHE </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all OS variables which are near addressable and cacheable. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>155 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.6 </b></p>
<p><b>Selecting special OS Variables </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p>OS_LINK_KERNEL_BARRIERS </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>OS_LINK_KERNEL_CORESTATUS </p>
<p>OS_LINK_KERNEL_TRACE </p>
<p>Table 4-12  </p>
<p>OS Barriers and Core status linker define group </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_KERNEL_BARRIERS </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all OS Barriers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_KERNEL_CORESTATUS </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all OS core state variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level </b></p>
<p><b>1 </b></p>
<p><b>Owner Bitmask </b></p>
<p><b>Optional </b></p>
<p><b>Hierarchy level </b></p>
<p><b>2 </b></p>
<p>OS_LINK_VAR </p>
<p>_APPSHARED </p>
<p>_0X&lt;application bitmask&gt; </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_CORESHARED </p>
<p>_0X&lt;core bitmask&gt; </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_APPSHARED </p>
<p>#include Os_Link.lsl </p>
<p> </p>
<p>Selects all OS application shared variables </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>156 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.7 </b></p>
<p><b>Selecting User Constant Sections </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p><b>Owner Name </b></p>
<p><b>Optional Hierarchy level 2 </b></p>
<p>OS_LINK_CONST </p>
<p>_APP </p>
<p>&lt;Owner Name&gt; </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_TASK </p>
<p>_ISR </p>
<p>_GLOBALSHARED </p>
<p>--- </p>
<p>Table 4-13  </p>
<p>User constants linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_APP_&lt;ApplicationName&gt; </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all constants which belong to the OS application &lt;ApplicationName&gt; </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_ISR_&lt;ISRName&gt;_FAR </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all constants which belong to the ISR &lt;ISRName&gt; which have far addressing </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>157 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.8 </b></p>
<p><b>Selecting User Variable Sections </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 1 </b></p>
<p><b>Owner Name </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 2 </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 3 </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 4 </b></p>
<p>OS_LINK_VAR </p>
<p>_APP </p>
<p>&lt;Owner Name&gt; </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_CACHE </p>
<p>_NOCACHE </p>
<p>_INIT </p>
<p>_NOINIT </p>
<p>_ZEROINIT </p>
<p>_TASK </p>
<p>_ISR </p>
<p>_GLOBALSHARED </p>
<p>--- </p>
<p>Table 4-14  </p>
<p>User variables linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_APP_&lt;ApplicationName&gt; </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all variables which belong to the OS application &lt;ApplicationName&gt; </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>158 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_APP_&lt;ApplicationName&gt;_FAR_CACHE_INIT </p>
<p>#include Os_Link_Core0.lsl </p>
<p> </p>
<p>Selects all variables which belong to the OS application &lt;ApplicationName&gt; which have far addressing, are cacheable and are </p>
<p>initialized </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>159 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.3 </b></p>
<p><b>Section Symbols </b></p>
<p>The linker command files described in 4.3.2 also generate section start and stop symbols </p>
<p>which may be used to configure start and end addresses of MPU region objects or access </p>
<p>check region objects. </p>
<p>These have the syntax </p>
<p>OS_&lt;SectionType&gt;_START </p>
<p>OS_&lt;SectionType&gt;_END </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>OS_MyAppl_VAR_FAST_START </p>
<p>OS_ MyAppl_VAR_FAST_END </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For ARM compiler, the OS generator will not generate section start and stop symbols. </p>
<p>However, the ARM linker will provide region-related symbols with special patterns (e.g.: </p>
<p>Image$$region_name$$Base or Load$$region_name$$Base), which can be used to </p>
<p>configure start and end addresses of MPU region objects or access check region </p>
<p>objects. Detailed information about the region-related symbols can be found in the user </p>
<p>guide of the ARM compiler. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.4 </b></p>
<p><b>Static Code Analysis </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>When running tools for static code analysis (e.g. MISRA, MSSV), the pre-processor </p>
<p>definition OS_STATIC_CODE_ANALYSIS has to be set during analysis. It switches off </p>
<p>compiler specific keywords and inline assembler parts. Typically code analysis tools </p>
<p>cannot deal with such code parts. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>160 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.5 </b></p>
<p><b>Configuration of X-Signals </b></p>
<p>This chapter describes how X-Signals are configured for cross core API calls. </p>
<p>1. </p>
<p>Add an “OsCoreXSignalChannel” to an “OsCore” object. This core will be the sender of </p>
<p>the X-Signal. </p>
<p>2. </p>
<p>Specify the queue size of the channel with the “OsCoreXSignalChannelSize” attribute. </p>
<p>3. </p>
<p>Add an X-Signal receiver ISR. It must be of category 2. </p>
<p>4. </p>
<p>Assign this ISR to be the X-Signal receiver </p>
<p>“OsCore/OsCoreXSignalChannelReceiverIsr”. </p>
<p>5. </p>
<p>Configure an appropriate interrupt priority for the receiver ISR (see the following </p>
<p>chapters for details on your used platform). The configured priority must follow the </p>
<p>rules listed in Table 3-3. </p>
<p>6. </p>
<p>Choose an appropriate interrupt source for the receiver ISR (see the following </p>
<p>chapters for details on your used platform). </p>
<p>7. </p>
<p>Add the &quot;OsIsrXSignalReceiver&quot; to the receiver ISR and select the provided APIs </p>
<p>(callable from the sender core) with the &quot;OsIsrXSignalReceiverProvidedApis&quot; attribute. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The DaVinci Configurator provides solving actions which support the correct </p>
<p>configuration of X-signals. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.5.1 </b></p>
<p><b>TriCore Aurix Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any interrupt source, which is not used by other modules, may </p>
<p>be used for the X-Signal ISR. </p>
<p>The offset of the SRC register of the used interrupt source has </p>
<p>to be specified for OsIsrInterruptSource. </p>
<p> </p>
<p><b>4.5.2 </b></p>
<p><b>RH850 Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a high </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Only interrupt sources of type INTIPIRn can be used. Available </p>
<p>sources INTIPIRn are listed in the hardware manual of used </p>
<p>derivative. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>161 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.5.3 </b></p>
<p><b>Power PC Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any Interrupt source of the available software interrupts may </p>
<p>be used. </p>
<p> </p>
<p><b>4.5.4 </b></p>
<p><b>ARM Family </b></p>
<p><b> </b></p>
<p>NVIC Interrupt Controller – TDA2x </p>
<p>GIC Interrupt Controller </p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a high logical priority </p>
<p><b>X-Signal ISR </b></p>
<p><b>Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority can be chosen </p>
<p>freely. </p>
<p><b>X-Signal ISR </b></p>
<p><b>Interrupt Source </b></p>
<p>Interrupt source 19 has to be used for </p>
<p>the X-Signal ISRs. </p>
<p>The interrupt sources 0..15 have to be </p>
<p>used for the X-Signal ISR. </p>
<p> </p>
<p><b>4.5.5 </b></p>
<p><b>VTT OS </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any interrupt source, which is not used by other modules, may </p>
<p>be used for the X-Signal ISR. </p>
<p> </p>
<p><b>4.6 </b></p>
<p><b>OS generated objects </b></p>
<p>In  dependency  of  its  configuration  MICROSAR  OS  may  add  other  OS  configuration </p>
<p>objects to it. </p>
<p><b>4.6.1 </b></p>
<p><b>System Application </b></p>
<p><b>Type </b></p>
<p>OsApplication </p>
<p><b>Name </b></p>
<p>SystemApplication_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added when the OsCore &lt;CoreName&gt; is configured to be an </p>
<p>AUTOSAR core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>A system application contains the OS objects </p>
<p><b>&gt; </b></p>
<p>IdleTask_&lt;CoreName&gt; </p>
<p><b>&gt; </b></p>
<p>TpCounter_&lt;CoreName&gt; </p>
<p><b>&gt; </b></p>
<p>XSignalIsr_&lt;CoreName&gt; </p>
<p><b>&gt; </b></p>
<p>CounterIsr_TpCounter_&lt;CoreName&gt; </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>162 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.6.2 </b></p>
<p><b>Idle Task </b></p>
<p><b>Type </b></p>
<p>OsTask </p>
<p><b>Name </b></p>
<p>IdleTask_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added when the OsCore &lt;CoreName&gt; is configured to be an </p>
<p>AUTOSAR core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Has the lowest priority of all tasks assigned to the same core. </p>
<p><b>&gt; </b></p>
<p>Is fully preemptive. </p>
<p><b>&gt; </b></p>
<p>Is implemented by the OS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Idle Task Priority </b></p>
<p>The generator has a special treatment for the idle task. The idle task has the virtual </p>
<p>priority 0xFFFFFFFF to differentiate it from regular tasks. It will be generated to have </p>
<p>the lowest priority, even if there are tasks configured with priority 0. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>User Code Execution  </b></p>
<p>The idle task is implemented by the OS to simplify scheduling and idle treatment. The </p>
<p>OS does not rely on execution of the idle task. Implement an additional task with </p>
<p>priority 0, if user code execution during idle time is needed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.6.3 </b></p>
<p><b>Timer ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>CounterIsr_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added if a hardware OsCounter is configured to have a driver </p>
<p>(attribute “OsCounterDriver”). </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is Implemented by the OS. </p>
<p><b>&gt; </b></p>
<p>Handles the system timer counter, alarms and scheduletables </p>
<p>which are assigned to the core. </p>
<p> </p>
<p><b>4.6.4 </b></p>
<p><b>System Timer Counter </b></p>
<p><b>Type </b></p>
<p>OsCounter </p>
<p><b>Name </b></p>
<p>SystemTimer </p>
<p><b>Condition </b></p>
<p>Is added optionally within the recommended configuration. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is used for OSEK backward compatibility </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>163 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.6.5 </b></p>
<p><b>Timing Protection Counter </b></p>
<p><b>Type </b></p>
<p>OsCounter </p>
<p><b>Name </b></p>
<p>TpCounter_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added when OsTask/IsrTimingProtection parameters are configured </p>
<p>on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Handles all times related to timing protection </p>
<p> </p>
<p><b>4.6.6 </b></p>
<p><b>Timing protection ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>CounterIsr_TpCounter_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added when OsTask/IsrTimingProtection parameters are configured </p>
<p>on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Interrupt service routine of the timing protection feature </p>
<p> </p>
<p><b>4.6.7 </b></p>
<p><b>Resource Scheduler </b></p>
<p><b>Type </b></p>
<p>OsResource </p>
<p><b>Name </b></p>
<p>RES_SCHEDULER_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>For each core the resource scheduler is added when </p>
<p>OsUseResScheduler is set to TRUE. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is automatically assigned to all tasks of core &lt;CoreName&gt; </p>
<p> </p>
<p><b>4.6.8 </b></p>
<p><b>X-Signal ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>XSignalIsr_&lt;CoreName&gt; </p>
<p><b>Condition </b></p>
<p>Is added when an X-Signal channel is configured on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Handles cross core requests. </p>
<p> </p>
<p><b>4.6.9 </b></p>
<p><b>IOC Spinlocks </b></p>
<p><b>Type </b></p>
<p>OsSpinlock </p>
<p><b>Name </b></p>
<p>IocSpinlock_&lt;IOC Name&gt; </p>
<p><b>Condition </b></p>
<p>Is added when an IOC is configured which requires cross core </p>
<p>communication. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Each IOC has its own spinlock to reduce core wait times </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>164 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.7 </b></p>
<p><b>VTT OS Specifics </b></p>
<p><b>4.7.1 </b></p>
<p><b>Configuration </b></p>
<p>As described in [6] all VTT configuration parameters are derived from the hardware target. </p>
<p>The only exceptions are the ISR objects for the VTT OS. </p>
<p></p>
<p>  ISRs </p>
<p>from </p>
<p>other </p>
<p>Vector </p>
<p>MICROSAR </p>
<p>BSW </p>
<p>modules </p>
<p>(e.g. </p>
<p>CAN) </p>
<p>are </p>
<p>inserted </p>
<p>automatically by the respective BSW module. </p>
<p></p>
<p>  Other user ISRs have to be added separately. </p>
<p></p>
<p>  Interrupt levels for all ISRs have to be configured manually. VTT OS knows interrupt </p>
<p>levels from 1 to 200 (where 1 is the lowest priority and 200 the highest). </p>
<p><b>4.7.2 </b></p>
<p><b>CANoe Interface </b></p>
<p>A  VTT  OS  is  simulated  within  the  CANoe  simulation  software.  There  are  a  set  of  API </p>
<p>functions which are capable to communicate with CANoe (e.g. sending a message on the </p>
<p>CAN bus). </p>
<p>These API functions are prefixed with “CANoeAPI_”. </p>
<p>The available set of API functions can be looked up in the delivered header “CANoeApi.h”. </p>
<p><b>4.7.2.1 </b></p>
<p><b>Idle Task behavior with VTT OS </b></p>
<p>Any </p>
<p>idle </p>
<p>task </p>
<p>which </p>
<p>runs </p>
<p>within </p>
<p>the </p>
<p>VTT </p>
<p>OS </p>
<p>must </p>
<p>call </p>
<p>the </p>
<p>function </p>
<p>“CANoeAPI_ConsumeTicks” (see description in CANoeApi.h). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the call of “CANoeAPI_ConsumeTicks” is missing within the idle task, the CANoe </p>
<p>windows application won’t respond any longer! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>There are two possible solutions which solves this problem: </p>
<p>1. </p>
<p>The OS generated idle task (see 4.6.2) calls this function by default. The application </p>
<p>has to ensure that this idle task is entered cyclically. </p>
<p>2. </p>
<p>It may be that the OS idle task is never executed, because there is a higher priority </p>
<p>application  idle  task.  This  application  idle  task  must  implement  a  cyclic  call  of </p>
<p>“CANoeAPI_ConsumeTicks” instead of the OS idle task. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>165 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.8 </b></p>
<p><b>POSIX OS Specifics </b></p>
<p><b>4.8.1 </b></p>
<p><b>Configuration </b></p>
<p>POSIX OS configuration parameters are not derived from the hardware target. </p>
<p>A virtual interrupt controller is implemented in order to simulate the hardware behaviour. </p>
<p>The maximum configurable values are: </p>
<p></p>
<p>  1000 Interrupt sources. </p>
<p></p>
<p>  100 Interrupt levels (ascending priority). </p>
<p><b>4.8.2 </b></p>
<p><b>Posix Interface </b></p>
<p>The set of used POSIX libraries are included in the file: Os_Hal_Compiler_Gcc_types.h. </p>
<p>The recommended POSIX standard version is at least IEEE Std 1003.1-2008.  </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>166 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.9 </b></p>
<p><b>User include files </b></p>
<p>Within some features of MICROSAR OS it may be necessary to provide foreign data types </p>
<p>to the OS. </p>
<p>This can be done by referencing user headers within the OS configuration. </p>
<p>The  features  “IOC”  and  “trusted  functions  stub  generation”  are  relying  on  such  include </p>
<p>mechanisms. </p>
<p> </p>
<p><b> </b></p>
<p><b>Configuration </b></p>
<p><b>Content </b></p>
<p><b>IOC </b></p>
<p>IOC include files are configured with </p>
<p>the IOC attribute </p>
<p>&quot;OsIocIncludeHeader“. </p>
<p>A list of include files may be specified </p>
<p>here. </p>
<p>The headers have to provide </p>
<p><b>&gt; </b></p>
<p>Definitions of foreign OS data </p>
<p>types which are used within IOC </p>
<p>communication. </p>
<p><b>Trusted </b></p>
<p><b>Functions </b></p>
<p>Include files which are needed for </p>
<p>trusted function feature are configured </p>
<p>within the application attribute </p>
<p>“OsAppCalloutStubsIncludeHeader”. </p>
<p>A list of include files may be specified </p>
<p>here. </p>
<p>The headers have to provide </p>
<p><b>&gt; </b></p>
<p>The definitions of foreign OS data </p>
<p>types which are used as trusted </p>
<p>functions parameters or return </p>
<p>values. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All user include files need to implement a double inclusion preventer! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>167 </p>
<p>based on template version 6.0.1 </p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p>This chapter lists all API service functions which are provided by MICROSAR OS. </p>
<p><b>5.1 </b></p>
<p><b>Specified OS services </b></p>
<p>The  OS  provides  the  following  services  which  are  specified  within  the  AUTOSAR  OS </p>
<p>specification. </p>
<p><b>5.1.1 </b></p>
<p><b>StartCore </b></p>
<p><b>Prototype </b></p>
<p>void <b>StartCore </b>(CoreIdType CoreID, StatusType *Status) </p>
<p><b>Parameter </b></p>
<p>CoreID [in] </p>
<p>The core to start. </p>
<p>Status [out] </p>
<p>Status code. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>&gt; </p>
<p>E_OK No Error. E_OS_ID (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Core ID is invalid. </p>
<p>&gt; </p>
<p>- Core is no AUTOSAR core. E_OS_ACCESS (EXTENDED status:) The </p>
<p>function was called after starting the OS. E_OS_STATE (EXTENDED </p>
<p>status:) The Core is already activated. </p>
<p><b>Functional Description </b></p>
<p>OS service StartCore(). </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Pre-Condition: Supervisor mode. Pre-Condition: Given object pointer(s) are valid. </p>
<p>Starts the core given by CoreID that is controlled by the AUTOSAR OS. This API is allowed to be used from </p>
<p>AUTOSAR and non-AUTOSAR cores.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>- </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 5-1  </p>
<p>StartCore </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>168 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.2 </b></p>
<p><b>StartNonAutosarCore </b></p>
<p><b>Prototype </b></p>
<p>void <b>StartNonAutosarCore </b>(CoreIdType CoreID, StatusType *Status) </p>
<p><b>Parameter </b></p>
<p>CoreID  </p>
<p>The core to start. </p>
<p>Status [out] </p>
<p>Status code. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>E_OK No Error. E_OS_ID (EXTENDED status:) Core ID is invalid. </p>
<p>E_OS_STATE (EXTENDED status:) The Core is already activated. </p>
<p><b>Functional Description </b></p>
<p>OS service StartNonAutosarCore(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Supervisor mode. </p>
<p>Starts the core given by CoreID that is not controlled by the AUTOSAR OS.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>- </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 5-2  </p>
<p>StartNonAutosarCore </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>169 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.3 </b></p>
<p><b>GetCoreID </b></p>
<p><b>Prototype </b></p>
<p>CoreIdType <b>GetCoreID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>CoreIdType </p>
<p>Unique ID of the calling core. </p>
<p><b>Functional Description </b></p>
<p>OS service GetCoreID(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Returns the unique logical core identifier of the core on which the function is called. The mapping of </p>
<p>physical cores to logical CoreIDs is implementation specific. This API is allowed to be used from AUTOSAR </p>
<p>cores only. If the API is required on a non-AUTOSAR core, it is possible to configure the core as an </p>
<p>AUTOSAR core but start it as a non-AUTOSAR core using the StartNonAutosarCore() API.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>ANY </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-3  </p>
<p>GetCoreID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>170 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.4 </b></p>
<p><b>GetNumberOfActivatedCores </b></p>
<p><b>Prototype </b></p>
<p>uint32 <b>GetNumberOfActivatedCores </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>uint32 </p>
<p>Number of cores activated by the StartCore() function. </p>
<p><b>Functional Description </b></p>
<p>OS service GetNumberOfActivatedCores(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The function returns the number of cores activated by the StartCore() function. AUTOSAR specifies this </p>
<p>function to be usable from task and ISR call level. But this function does not explicitly perform any call </p>
<p>context checks. There is no need to, because it is a primitive getter function.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-4  </p>
<p>GetNumberOfActivatedCores </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>171 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.5 </b></p>
<p><b>GetActiveApplicationMode </b></p>
<p><b>Prototype </b></p>
<p>AppModeType <b>GetActiveApplicationMode </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AppModeType </p>
<p>Current Application Mode </p>
<p><b>Functional Description </b></p>
<p>OS service GetActiveApplicationMode(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service returns the current application mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-5  </p>
<p>GetActiveApplicationMode </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>172 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.6 </b></p>
<p><b>StartOS </b></p>
<p><b>Prototype </b></p>
<p>void <b>StartOS </b>(AppModeType Mode) </p>
<p><b>Parameter </b></p>
<p>Mode [in] </p>
<p>The application mode in which the OS shall start. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service StartOS(). </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Pre-Condition: Supervisor mode. Pre-Condition: Os_Init() has been called before. </p>
<p>Starts the operating system in a given application mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>- </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 5-6  </p>
<p>StartOS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>173 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.7 </b></p>
<p><b>ShutdownOS </b></p>
<p><b>Prototype </b></p>
<p>void <b>ShutdownOS </b>(StatusType Error) </p>
<p><b>Parameter </b></p>
<p>Error  </p>
<p>Error code which shall be passed to the ShutdownHook() </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service ShutdownOS(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This function shall shutdown the core on which it was called. Only allowed in trusted applications. In case </p>
<p>that ShutdownOS() is called from an invalid context, OS_STATUS_CALLEVEL is reported via the </p>
<p>ProtectionHook.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|STARTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-7  </p>
<p>ShutdownOS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>174 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.8 </b></p>
<p><b>ShutdownAllCores </b></p>
<p><b>Prototype </b></p>
<p>void <b>ShutdownAllCores </b>(StatusType Error) </p>
<p><b>Parameter </b></p>
<p>Error [in] </p>
<p>This is the error code which shall be passed to the ShutdownHook(). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service ShutdownAllCores(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Propagates a shutdown request to all started AUTOSAR cores and performs a shutdown itself afterwards. </p>
<p>Only allowed in trusted applications.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|STARTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-8  </p>
<p>ShutdownAllCores </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>175 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.9 </b></p>
<p><b>ControlIdle </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ControlIdle </b>(CoreIdType CoreID, IdleModeType IdleMode) </p>
<p><b>Parameter </b></p>
<p>CoreID [in] </p>
<p>Selects the core which idle mode is set </p>
<p>IdleMode [in] </p>
<p>The mode which shall be performed during idle time </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_ID (EXTENDED status): Invalid core and/or invalid </p>
<p>IdleMode. E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service ControlIdle(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This API allows the caller to select the idle mode action which is performed during idle time of the OS (e.g. if </p>
<p>no Task/ISR is active). The real idle modes are hardware dependent and not standardized. The default idle </p>
<p>mode on each core is IDLE_NO_HALT.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 5-9  </p>
<p>ControlIdle </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>176 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.10 </b></p>
<p><b>GetSpinlock </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetSpinlock </b>(SpinlockIdType SpinlockId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId [in] </p>
<p>The spinlock which shall be locked. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid SpinlockID. </p>
<p>E_OS_INTERFERENCE_DEADLOCK (EXTENDED status:) Spinlock </p>
<p>already occupied by a task/ISR of the same core. </p>
<p>E_OS_NESTING_DEADLOCK (EXTENDED status:) Invalid Spinlock </p>
<p>allocation order. E_OS_CALLEVEL (EXTENDED status:) Called from </p>
<p>invalid context. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p><b>Functional Description </b></p>
<p>OS service GetSpinlock(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Allocates the requested spinlock for the caller. If it is already locked, the function performs active around </p>
<p>until the spinlock becomes available again.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-10  </p>
<p>GetSpinlock </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>177 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.11 </b></p>
<p><b>ReleaseSpinlock </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ReleaseSpinlock </b>(SpinlockIdType SpinlockId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId [in] </p>
<p>The spinlock which shall be released. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid SpinlockID. </p>
<p>E_OS_STATE (EXTENDED status:) The caller is not the owner of the given </p>
<p>spinlock. E_OS_NOFUNC (EXTENDED status:) The caller tries to release a </p>
<p>spinlock while another spinlock has to be released before. E_OS_RESOURCE </p>
<p>(EXTENDED status:) Spinlock and Resource API not used in LIFO order. </p>
<p>E_OS_ACCESS (Service Protection:) Caller's access rights are not sufficient. </p>
<p>This error may occur in combination with trusted functions. </p>
<p><b>Functional Description </b></p>
<p>OS service ReleaseSpinlock(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>ReleaseSpinlock releases a spinlock variable that was occupied before. Before terminating a task/ISR all </p>
<p>spinlock variables that have been occupied with GetSpinlock() shall be released. The error </p>
<p>E_OS_CALLEVEL is already checked by E_OS_STATE. See Os_SpinlockRelease() for details.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-11  </p>
<p>ReleaseSpinlock </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>178 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.12 </b></p>
<p><b>TryToGetSpinlock </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>TryToGetSpinlock </b>(SpinlockIdType SpinlockId, TryToGetSpinlockType </p>
<p>*Success) </p>
<p><b>Parameter </b></p>
<p>SpinlockId [in] </p>
<p>The spinlock which shall be locked. </p>
<p>Success [out] </p>
<p>The result of the allocation attempt. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid SpinlockID. </p>
<p>E_OS_INTERFERENCE_DEADLOCK (EXTENDED status:) Spinlock </p>
<p>already occupied by a task/ISR of the same core. </p>
<p>E_OS_NESTING_DEADLOCK (EXTENDED status:) Invalid Spinlock </p>
<p>allocation order. E_OS_CALLEVEL (EXTENDED status:) Called from </p>
<p>invalid context. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p><b>Functional Description </b></p>
<p>OS service TryToGetSpinlock(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Allocates the requested spinlock for the caller. If it is already locked, the function returns.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-12  </p>
<p>TryToGetSpinlock </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>179 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.13 </b></p>
<p><b>DisableAllInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>DisableAllInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service DisableAllInterrupts().. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Not already in DisableAllInterrupts() sequence. </p>
<p>Disables category 1 and category 2 ISRs. If timing protection is configured, the timing protection interrupt is </p>
<p>not affected.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-13  </p>
<p>DisableAllInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>180 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.14 </b></p>
<p><b>EnableAllInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>EnableAllInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service EnableAllInterrupts(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: In DisableAllInterrupts() sequence. </p>
<p>Restores the state saved by DisableAllInterrupts(). </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-14  </p>
<p>EnableAllInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>181 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.15 </b></p>
<p><b>SuspendAllInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>SuspendAllInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service SuspendAllInterrupts(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Not in DisableAllInterrupts() sequence. </p>
<p>Saves the recognition status of all interrupts and disables all interrupts for which the hardware supports </p>
<p>disabling. This API can be called nested.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-15  </p>
<p>SuspendAllInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>182 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.16 </b></p>
<p><b>ResumeAllInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>ResumeAllInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service ResumeAllInterrupts(). </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Pre-Condition: In SuspendAllInterrupts() sequence.Pre-Condition: Correct nesting sequence of suspend </p>
<p>interrupt API. </p>
<p>Restores the recognition status of all interrupts saved by the SuspendAllInterrupts() service.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-16  </p>
<p>ResumeAllInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>183 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.17 </b></p>
<p><b>SuspendOSInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>SuspendOSInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service SuspendOSInterrupts(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Not in DisableAllInterrupts() sequence. </p>
<p>Saves the recognition status of interrupts of category 2 and disables the recognition of these interrupts. This </p>
<p>API can be called nested.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-17  </p>
<p>SuspendOSInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>184 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.18 </b></p>
<p><b>ResumeOSInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>ResumeOSInterrupts </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service ResumeOSInterrupts(). </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Pre-Condition: In SuspendOSInterrupts() sequence.Pre-Condition: Correct nesting sequence of suspend </p>
<p>interrupt API. </p>
<p>Restores the recognition status of interrupts saved by the SuspendOSInterrupts() service.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|ALARMHOOK|PROTH</p>
<p>OOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-18  </p>
<p>ResumeOSInterrupts </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>185 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.19 </b></p>
<p><b>ActivateTask </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ActivateTask </b>(TaskType TaskID) </p>
<p><b>Parameter </b></p>
<p>TaskID [in] </p>
<p>The task which shall be activated. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_LIMIT Too many task activations. E_OS_ID </p>
<p>(EXTENDED status:) Invalid TaskID. E_OS_CALLEVEL (EXTENDED </p>
<p>status:) Called from invalid context. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. E_OS_ACCESS (Service </p>
<p>Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given task's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service ActivateTask(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The task TaskID is transferred from the SUSPENDED state into the READY state. The operating system </p>
<p>ensures that the task code is being executed from the first statement.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-19  </p>
<p>ActivateTask </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>186 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.20 </b></p>
<p><b>TerminateTask </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>TerminateTask </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_RESOURCE (EXTENDED status:) Task still occupies resources. </p>
<p>E_OS_SPINLOCK (EXTENDED status:) Task still holds spinlocks. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service TerminateTask(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service causes the termination of the calling task. The calling task is transferred from the RUNNING </p>
<p>state into the SUSPENDED state. This service only returns in case it detects an error.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-20  </p>
<p>TerminateTask </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>187 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.21 </b></p>
<p><b>ChainTask </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ChainTask </b>(TaskType TaskID) </p>
<p><b>Parameter </b></p>
<p>TaskID [in] </p>
<p>The task which shall be activated. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OS_LIMIT Too many task activations. E_OS_CALLEVEL (EXTENDED </p>
<p>status:) Called from invalid context. E_OS_RESOURCE (EXTENDED </p>
<p>status:) Task still occupies resources. E_OS_SPINLOCK (EXTENDED </p>
<p>status:) Task still holds spinlocks. E_OS_ID (EXTENDED status:) Invalid </p>
<p>TaskID. E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given task's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service ChainTask(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>After termination of the calling task the given task is activated. This service only returns in case it detects an </p>
<p>error.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-21  </p>
<p>ChainTask </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>188 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.22 </b></p>
<p><b>Schedule </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>Schedule </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No Error. E_OS_CALLEVEL (EXTENDED status:) The service was </p>
<p>called from any context which is not allowed. E_OS_RESOURCE </p>
<p>(EXTENDED status:) The service was called from a task which holds an OS </p>
<p>resource. E_OS_SPINLOCK (EXTENDED status:) The service was called </p>
<p>from a task which holds a spinlock. E_OS_DISABLEDINT (Service Protection:) </p>
<p>The service was called with disabled interrupts. </p>
<p><b>Functional Description </b></p>
<p>OS service Schedule(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Interrupts are enabled. </p>
<p> </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-22  </p>
<p>Schedule </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>189 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.23 </b></p>
<p><b>GetTaskID </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetTaskID </b>(TaskRefType TaskID) </p>
<p><b>Parameter </b></p>
<p>TaskID [out] </p>
<p>The current task ID. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_CALLEVEL (EXTENDED status:) Called from invalid </p>
<p>context. E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is </p>
<p>NULL. E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetTaskID(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Returns the ID of the task which is currently RUNNING on the local core.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-23  </p>
<p>GetTaskID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>190 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.24 </b></p>
<p><b>GetTaskState </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetTaskState </b>(TaskType TaskID, TaskStateRefType State) </p>
<p><b>Parameter </b></p>
<p>TaskID [in] </p>
<p>The task to be queried. </p>
<p>State [out] </p>
<p>The task's state. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_CALLEVEL (EXTENDED status:) Called from </p>
<p>invalid context. E_OS_ID (EXTENDED status:) Invalid TaskID. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is NULL. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given task's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service GetTaskState(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: The given task has to be assigned to the current core. </p>
<p>Returns the current scheduling state of a task (RUNNING, READY, ...).  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-24  </p>
<p>GetTaskState </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>191 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.25 </b></p>
<p><b>GetISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>GetISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>&gt; </p>
<p>Identifier of running ISR INVALID_ISR If called from </p>
<p>&gt; </p>
<p>- invalid call-context, </p>
<p>&gt; </p>
<p>- from a task or </p>
<p>&gt; </p>
<p>- a hook which was called inside a task context. </p>
<p><b>Functional Description </b></p>
<p>OS service GetISRID(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Return the identifier of the currently executing ISR.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-25  </p>
<p>GetISRID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>192 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.26 </b></p>
<p><b>SetEvent </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>SetEvent </b>(TaskType TaskID, EventMaskType Mask) </p>
<p><b>Parameter </b></p>
<p>TaskID [in] </p>
<p>The task which shall be modified. </p>
<p>Mask [in] </p>
<p>The events which shall be set. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid TaskID. </p>
<p>E_OS_ACCESS (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Task is no extended task. (Service Protection:) </p>
<p>&gt; </p>
<p>- Task's owner application is not accessible. </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_STATE (EXTENDED </p>
<p>status:) Events cannot be set as the referenced task is in the SUSPENDED </p>
<p>state. E_OS_CALLEVEL (Service Protection:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service SetEvent(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The events of the given task are set according to the given event mask.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-26  </p>
<p>SetEvent </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>193 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.27 </b></p>
<p><b>ClearEvent </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ClearEvent </b>(EventMaskType Mask) </p>
<p><b>Parameter </b></p>
<p>Mask [in] </p>
<p>The events which shall be set. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_ACCESS (EXTENDED status:) Task is no extended </p>
<p>task. E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service ClearEvent(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The events of the calling task are cleared according to the given event mask.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-27  </p>
<p>ClearEvent </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>194 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.28 </b></p>
<p><b>GetEvent </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetEvent </b>(TaskType TaskID, EventMaskRefType Mask) </p>
<p><b>Parameter </b></p>
<p>TaskID [in] </p>
<p>The task which shall be queried. </p>
<p>Mask [out] </p>
<p>Events which are set. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_PARAM_POINTER (EXTENDED status:) Given </p>
<p>pointer is NULL. E_OS_ID (EXTENDED status:) Invalid TaskID. </p>
<p>E_OS_ACCESS (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Task is no extended task. (Service Protection:) </p>
<p>&gt; </p>
<p>- Task's owner application is not accessible. </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_STATE (EXTENDED </p>
<p>status:) Referenced task is in SUSPENDED state. E_OS_CALLEVEL </p>
<p>(EXTENDED status:) Called from invalid context. E_OS_DISABLEDINT </p>
<p>(Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetEvent(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Task is assigned to the current core. </p>
<p>This service returns the state of all event bits of the given task, not the events that the task is waiting for.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-28  </p>
<p>GetEvent </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>195 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.29 </b></p>
<p><b>WaitEvent </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>WaitEvent </b>(EventMaskType Mask) </p>
<p><b>Parameter </b></p>
<p>Mask [in] </p>
<p>Mask of the events waited for. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_ACCESS (EXTENDED status:) Task is no extended </p>
<p>task. E_OS_RESOURCE (EXTENDED status:) Task still occupies resources. </p>
<p>E_OS_SPINLOCK (EXTENDED status:) Task still holds spinlocks. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service WaitEvent(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The state of the current task is set to WAITING, unless at least one of the given events is set.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-29  </p>
<p>WaitEvent </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>196 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.30 </b></p>
<p><b>IncrementCounter </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>IncrementCounter </b>(CounterType CounterID) </p>
<p><b>Parameter </b></p>
<p>CounterID [in] </p>
<p>The counter to be incremented. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No Error. E_OS_ID (EXTENDED status:) CounterID is not a valid </p>
<p>software counter ID. E_OS_CALLEVEL (EXTENDED status:) Called from </p>
<p>invalid context. E_OS_CORE (EXTENDED status:) The given object </p>
<p>belongs to a foreign core. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given counter's owner application is not accessible. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service IncrementCounter(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p> </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-30  </p>
<p>IncrementCounter </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>197 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.31 </b></p>
<p><b>GetCounterValue </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetCounterValue </b>(CounterType CounterID, TickRefType Value) </p>
<p><b>Parameter </b></p>
<p>CounterID [in] </p>
<p>The counter to be read. </p>
<p>Value [out] </p>
<p>Contains the current tick value of the counter. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No Error. E_OS_ID (EXTENDED status:) Invalid CounterID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is NULL. </p>
<p>E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Counter's owner application is not accessible. </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetCounterValue(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p> </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-31  </p>
<p>GetCounterValue </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>198 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.32 </b></p>
<p><b>GetElapsedValue </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetElapsedValue </b>(CounterType CounterID, TickRefType Value, </p>
<p>TickRefType ElapsedValue) </p>
<p><b>Parameter </b></p>
<p>CounterID [in] </p>
<p>The counter to be read. </p>
<p>Value [in,out] </p>
<p>**in:** The previously read tick value of the counter. </p>
<p>**out:** The current tick value of the counter. </p>
<p>ElapsedValue [out] </p>
<p>The difference to the previous read value. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No Error. E_OS_ID (EXTENDED status:) Invalid CounterID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_VALUE (EXTENDED status:) The given Value was not valid. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is NULL. </p>
<p>E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Counter's owner application is not accessible. </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetElapsedValue(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p> </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-32  </p>
<p>GetElapsedValue </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>199 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.33 </b></p>
<p><b>GetAlarmBase </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetAlarmBase </b>(AlarmType AlarmID, AlarmBaseRefType Info) </p>
<p><b>Parameter </b></p>
<p>AlarmID [in] </p>
<p>Reference to the alarm element. </p>
<p>Info [out] </p>
<p>Contains information about the counter on successful return. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid AlarmID. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is NULL. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given task's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service GetAlarmBase(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: Given object pointer(s) are valid. </p>
<p>The system service GetAlarmBase reads the alarm base characteristics. The return value Info is a structure </p>
<p>in which the information of data type AlarmBaseType is stored.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|PRETHOOK|POSTTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-33  </p>
<p>GetAlarmBase </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>200 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.34 </b></p>
<p><b>GetAlarm </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetAlarm </b>(AlarmType AlarmID, TickRefType Tick) </p>
<p><b>Parameter </b></p>
<p>AlarmID [in] </p>
<p>Reference to the alarm element. </p>
<p>Tick [out] </p>
<p>Relative value in ticks before the alarm expires. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_NOFUNC Alarm is not in use. E_OS_ID </p>
<p>(EXTENDED status:) Invalid AlarmID. E_OS_PARAM_POINTER </p>
<p>(EXTENDED status:) Given pointer is NULL. E_OS_CALLEVEL </p>
<p>(EXTENDED status:) Called from invalid context. E_OS_DISABLEDINT </p>
<p>(Service Protection:) Caller is in interrupt API sequence. E_OS_ACCESS </p>
<p>(Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given task's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service GetAlarm(). </p>
<p><b>Particularities and Limitations </b></p>
<p>The given alarm is assigned to the local core. </p>
<p>It is up to the application to decide whether for example a CancelAlarm may still be useful. If AlarmID is not </p>
<p>in use, Tick is not defined. Allowed on task level, ISR, and in several hook routines.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|PRETHOOK|POSTTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-34  </p>
<p>GetAlarm </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>201 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.35 </b></p>
<p><b>SetRelAlarm </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>SetRelAlarm </b>(AlarmType AlarmID, TickType Increment, TickType Cycle) </p>
<p><b>Parameter </b></p>
<p>AlarmID [in] </p>
<p>Reference to the alarm element. </p>
<p>Increment [in] </p>
<p>Relative value in ticks. </p>
<p>Cycle [in] </p>
<p>Cycle value in case of cyclic alarm. In case of single alarms, cycle shall be </p>
<p>zero. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Alarm is already in use. E_OS_ID </p>
<p>(EXTENDED status:) Invalid AlarmID. E_OS_VALUE Returned if: </p>
<p>&gt; </p>
<p>- Value of increment is zero </p>
<p>&gt; </p>
<p>- (EXTENDED status:) Value of Increment outside of the admissible limits </p>
<p>(lower than zero or greater than maxallowedvalue). </p>
<p>&gt; </p>
<p>- (EXTENDED status:) Value of Cycle unequal to 0 and outside of the </p>
<p>admissible counter limits (less than mincycle or greater than </p>
<p>maxallowedvalue). E_OS_CALLEVEL (EXTENDED status:) Called from </p>
<p>invalid context. E_OS_DISABLEDINT (Service Protection:) Caller is in </p>
<p>interrupt API sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given alarm's owner application is not accessible. other See </p>
<p>Os_XSigSend_SetRelAlarm() and Os_XSigRecv_SetRelAlarm(). </p>
<p><b>Functional Description </b></p>
<p>OS service SetRelAlarm(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The system service occupies the alarm AlarmID element. After increment ticks have elapsed, the task </p>
<p>assigned to the alarm AlarmID is activated or the assigned event (only for extended tasks) is set or the </p>
<p>alarm-callback routine is called.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-35  </p>
<p>SetRelAlarm </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>202 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.36 </b></p>
<p><b>SetAbsAlarm </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>SetAbsAlarm </b>(AlarmType AlarmID, TickType Start, TickType Cycle) </p>
<p><b>Parameter </b></p>
<p>AlarmID [in] </p>
<p>Reference to the alarm element. </p>
<p>Start [in] </p>
<p>Absolute value in ticks. </p>
<p>Cycle [in] </p>
<p>Cycle value in case of cyclic alarm. In case of single alarms, cycle shall be </p>
<p>zero. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Alarm is already in use. E_OS_ID </p>
<p>(EXTENDED status:) Invalid AlarmID. E_OS_VALUE (EXTENDED status:) </p>
<p>Returned if: </p>
<p>&gt; </p>
<p>- Value of Start outside of the admissible counter limit (less than zero or </p>
<p>greater than maxallowedvalue). </p>
<p>&gt; </p>
<p>- Value of Cycle unequal to 0 and outside of the admissible counter limits </p>
<p>(less than mincycle or greater than maxallowedvalue). E_OS_CALLEVEL </p>
<p>(EXTENDED status:) Called from invalid context. E_OS_DISABLEDINT </p>
<p>(Service Protection:) Caller is in interrupt API sequence. E_OS_ACCESS </p>
<p>(Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given alarm's owner application is not accessible. other See </p>
<p>Os_XSigSend_SetAbsAlarm() and Os_XSigRecv_SetAbsAlarm(). </p>
<p><b>Functional Description </b></p>
<p>OS service SetAbsAlarm(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The system service occupies the alarm AlarmID element. When start ticks are reached, the task assigned </p>
<p>to the alarm AlarmID is activated or the assigned event (only for extended tasks) is set or the alarm-callback </p>
<p>routine is called.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-36  </p>
<p>SetAbsAlarm </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>203 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.37 </b></p>
<p><b>CancelAlarm </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>CancelAlarm </b>(AlarmType AlarmID) </p>
<p><b>Parameter </b></p>
<p>AlarmID [in] </p>
<p>Reference to the alarm element. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_NOFUNC Alarm is not in use. E_OS_ID </p>
<p>(EXTENDED status:) Invalid AlarmID. E_OS_CALLEVEL (EXTENDED </p>
<p>status:) Called from invalid context. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. E_OS_ACCESS (Service </p>
<p>Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given alarm's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service CancelAlarm(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The system service cancels the alarm AlarmID.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-37  </p>
<p>CancelAlarm </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>204 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.38 </b></p>
<p><b>GetResource </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetResource </b>(ResourceType ResID) </p>
<p><b>Parameter </b></p>
<p>ResID [in] </p>
<p>The resource which shall be occupied. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid ResID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_CORE (EXTENDED status:) The given object belongs to a foreign </p>
<p>core. E_OS_ACCESS (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Statically assigned priority of the caller is higher than the calculated ceiling </p>
<p>priority. </p>
<p>&gt; </p>
<p>- Attempt to get a resource which is already occupied. (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetResource(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This API serves to enter critical sections in the code. A critical section shall always be left using </p>
<p>ReleaseResource(). </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-38  </p>
<p>GetResource </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>205 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.39 </b></p>
<p><b>ReleaseResource </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>ReleaseResource </b>(ResourceType ResID) </p>
<p><b>Parameter </b></p>
<p>ResID [in] </p>
<p>The resource which shall be released. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid ResID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_CORE (EXTENDED status:) The given object belongs to a foreign </p>
<p>core. E_OS_NOFUNC (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Attempt to release a resource which has not been occupied by the caller </p>
<p>before. </p>
<p>&gt; </p>
<p>- Attempt to release a nested resource in wrong order. E_OS_SPINLOCK </p>
<p>(EXTENDED status:) Spinlock and Resource API not used in LIFO order. </p>
<p>E_OS_ACCESS (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Attempt to release a resource which has a lower ceiling priority than the </p>
<p>statically assigned priority of the caller. (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. E_OS_DISABLEDINT (Service </p>
<p>Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service ReleaseResource(). </p>
<p><b>Particularities and Limitations </b></p>
<p>This API is the counterpart of GetResource() and serves to leave critical sections in the code.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-39  </p>
<p>ReleaseResource </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>206 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.40 </b></p>
<p><b>StartScheduleTableRel </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>StartScheduleTableRel </b>(ScheduleTableType ScheduleTableID, TickType </p>
<p>Offset) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table to be started. </p>
<p>Offset [in] </p>
<p>The relative offset when the schedule table shall be started. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Schedule table has already been started. </p>
<p>E_OS_ID (EXTENDED status:) Invalid ScheduleTableID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_VALUE (EXTENDED status:) Offset is bigger than </p>
<p>(OsCounterMaxAllowedValue - InitialOffset) or is equal to zero </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service StartScheduleTableRel(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The schedule table is started at a relative offset to the current time.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-40  </p>
<p>StartScheduleTableRel </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>207 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.41 </b></p>
<p><b>StartScheduleTableAbs </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>StartScheduleTableAbs </b>(ScheduleTableType ScheduleTableID, TickType </p>
<p>Start) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table to be started </p>
<p>Start [in] </p>
<p>The absolute time when the schedule table shall be started </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Schedule table has already been started. </p>
<p>E_OS_ID (EXTENDED status:) Invalid ScheduleTableID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_VALUE (EXTENDED status:) Offset is bigger than </p>
<p>OsCounterMaxAllowedValue E_OS_DISABLEDINT (Service Protection:) </p>
<p>Caller is in interrupt API sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service StartScheduleTableAbs(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The schedule table is started at an absolute time.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-41  </p>
<p>StartScheduleTableAbs </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>208 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.42 </b></p>
<p><b>StopScheduleTable </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>StopScheduleTable </b>(ScheduleTableType ScheduleTableID) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table to be stopped. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_NOFUNC Schedule table has already been </p>
<p>stopped. E_OS_ID (EXTENDED status:) Invalid ScheduleTableID. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service StopScheduleTable(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>The schedule table is stopped immediately.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-42  </p>
<p>StopScheduleTable </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>209 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.43 </b></p>
<p><b>NextScheduleTable </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>NextScheduleTable </b>(ScheduleTableType ScheduleTableID_From, </p>
<p>ScheduleTableType ScheduleTableID_To) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID_From [in] </p>
<p>The ID of the schedule table which is requested to stop at its end </p>
<p>ScheduleTableID_To [in] </p>
<p>The ID of the schedule table which starts after the other one has stopped </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_NOFUNC Schedule table ScheduleTableID_From </p>
<p>has not been started. E_OS_STATE Schedule table ScheduleTableID_To </p>
<p>has already been requested to start at the end of another schedule table. </p>
<p>E_OS_ID (EXTENDED status:) Invalid ScheduleTableID_From/To. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API </p>
<p>sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service NextScheduleTable(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Requests the switch of schedule table processing from one schedule table to another after the first one has </p>
<p>reached its end.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-43  </p>
<p>NextScheduleTable </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>210 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.44 </b></p>
<p><b>GetScheduleTableStatus </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetScheduleTableStatus </b>(ScheduleTableType ScheduleTableID, </p>
<p>ScheduleTableStatusRefType ScheduleStatus) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table for which the status shall be requested. </p>
<p>ScheduleStatus [out] </p>
<p>Reference to ScheduleTableStatusType. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid ScheduleTableID </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) ScheduleStatus is a </p>
<p>pointer to null. E_OS_DISABLEDINT (Service Protection:) Caller is in </p>
<p>interrupt API sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service GetScheduleTableStatus(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service queries the state of a schedule table (also with respect to synchronization).  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-44  </p>
<p>GetScheduleTableStatus </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>211 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.45 </b></p>
<p><b>StartScheduleTableSynchron </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>StartScheduleTableSynchron </b>(ScheduleTableType ScheduleTableID) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table which shall start synchronously </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Schedule table ScheduleTableID has </p>
<p>already been started. E_OS_ID (EXTENDED status:) Invalid </p>
<p>ScheduleTableID. E_OS_CORE (EXTENDED status:) The given object </p>
<p>belongs to a foreign core. E_OS_CALLEVEL (EXTENDED status:) Called </p>
<p>from invalid context. E_OS_DISABLEDINT (Service Protection:) Caller is in </p>
<p>interrupt API sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service StartScheduleTableSynchron(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service starts an explicitly synchronized schedule table synchronously. As a result the schedule table </p>
<p>enters the state SCHEDULETABLE_WAITING and waits for a synchronization count to be provided.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-45  </p>
<p>StartScheduleTableSynchron </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>212 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.46 </b></p>
<p><b>SyncScheduleTable </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>SyncScheduleTable </b>(ScheduleTableType ScheduleTableID, TickType </p>
<p>Value) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table to the synchronized </p>
<p>Value [in] </p>
<p>The current value of the synchronization counter </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE The state of the schedule table </p>
<p>ScheduleTableId is equal to SCHEDULETABLE_STOPPED or </p>
<p>SCHEDULETABLE_NEXT. E_OS_ID (EXTENDED status:) Invalid </p>
<p>ScheduleTableID. E_OS_CORE (EXTENDED status:) The given object </p>
<p>belongs to a foreign core. E_OS_CALLEVEL (EXTENDED status:) Called </p>
<p>from invalid context. E_OS_VALUE (EXTENDED status:) The Value is out </p>
<p>of range E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service SyncScheduleTable(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service provides the schedule table with a synchronization count and starts the synchronization.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-46  </p>
<p>SyncScheduleTable </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>213 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.47 </b></p>
<p><b>SetScheduleTableAsync </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>SetScheduleTableAsync </b>(ScheduleTableType ScheduleTableID) </p>
<p><b>Parameter </b></p>
<p>ScheduleTableID [in] </p>
<p>The ID of the schedule table which shall no longer be synchronized. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_STATE Current state of ScheduleTableID is </p>
<p>SCHEDULETABLE_STOPPED, SCHEDULETABLE_NEXT or </p>
<p>SCHEDULETABLE_WAITING. E_OS_ID (EXTENDED status:) </p>
<p>&gt; </p>
<p>- Invalid ScheduleTableID. </p>
<p>&gt; </p>
<p>- OsScheduleTblSyncStrategy of ScheduleTableID is not equal to </p>
<p>EXPLICIT E_OS_CORE (EXTENDED status:) The given object belongs to </p>
<p>a foreign core. E_OS_CALLEVEL (EXTENDED status:) Called from invalid </p>
<p>context. E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt </p>
<p>API sequence. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Caller's access rights are not sufficient. </p>
<p>&gt; </p>
<p>- Given schedule table's owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service SetScheduleTableAsync(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service stops the synchronization of a schedule table.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-47  </p>
<p>SetScheduleTableAsync </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>214 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.48 </b></p>
<p><b>GetApplicationID </b></p>
<p><b>Prototype </b></p>
<p>ApplicationType <b>GetApplicationID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ApplicationType </p>
<p>Identifier of the OS-Application. </p>
<p><b>Functional Description </b></p>
<p>OS service GetApplicationID(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service determines the OS-Application where the caller (Task/ISR/Hook) originally belongs to (was </p>
<p>configured to). All system objects (e.g. system hooks, idle task, ...) belong to kernel applications. Kernel </p>
<p>applications are regular applications and have valid identifiers. Therefore INVALID_OSAPPLICATION is </p>
<p>never returned because there is always a valid application active.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-48  </p>
<p>GetApplicationID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>215 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.49 </b></p>
<p><b>GetCurrentApplicationID </b></p>
<p><b>Prototype </b></p>
<p>ApplicationType <b>GetCurrentApplicationID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ApplicationType </p>
<p>Identifier of the OS-Application. </p>
<p><b>Functional Description </b></p>
<p>OS service GetCurrentApplicationID(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service determines the OS-Application where the caller (Task/ISR/Hook) of the service is currently </p>
<p>executing. Note that, if the caller is not within a CallTrustedFunction() call, the value is equal to the result of </p>
<p>GetApplicationID(). </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-49  </p>
<p>GetCurrentApplicationID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>216 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.50 </b></p>
<p><b>GetApplicationState </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>GetApplicationState </b>(ApplicationType Application, </p>
<p>ApplicationStateRefType Value) </p>
<p><b>Parameter </b></p>
<p>Application [in] </p>
<p>The OS-Application from which the state is requested. </p>
<p>Value [out] </p>
<p>The current state of the application. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_ID (EXTENDED status:) Invalid Application. </p>
<p>E_OS_PARAM_POINTER (EXTENDED status:) Given pointer is NULL. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service GetApplicationState(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service returns the current state of an OS-Application.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PRETHOOK|POSTTHOOK|STARTHOOK|SHUTHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-50  </p>
<p>GetApplicationState </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>217 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.51 </b></p>
<p><b>CheckObjectAccess </b></p>
<p><b>Prototype </b></p>
<p>ObjectAccessType <b>CheckObjectAccess </b>(ApplicationType ApplID, ObjectTypeType </p>
<p>ObjectType, Os_ObjectIdType ObjectID) </p>
<p><b>Parameter </b></p>
<p>ApplID [in] </p>
<p>OS-Application identifier. </p>
<p>ObjectType [in] </p>
<p>Type of the following parameter. </p>
<p>ObjectID [in] </p>
<p>The object to be examined. </p>
<p><b>Return code </b></p>
<p>ObjectAccessType </p>
<p>&gt; </p>
<p>ACCESS if the ApplID has access to the object. NO_ACCESS If: </p>
<p>&gt; </p>
<p>- ApplID doesn't have access to the object. </p>
<p>&gt; </p>
<p>- ApplID is invalid. </p>
<p>&gt; </p>
<p>- ObjectID is invalid. </p>
<p><b>Functional Description </b></p>
<p>OS service CheckObjectAccess(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service determines if the OS-Application, given by ApplID, is allowed to use the IDs of a Task, </p>
<p>Resource, Counter, Alarm or Schedule Table in API calls.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-51  </p>
<p>CheckObjectAccess </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>218 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.52 </b></p>
<p><b>CheckObjectOwnership </b></p>
<p><b>Prototype </b></p>
<p>ApplicationType <b>CheckObjectOwnership </b>(ObjectTypeType ObjectType, </p>
<p>Os_ObjectIdType ObjectID) </p>
<p><b>Parameter </b></p>
<p>ObjectType [in] </p>
<p>Type of the following parameter. </p>
<p>ObjectID [in] </p>
<p>The object to be examined. </p>
<p><b>Return code </b></p>
<p>ApplicationType </p>
<p>Identifier of the owner OS-Application. INVALID_OSAPPLICATION if the object </p>
<p>does not exist. </p>
<p><b>Functional Description </b></p>
<p>OS service CheckObjectOwnership(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service determines to which OS-Application a given Task, ISR, Counter, Alarm or Schedule Table </p>
<p>belongs.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK|PROTHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-52  </p>
<p>CheckObjectOwnership </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>219 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.53 </b></p>
<p><b>AllowAccess </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>AllowAccess </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>E_OK No error. E_OS_STATE The application is not in the restarting state. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_DISABLEDINT (Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service AllowAccess(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service sets the state of the current OS-Application from APPLICATION_RESTARTING to </p>
<p>APPLICATION_ACCESSIBLE.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-53  </p>
<p>AllowAccess </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>220 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.54 </b></p>
<p><b>TerminateApplication </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>TerminateApplication </b>(ApplicationType Application, RestartType </p>
<p>RestartOption) </p>
<p><b>Parameter </b></p>
<p>Application [in] </p>
<p>The identifier of the OS-Application to be terminated. If the caller belongs to </p>
<p>Application the call results in a self-termination. </p>
<p>RestartOption [in] </p>
<p>Either RESTART for doing a restart of the OS-Application or NO_RESTART if </p>
<p>OS-Application shall not be restarted. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No errors E_OS_STATE The state of Application does not allow </p>
<p>terminating it: </p>
<p>&gt; </p>
<p>- The application is already terminated. </p>
<p>&gt; </p>
<p>- The application is restarting AND the caller does not belong to the </p>
<p>application. </p>
<p>&gt; </p>
<p>- The application is restarting AND the caller does belong to the application </p>
<p>AND the RestartOption is RESTART. E_OS_ID (EXTENDED status:) </p>
<p>Application was not valid. E_OS_VALUE (EXTENDED status:) </p>
<p>RestartOption was neither RESTART nor NO_RESTART. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_ACCESS (EXTENDED status:) The caller belongs to a non-trusted </p>
<p>OS-Application AND the caller does not belong to given Application </p>
<p>TerminateApplication() shall return E_OS_ACCESS. E_OS_DISABLEDINT </p>
<p>(Service Protection:) Caller is in interrupt API sequence. </p>
<p><b>Functional Description </b></p>
<p>OS service TerminateApplication(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>This service terminates the OS-Application to which the calling Task/ISR/application specific error hook </p>
<p>belongs.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2|ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-54  </p>
<p>TerminateApplication </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>221 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.55 </b></p>
<p><b>CallTrustedFunction </b></p>
<p><b>Prototype </b></p>
<p>StatusType <b>CallTrustedFunction </b>(TrustedFunctionIndexType FunctionIndex, </p>
<p>TrustedFunctionParameterRefType FunctionParams) </p>
<p><b>Parameter </b></p>
<p>FunctionIndex [in] </p>
<p>Index of the function to be called. </p>
<p>FunctionParams [in] </p>
<p>Pointer to the parameters for the function. If no parameters are provided, a </p>
<p>NULL pointer has to be passed. </p>
<p><b>Return code </b></p>
<p>StatusType </p>
<p>&gt; </p>
<p>E_OK No error. E_OS_SERVICEID No function defined for this index. </p>
<p>E_OS_CALLEVEL (EXTENDED status:) Called from invalid context. </p>
<p>E_OS_ACCESS (EXTENDED status:) The given object belongs to a </p>
<p>foreign core. E_OS_ACCESS (Service Protection:) </p>
<p>&gt; </p>
<p>- Owner application is not accessible. </p>
<p><b>Functional Description </b></p>
<p>OS service CallTrustedFunction(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Each trusted OS-Application may export services which are callable from other OS-Applications.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK|ISR2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-55  </p>
<p>CallTrustedFunction </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>222 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.56 </b></p>
<p><b>Check Task Memory Access </b></p>
<p><b>Prototype </b></p>
<p>FUNC(AccessType, OS_CODE) CheckTaskMemoryAccess( </p>
<p>  TaskType TaskID, </p>
<p>  MemoryStartAddressType Address, </p>
<p>  MemorySizeType Size </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>TaskID </p>
<p>ID of task </p>
<p>Address </p>
<p>Start address of checked address range </p>
<p>Size </p>
<p>Size of checked address range </p>
<p><b>Return code </b></p>
<p>AccessType </p>
<p>Returns the access rights of the Task to the given address range </p>
<p><b>Functional Description </b></p>
<p>The service distinguishes the memory access rights of a given Task. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The access checks are based upon the “OsAccessCheckRegion” configuration objects. </p>
<p>&gt; </p>
<p>The return value of this functions is typically used with the AUTOSAR OS specified macros </p>
<p>&gt; </p>
<p>OSMEMORY_IS_READABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_WRITEABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_EXECUTABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_STACKSPACE </p>
<p>Table 5-56  </p>
<p>API Service CheckTaskMemoryAccess </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>223 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.57 </b></p>
<p><b>Check ISR Memory Access </b></p>
<p><b>Prototype </b></p>
<p>FUNC(AccessType, OS_CODE) CheckISRMemoryAccess( </p>
<p>  ISRType ISRID, </p>
<p>  MemoryStartAddressType Address, </p>
<p>  MemorySizeType Size </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>ID of category 2 ISR </p>
<p>Address </p>
<p>Start address of checked address range </p>
<p>Size </p>
<p>Size of checked address range </p>
<p><b>Return code </b></p>
<p>AccessType </p>
<p>Returns the access rights of the ISR to the given address range </p>
<p><b>Functional Description </b></p>
<p>The service distinguishes the memory access rights of a given category 2 ISR </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The access checks are based upon the “OsAccessCheckRegion” configuration objects. </p>
<p>&gt; </p>
<p>The return value of this functions is typically used with the AUTOSAR OS specified macros </p>
<p>&gt; </p>
<p>OSMEMORY_IS_READABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_WRITEABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_EXECUTABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_STACKSPACE </p>
<p>Table 5-57  </p>
<p>API Service CheckISRMemoryAccess </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>224 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.58 </b></p>
<p><b>OSErrorGetServiceId </b></p>
<p><b>Prototype </b></p>
<p>OSServiceIdType <b>OSErrorGetServiceId </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>OSServiceIdType </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>OS service OSErrorGetServiceId(). </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>Provides the service identifier where the error has been risen.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-58  </p>
<p>OSErrorGetServiceId </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>225 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.59 </b></p>
<p><b>OSError_Os_DisableInterruptSource_ISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>OSError_Os_DisableInterruptSource_ISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ISRID of a faulty Os_DisableInterruptSource call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-59  </p>
<p>OSError_Os_DisableInterruptSource_ISRID </p>
<p><b>5.1.60 </b></p>
<p><b>OSError_Os_EnableInterruptSource_ISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>OSError_Os_EnableInterruptSource_ISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ISRID of a faulty Os_EnableInterruptSource call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-60  </p>
<p>OSError_Os_EnableInterruptSource_ISRID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>226 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.61 </b></p>
<p><b>OSError_Os_EnableInterruptSource_ClearPending </b></p>
<p><b>Prototype </b></p>
<p>boolean <b>OSError_Os_EnableInterruptSource_ClearPending </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>boolean </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ClearPending of a faulty Os_EnableInterruptSource call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-61  </p>
<p>OSError_Os_EnableInterruptSource_ClearPending </p>
<p><b>5.1.62 </b></p>
<p><b>OSError_Os_ClearPendingInterrupt_ISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>OSError_Os_ClearPendingInterrupt_ISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ISRID of a faulty Os_ClearPendingInterrupt call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-62  </p>
<p>OSError_Os_ClearPendingInterrupt_ISRID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>227 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.63 </b></p>
<p><b>OSError_Os_IsInterruptSourceEnabled_ISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>OSError_Os_IsInterruptSourceEnabled_ISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ISRID of a faulty Os_IsInterruptSourceEnabled call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-63  </p>
<p>OSError_Os_IsInterruptSourceEnabled_ISRID </p>
<p><b>5.1.64 </b></p>
<p><b>OSError_Os_IsInterruptSourceEnabled_IsEnabled </b></p>
<p><b>Prototype </b></p>
<p>boolean * <b>OSError_Os_IsInterruptSourceEnabled_IsEnabled </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>boolean * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IsEnabled of a faulty Os_IsInterruptSourceEnabled call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-64  </p>
<p>OSError_Os_IsInterruptSourceEnabled_IsEnabled </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>228 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.65 </b></p>
<p><b>OSError_Os_IsInterruptPending_ISRID </b></p>
<p><b>Prototype </b></p>
<p>ISRType <b>OSError_Os_IsInterruptPending_ISRID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ISRType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ISRID of a faulty Os_IsInterruptPending call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-65  </p>
<p>OSError_Os_IsInterruptPending_ISRID </p>
<p><b>5.1.66 </b></p>
<p><b>OSError_Os_IsInterruptPending_IsPending </b></p>
<p><b>Prototype </b></p>
<p>boolean * <b>OSError_Os_IsInterruptPending_IsPending </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>boolean * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IsPending of a faulty Os_IsInterruptPending_IsPending call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-66  </p>
<p>OSError_Os_IsInterruptPending_IsPending </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>229 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.67 </b></p>
<p><b>OSError_CallTrustedFunction_FunctionIndex </b></p>
<p><b>Prototype </b></p>
<p>TrustedFunctionIndexType <b>OSError_CallTrustedFunction_FunctionIndex </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TrustedFunctionIndexType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter FunctionIndex of a faulty CallTrustedFunction call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-67  </p>
<p>OSError_CallTrustedFunction_FunctionIndex </p>
<p><b>5.1.68 </b></p>
<p><b>OSError_CallTrustedFunction_FunctionParams </b></p>
<p><b>Prototype </b></p>
<p>TrustedFunctionParameterRefType <b>OSError_CallTrustedFunction_FunctionParams </b></p>
<p>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TrustedFunctionParameterRefType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter FunctionParams of a faulty CallTrustedFunction call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-68  </p>
<p>OSError_CallTrustedFunction_FunctionParams </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>230 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.69 </b></p>
<p><b>OSError_CallNonTrustedFunction_FunctionIndex </b></p>
<p><b>Prototype </b></p>
<p>Os_NonTrustedFunctionIndexType <b>OSError_CallNonTrustedFunction_FunctionIndex </b></p>
<p>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_NonTrustedFunctionIndexType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter FunctionIndex of a faulty CallTrustedFunction call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-69  </p>
<p>OSError_CallNonTrustedFunction_FunctionIndex </p>
<p><b>5.1.70 </b></p>
<p><b>OSError_CallNonTrustedFunction_FunctionParams </b></p>
<p><b>Prototype </b></p>
<p>Os_NonTrustedFunctionParameterRefType </p>
<p><b>OSError_CallNonTrustedFunction_FunctionParams </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_NonTrustedFunctionParameterRefType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter FunctionParams of a faulty CallNonTrustedFunction call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-70  </p>
<p>OSError_CallNonTrustedFunction_FunctionParams </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>231 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.71 </b></p>
<p><b>OSError_StartScheduleTableRel_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_StartScheduleTableRel_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty StartScheduleTableRel call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-71  </p>
<p>OSError_StartScheduleTableRel_ScheduleTableID </p>
<p><b>5.1.72 </b></p>
<p><b>OSError_StartScheduleTableRel_Offset </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_StartScheduleTableRel_Offset </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Offset of a faulty StartScheduleTableRel call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-72  </p>
<p>OSError_StartScheduleTableRel_Offset </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>232 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.73 </b></p>
<p><b>OSError_StartScheduleTableAbs_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_StartScheduleTableAbs_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty StartScheduleTableAbs call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-73  </p>
<p>OSError_StartScheduleTableAbs_ScheduleTableID </p>
<p><b>5.1.74 </b></p>
<p><b>OSError_StartScheduleTableAbs_Start </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_StartScheduleTableAbs_Start </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Start of a faulty StartScheduleTableAbs call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-74  </p>
<p>OSError_StartScheduleTableAbs_Start </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>233 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.75 </b></p>
<p><b>OSError_StopScheduleTable_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_StopScheduleTable_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty StopScheduleTable call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-75  </p>
<p>OSError_StopScheduleTable_ScheduleTableID </p>
<p><b>5.1.76 </b></p>
<p><b>OSError_NextScheduleTable_ScheduleTableID_From </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_NextScheduleTable_ScheduleTableID_From </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID_From of a faulty NextScheduleTable call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-76  </p>
<p>OSError_NextScheduleTable_ScheduleTableID_From </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>234 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.77 </b></p>
<p><b>OSError_NextScheduleTable_ScheduleTableID_To </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_NextScheduleTable_ScheduleTableID_To </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID_To of a faulty NextScheduleTable call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-77  </p>
<p>OSError_NextScheduleTable_ScheduleTableID_To </p>
<p><b>5.1.78 </b></p>
<p><b>OSError_StartScheduleTableSynchron_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_StartScheduleTableSynchron_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty StartScheduleTableSynchron call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-78  </p>
<p>OSError_StartScheduleTableSynchron_ScheduleTableID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>235 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.79 </b></p>
<p><b>OSError_SyncScheduleTable_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_SyncScheduleTable_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty SyncScheduleTable call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-79  </p>
<p>OSError_SyncScheduleTable_ScheduleTableID </p>
<p><b>5.1.80 </b></p>
<p><b>OSError_SyncScheduleTable_Value </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_SyncScheduleTable_Value </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Value of a faulty SyncScheduleTable call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-80  </p>
<p>OSError_SyncScheduleTable_Value </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>236 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.81 </b></p>
<p><b>OSError_SetScheduleTableAsync_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_SetScheduleTableAsync_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty SetScheduleTableAsync call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-81  </p>
<p>OSError_SetScheduleTableAsync_ScheduleTableID </p>
<p><b>5.1.82 </b></p>
<p><b>OSError_GetScheduleTableStatus_ScheduleTableID </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableType <b>OSError_GetScheduleTableStatus_ScheduleTableID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleTableID of a faulty GetScheduleTableStatus call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-82  </p>
<p>OSError_GetScheduleTableStatus_ScheduleTableID </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>237 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.83 </b></p>
<p><b>OSError_GetScheduleTableStatus_ScheduleStatus </b></p>
<p><b>Prototype </b></p>
<p>ScheduleTableStatusRefType <b>OSError_GetScheduleTableStatus_ScheduleStatus </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ScheduleTableType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ScheduleStatus of a faulty GetScheduleTableStatus call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-83  </p>
<p>OSError_GetScheduleTableStatus_ScheduleStatus </p>
<p> </p>
<p><b>5.1.84 </b></p>
<p><b>OSError_IncrementCounter_CounterID </b></p>
<p><b>Prototype </b></p>
<p>CounterType <b>OSError_IncrementCounter_CounterID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>CounterType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter CounterID of a faulty IncrementCounter call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-84  </p>
<p>OSError_IncrementCounter_CounterID </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>238 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.85 </b></p>
<p><b>OSError_GetCounterValue_CounterID </b></p>
<p><b>Prototype </b></p>
<p>CounterType <b>OSError_GetCounterValue_CounterID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>CounterType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter CounterID of a faulty GetCounterValue call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-85  </p>
<p>OSError_GetCounterValue_CounterID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>239 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.86 </b></p>
<p><b>OSError_GetCounterValue_Value </b></p>
<p><b>Prototype </b></p>
<p>TickRefType <b>OSError_GetCounterValue_Value </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Value of a faulty GetCounterValue call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-86  </p>
<p>OSError_GetCounterValue_Value </p>
<p><b>5.1.87 </b></p>
<p><b>OSError_GetElapsedValue_CounterID </b></p>
<p><b>Prototype </b></p>
<p>CounterType <b>OSError_GetElapsedValue_CounterID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>CounterType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter CounterID of a faulty GetElapsedValue call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-87  </p>
<p>OSError_GetElapsedValue_CounterID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>240 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.88 </b></p>
<p><b>OSError_GetElapsedValue_Value </b></p>
<p><b>Prototype </b></p>
<p>TickRefType <b>OSError_GetElapsedValue_Value </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Value of a faulty GetElapsedValue call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-88  </p>
<p>OSError_GetElapsedValue_Value </p>
<p><b>5.1.89 </b></p>
<p><b>OSError_GetElapsedValue_ElapsedValue </b></p>
<p><b>Prototype </b></p>
<p>TickRefType <b>OSError_GetElapsedValue_ElapsedValue </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ElapsedValue of a faulty GetElapsedValue call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-89  </p>
<p>OSError_GetElapsedValue_ElapsedValue </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>241 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.90 </b></p>
<p><b>OSError_TerminateApplication_Application </b></p>
<p><b>Prototype </b></p>
<p>ApplicationType <b>OSError_TerminateApplication_Application </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ApplicationType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Application of a faulty TerminateApplication call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-90  </p>
<p>OSError_TerminateApplication_Application </p>
<p><b>5.1.91 </b></p>
<p><b>OSError_TerminateApplication_RestartOption </b></p>
<p><b>Prototype </b></p>
<p>RestartType <b>OSError_TerminateApplication_RestartOption </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>RestartType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter RestartOption of a faulty TerminateApplication call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-91  </p>
<p>OSError_TerminateApplication_RestartOption </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>242 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.92 </b></p>
<p><b>OSError_GetApplicationState_Application </b></p>
<p><b>Prototype </b></p>
<p>ApplicationType <b>OSError_GetApplicationState_Application </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ApplicationType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Application of a faulty GetApplicationState call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-92  </p>
<p>OSError_GetApplicationState_Application </p>
<p><b>5.1.93 </b></p>
<p><b>OSError_GetApplicationState_Value </b></p>
<p><b>Prototype </b></p>
<p>ApplicationStateRefType <b>OSError_GetApplicationState_Value </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ApplicationStateRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Value of a faulty GetApplicationState call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-93  </p>
<p>OSError_GetApplicationState_Value </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>243 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.94 </b></p>
<p><b>OSError_GetSpinlock_SpinlockId </b></p>
<p><b>Prototype </b></p>
<p>SpinlockIdType <b>OSError_GetSpinlock_SpinlockId </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>SpinlockIdType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter SpinlockId of a faulty GetSpinlock call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-94  </p>
<p>OSError_GetSpinlock_SpinlockId </p>
<p><b>5.1.95 </b></p>
<p><b>OSError_ReleaseSpinlock_SpinlockId </b></p>
<p><b>Prototype </b></p>
<p>SpinlockIdType <b>OSError_ReleaseSpinlock_SpinlockId </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>SpinlockIdType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter SpinlockId of a faulty ReleaseSpinlock call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-95  </p>
<p>OSError_ReleaseSpinlock_SpinlockId </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>244 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.96 </b></p>
<p><b>OSError_TryToGetSpinlock_SpinlockId </b></p>
<p><b>Prototype </b></p>
<p>SpinlockIdType <b>OSError_TryToGetSpinlock_SpinlockId </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>SpinlockIdType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter SpinlockId of a faulty TryToGetSpinlock call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-96  </p>
<p>OSError_TryToGetSpinlock_SpinlockId </p>
<p><b>5.1.97 </b></p>
<p><b>OSError_TryToGetSpinlock_Success </b></p>
<p><b>Prototype </b></p>
<p>TryToGetSpinlockType const * <b>OSError_TryToGetSpinlock_Success </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TryToGetSpinlockType </p>
<p>const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Success of a faulty TryToGetSpinlock call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-97  </p>
<p>OSError_TryToGetSpinlock_Success </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>245 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.98 </b></p>
<p><b>OSError_ControlIdle_CoreID </b></p>
<p><b>Prototype </b></p>
<p>CoreIdType <b>OSError_ControlIdle_CoreID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>CoreIdType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter CoreID of a faulty ControlIdle call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-98  </p>
<p>OSError_ControlIdle_CoreID </p>
<p> </p>
<p><b>5.1.99 </b></p>
<p><b>OSError_Os_GetExceptionContext_Context </b></p>
<p><b>Prototype </b></p>
<p>Os_ExceptionContextRefType <b>OSError_Os_GetExceptionContext_Context </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_ExceptionContextRefType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Context of a faulty Os_GetExceptionContext call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-99  </p>
<p>OSError_Os_GetExceptionContext_Context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>246 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.100 OSError_Os_SetExceptionContext_Context </b></p>
<p><b>Prototype </b></p>
<p>Os_ExceptionContextRefType <b>OSError_Os_SetExceptionContext_Context </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_ExceptionContextRefType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Context of a faulty Os_SetExceptionContext call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-100  OSError_Os_SetExceptionContext_Context </p>
<p><b>5.1.101 OSError_ControlIdle_IdleMode </b></p>
<p><b>Prototype </b></p>
<p>IdleModeType <b>OSError_ControlIdle_IdleMode </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>IdleModeType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IdleMode of a faulty ControlIdle call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-101  OSError_ControlIdle_IdleMode </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>247 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.102 OSError_IocSend_IN </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocSend_IN </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IN of a faulty IocSend call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-102  OSError_IocSend_IN </p>
<p><b>5.1.103 OSError_IocWrite_IN </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocWrite_IN </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IN of a faulty IocWrite call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-103  OSError_IocWrite_IN </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>248 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.104 OSError_IocSendGroup_IN </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocSendGroup_IN </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IN of a faulty IocSendGroup call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-104  OSError_IocSendGroup_IN </p>
<p><b>5.1.105 OSError_IocWriteGroup_IN </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocWriteGroup_IN </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter IN of a faulty IocWriteGroup call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-105  OSError_IocWriteGroup_IN </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>249 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.106 OSError_IocReceive_OUT </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocReceive_OUT </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter OUT of a faulty IocReceive call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-106  OSError_IocReceive_OUT </p>
<p><b>5.1.107 OSError_IocRead_OUT </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocRead_OUT </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter OUT of a faulty IocRead call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-107  OSError_IocRead_OUT </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>250 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.108 OSError_IocReceiveGroup_OUT </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocReceiveGroup_OUT </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter OUT of a faulty IocReceiveGroup call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-108  OSError_IocReceiveGroup_OUT </p>
<p><b>5.1.109 OSError_IocReadGroup_OUT </b></p>
<p><b>Prototype </b></p>
<p>void const * <b>OSError_IocReadGroup_OUT </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>void const * </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter OUT of a faulty IocReadGroup call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-109  OSError_IocReadGroup_OUT </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>251 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.110 OSError_StartOS_Mode </b></p>
<p><b>Prototype </b></p>
<p>AppModeType <b>OSError_StartOS_Mode </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AppModeType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Mode of a faulty StartOS call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-110  OSError_StartOS_Mode </p>
<p><b>5.1.111 OSError_ActivateTask_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskType <b>OSError_ActivateTask_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty ActivateTask call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-111   OSError_ActivateTask_TaskID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>252 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.112 OSError_ChainTask_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskType <b>OSError_ChainTask_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty ChainTask call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-112  OSError_ChainTask_TaskID </p>
<p><b>5.1.113 OSError_GetTaskID_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskRefType <b>OSError_GetTaskID_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty GetTaskID call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-113  OSError_GetTaskID_TaskID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>253 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.114 OSError_GetTaskState_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskType <b>OSError_GetTaskState_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty GetTaskState call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-114  OSError_GetTaskState_TaskID </p>
<p><b>5.1.115 OSError_GetTaskState_State </b></p>
<p><b>Prototype </b></p>
<p>TaskStateRefType <b>OSError_GetTaskState_State </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskStateRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter State of a faulty GetTaskState call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-115  OSError_GetTaskState_State </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>254 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.116 OSError_SetEvent_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskType <b>OSError_SetEvent_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty SetEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-116  OSError_SetEvent_TaskID </p>
<p><b>5.1.117 OSError_SetEvent_Mask </b></p>
<p><b>Prototype </b></p>
<p>EventMaskType <b>OSError_SetEvent_Mask </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EventMaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Mask of a faulty SetEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-117  OSError_SetEvent_Mask </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>255 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.118 OSError_ClearEvent_Mask </b></p>
<p><b>Prototype </b></p>
<p>EventMaskType <b>OSError_ClearEvent_Mask </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EventMaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Mask of a faulty ClearEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-118  OSError_ClearEvent_Mask </p>
<p><b>5.1.119 OSError_GetEvent_TaskID </b></p>
<p><b>Prototype </b></p>
<p>TaskType <b>OSError_GetEvent_TaskID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter TaskID of a faulty GetEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-119  OSError_GetEvent_TaskID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>256 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.120 OSError_GetEvent_Mask </b></p>
<p><b>Prototype </b></p>
<p>EventMaskRefType <b>OSError_GetEvent_Mask </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EventMaskRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Mask of a faulty GetEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-120  OSError_GetEvent_Mask </p>
<p><b>5.1.121 OSError_WaitEvent_Mask </b></p>
<p><b>Prototype </b></p>
<p>EventMaskType <b>OSError_WaitEvent_Mask </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>EventMaskType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Mask of a faulty WaitEvent call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-121  OSError_WaitEvent_Mask </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>257 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.122 OSError_GetAlarmBase_AlarmID </b></p>
<p><b>Prototype </b></p>
<p>AlarmType <b>OSError_GetAlarmBase_AlarmID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter AlarmID of a faulty GetAlarmBase call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-122  OSError_GetAlarmBase_AlarmID </p>
<p><b>5.1.123 OSError_GetAlarmBase_Info </b></p>
<p><b>Prototype </b></p>
<p>AlarmBaseRefType <b>OSError_GetAlarmBase_Info </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmBaseRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Info of a faulty GetAlarmBase call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-123  OSError_GetAlarmBase_Info </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>258 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.124 OSError_GetAlarm_AlarmID </b></p>
<p><b>Prototype </b></p>
<p>AlarmType <b>OSError_GetAlarm_AlarmID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter AlarmID of a faulty GetAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-124  OSError_GetAlarm_AlarmID </p>
<p><b>5.1.125 OSError_GetAlarm_Tick </b></p>
<p><b>Prototype </b></p>
<p>TickRefType <b>OSError_GetAlarm_Tick </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter Tick of a faulty GetAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-125  OSError_GetAlarm_Tick </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>259 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.126 OSError_SetRelAlarm_AlarmID </b></p>
<p><b>Prototype </b></p>
<p>AlarmType <b>OSError_SetRelAlarm_AlarmID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter AlarmID of a faulty SetRelAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-126  OSError_SetRelAlarm_AlarmID </p>
<p><b>5.1.127 OSError_SetRelAlarm_increment </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_SetRelAlarm_increment </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter increment of a faulty SetRelAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-127  OSError_SetRelAlarm_increment </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>260 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.128 OSError_SetRelAlarm_cycle </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_SetRelAlarm_cycle </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter cycle of a faulty SetRelAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-128  OSError_SetRelAlarm_cycle </p>
<p><b>5.1.129 OSError_SetAbsAlarm_AlarmID </b></p>
<p><b>Prototype </b></p>
<p>AlarmType <b>OSError_SetAbsAlarm_AlarmID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter AlarmID of a faulty SetAbsAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-129  OSError_SetAbsAlarm_AlarmID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>261 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.130 OSError_SetAbsAlarm_start </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_SetAbsAlarm_start </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter start of a faulty SetAbsAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-130  OSError_SetAbsAlarm_start </p>
<p><b>5.1.131 OSError_SetAbsAlarm_cycle </b></p>
<p><b>Prototype </b></p>
<p>TickType <b>OSError_SetAbsAlarm_cycle </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>TickType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter cycle of a faulty SetAbsAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-131  OSError_SetAbsAlarm_cycle </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>262 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.132 OSError_CancelAlarm_AlarmID </b></p>
<p><b>Prototype </b></p>
<p>AlarmType <b>OSError_CancelAlarm_AlarmID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>AlarmType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter AlarmID of a faulty CancelAlarm call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-132  OSError_CancelAlarm_AlarmID </p>
<p><b>5.1.133 OSError_GetResource_ResID </b></p>
<p><b>Prototype </b></p>
<p>ResourceType <b>OSError_GetResource_ResID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ResourceType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ResID of a faulty GetResource call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-133  OSError_GetResource_ResID </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>263 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.134 OSError_ReleaseResource_ResID </b></p>
<p><b>Prototype </b></p>
<p>ResourceType <b>OSError_ReleaseResource_ResID </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>ResourceType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ResID of a faulty ReleaseResource call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-134  OSError_ReleaseResource_ResID </p>
<p><b>5.1.135 OSError_Os_GetUnhandledIrq_InterruptSource </b></p>
<p><b>Prototype </b></p>
<p>Os_InterruptSourceIdRefType <b>OSError_Os_GetUnhandledIrq_InterruptSource </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_InterruptSourceIdRefType </p>
<p>Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter InterruptSource of a faulty Os_GetUnhandledIrq call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-135  OSError_Os_GetUnhandledIrq_InterruptSource </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>264 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.1.136 OSError_Os_GetUnhandledExc_ExceptionSource </b></p>
<p><b>Prototype </b></p>
<p>Os_ExceptionSourceIdRefType <b>OSError_Os_GetUnhandledExc_ExceptionSource </b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_ExceptionSourceIdRefType  Requested parameter value. </p>
<p><b>Functional Description </b></p>
<p>Returns parameter ExceptionSource of a faulty Os_GetUnhandledExc call. </p>
<p><b>Particularities and Limitations </b></p>
<p>Pre-Condition: None </p>
<p>--no details-- </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-136  OSError_Os_GetUnhandledExc_ExceptionSource </p>
<p><b>5.1.137 OSError_BarrierSynchronize_BarrierID </b></p>
<p><b>Prototype </b></p>
<p>Os_BarrierIdType <b>OSError_BarrierSynchronize_BarrierID</b>(void) </p>
<p><b>Parameter </b></p>
<p>void </p>
<p>none </p>
<p><b>Return code </b></p>
<p>Os_BarrierIdType</p>
<p> </p>
<p>Requested parameter value </p>
<p><b>Functional Description </b></p>
<p>Returns parameter BarrierID of a faulty Os_BarrierSynchronize call. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Pre-Condition: None  </p>
<p>Call context </p>
<p>&gt; </p>
<p>ERRHOOK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-137  OSError_BarrierSynchronize_BarrierID </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>265 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2 </b></p>
<p><b>Additional OS services </b></p>
<p>The OS provides the following additional services which are not part of the AUTOSAR OS </p>
<p>specification. </p>
<p><b>5.2.1 </b></p>
<p><b>Os_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>Os_GetVersionInfo </b>(Std_VersionInfoType *versioninfo) </p>
<p><b>Parameter </b></p>
<p>versioninfo [out] </p>
<p>Version information (decimal coded). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>AUTOSAR Get Version Information API. </p>
<p><b>Particularities and Limitations </b></p>
<p>Given object pointer(s) are valid. </p>
<p>Returns the Published information of MICROSAR OS.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>ANY </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>Table 5-138  Os_GetVersionInfo </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>266 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.2 </b></p>
<p><b>Peripheral Access API </b></p>
<p>The  API  consists  of  read,  write  and  bit  manipulating  functions  for  8,  16  and  32  bit </p>
<p>accesses. </p>
<p><b>5.2.2.1 </b></p>
<p><b>Read Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(uint8, OS_CODE) Os_ReadPeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2CONST(uint8, AUTOMATIC, OS_APPL_DATA) Address </p>
<p>) </p>
<p>FUNC(uint16, OS_CODE) Os_ReadPeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2CONST(uint16, AUTOMATIC, OS_APPL_DATA) Address </p>
<p>) </p>
<p>FUNC(uint32, OS_CODE) Os_ReadPeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2CONST(uint32, AUTOMATIC, OS_APPL_DATA) Address </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be read. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>The content of the peripheral register which has been passed in the Address </p>
<p>parameter. </p>
<p>uint16 </p>
<p>uint32 </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the API returns the content of the passed address </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-139  Read Peripheral API </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>267 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osReadPeripheral8(), osReadPeripheral16() </p>
<p>and osReadPeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>268 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.2.2 </b></p>
<p><b>Write Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint8, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint8 Value </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint16, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint16 Value </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint32, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint32 Value </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be written. </p>
<p>Value uint8 </p>
<p>Value which shall be written to the peripheral register. </p>
<p>Value uint16 </p>
<p>Value uint32 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the OS writes the Value into the peripheral register. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-140  Write Peripheral APIs </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>269 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osWritePeripheral8(), osWritePeripheral16() </p>
<p>and osWritePeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>270 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.2.3 </b></p>
<p><b>Bitmask Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint8, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint8 ClearMask, </p>
<p>  uint8 SetMask </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint16, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint16 ClearMask, </p>
<p>  uint16 SetMask </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  P2VAR(uint32, AUTOMATIC, OS_APPL_DATA) Address, </p>
<p>  uint32 ClearMask, </p>
<p>  uint32 SetMask </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be modified. </p>
<p>ClearMask uint8 </p>
<p>The mask for the AND operation. </p>
<p>ClearMask uint16 </p>
<p>ClearMask uint32 </p>
<p>SetMask uint8 </p>
<p>The mask for the OR operation. </p>
<p>SetMask uint16 </p>
<p>SetMask uint32 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the OS performs the following operation: </p>
<p>Address = (Address &amp; ClearMask) | SetMask; </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>271 </p>
<p>based on template version 6.0.1 </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-141  Bitmask Peripheral API </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osModifyPeripheral8(), osModifyPeripheral16() </p>
<p>and osModifyPeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>272 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.3 </b></p>
<p><b>Pre-Start Task </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_EnterPreStartTask(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function schedules and dispatches to the pre-start task. The core is initialized that non-trusted function </p>
<p>calls can be used safely within this task. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Has to be called on a core which is started as an AUTOSAR core. </p>
<p>&gt; </p>
<p>The core which calls this function must have a configured pre-start task. </p>
<p>&gt; </p>
<p>Must only be called once. </p>
<p>&gt; </p>
<p>Must be called prior to </p>
<p>StartOS()</p>
<p> but after </p>
<p>Os_Init()</p>
<p>  </p>
<p>Table 5-142  API Service Os_EnterPreStartTask </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>273 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.4 </b></p>
<p><b>Non-Trusted Functions (NTF) </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_CallNonTrustedFunction( </p>
<p>  Os_NonTrustedFunctionIndexType FunctionIndex, </p>
<p>  Os_NonTrustedFunctionParameterRefType FunctionParams </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>FunctionIndex </p>
<p>The Index of the non-trusted function. </p>
<p>FunctionParams </p>
<p>Pointer to parameters which are passed to the non-trusted function. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_SERVICEID </p>
<p>No function defined for this index. </p>
<p>E_OS_CALLEVEL  </p>
<p>Called from invalid context. (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>The given object belongs to a foreign core. (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>Owner OS application is not accessible. (Service Protection) </p>
<p>E_OS_SYS_NO_NTFSTACK  </p>
<p>No further NTF-Stacks available. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Performs a call to the non-trusted function passed in „</p>
<p>FunctionIndex</p>
<p>“. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The non-trusted function will not be able to return any values. It has no access rights to the data </p>
<p>structure of the caller referenced by the “</p>
<p>FunctionParams</p>
<p>” parameter. </p>
<p>&gt; </p>
<p>This API service may be called with disabled interrupts. </p>
<p>Table 5-143  Call Non-Trusted Function API </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>274 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.5 </b></p>
<p><b>Fast Trusted Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_CallFastTrustedFunction </p>
<p>( </p>
<p>  Os_FastTrustedFunctionIndexType FunctionIndex, </p>
<p>  Os_FastTrustedFunctionParameterRefType FunctionParams </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>FunctionIndex </p>
<p>Index of the function to be called. </p>
<p>FunctionParams </p>
<p>Pointer to the parameters for the function. </p>
<p>If no parameters are provided a NULL pointer has to be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_SERVICEID </p>
<p>No function defined for this index. </p>
<p><b>Functional Description </b></p>
<p>Performs a call to the fast trusted function passed in „</p>
<p>FunctionIndex</p>
<p>“. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called with interrupts disabled </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>275 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.6 </b></p>
<p><b>Interrupt Source API </b></p>
<p><b>5.2.6.1 </b></p>
<p><b>Disable Interrupt Source </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_DisableInterruptSource( </p>
<p>  ISRType ISRID </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS disables the interrupt source by modifying the interrupt controller registers. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only. </p>
<p>Table 5-144  API Service Os_DisableInterruptSource </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Depending on target platform (e.g. ARM platforms), the ISR may still become active </p>
<p>although Os_DisableInterruptSource has returned E_OK. </p>
<p>This may be caused by hardware racing conditions e.g. when the interrupt is requested </p>
<p>immediately before the effect of Os_DisableInterruptSource becomes active. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>276 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.6.2 </b></p>
<p><b>Enable Interrupt Source </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_EnableInterruptSource( </p>
<p>  ISRType ISRID, </p>
<p>  boolean ClearPending </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>ClearPending </p>
<p>Defines whether the pending flag shall be cleared (TRUE) or not (FALSE). </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier ID (EXTENDED status) </p>
<p>E_OS_CALLEVEL  </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_VALUE  </p>
<p>The parameter “ClearPending” is not a boolean value (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS enables the interrupt source by modifying the interrupt controller registers. Additionally it </p>
<p>may clear the interrupt pending flag </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-145  API Service Os_EnableInterruptSource </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>277 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.6.3 </b></p>
<p><b>Clear Pending Interrupt </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_ClearPendingInterrupt( </p>
<p>  ISRType ISRID </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS clears the interrupt pending flag by modifying the interrupt controller registers. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-146  API Service Os_ClearPendingInterrupt </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In order to minimize the risk of spurious interrupts, Os_ClearPendingInterrupt shall be </p>
<p>called only after the ISR (IsrId) has been disabled and before it is enabled again. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The API service tries to clear the pending flag only. The interrupt cause has to be reset </p>
<p>by the application software. Otherwise the flag may be set again immediately after it </p>
<p>has been cleared by the API. This may be the case e.g. with level triggered ISRs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>278 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.6.4 </b></p>
<p><b>Check Interrupt Source Enabled </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_IsInterruptSourceEnabled( </p>
<p>  ISRType ISRID, </p>
<p>  P2VAR(boolean, AUTOMATIC, OS_VAR_NOINIT) IsEnabled </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>IsEnabled </p>
<p>Defines wether the source of the ISR is enabled (TRUE) or not (FALSE) </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given pointer parameter (isEnabled) is NULL (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS checks if the interrupt source is enabled reading the interrupt controller registers and </p>
<p>update the boolean addressed by IsEnabled accordingly </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-147  API Service Os_IsInterruptSourceEnabled </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>279 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.6.5 </b></p>
<p><b>Check Interrupt Pending </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_IsInterruptPending( </p>
<p>  ISRType ISRID, </p>
<p>  P2VAR(boolean, AUTOMATIC, OS_VAR_NOINIT) IsPending </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>IsPending </p>
<p>Defines wether the ISR has been already </p>
<p>requesterd (TRUE) or not (FALSE) </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier </p>
<p>(EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function </p>
<p>(EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the </p>
<p>ISR passed in ISRID (Service Protection) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given pointer parameter (isPending) is NULL </p>
<p>(EXTENDED status) </p>
<p>E_OS_SYS_UNIMPLEMENTED_FUNCTIONALITY </p>
<p>Hardware does not support to check if there are </p>
<p>pending interrupts </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS checks if the ISR has been already requested,  reading the interrupt controller registers </p>
<p>and update the boolean addressed by IsPending accordingly </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-148  API Service Os_IsInterruptPending </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>280 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.7 </b></p>
<p><b>Detailed Error API </b></p>
<p><b>5.2.7.1 </b></p>
<p><b>Get detailed Error </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetDetailedError( </p>
<p>  Os_ErrorInformationRefType ErrorRef </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ErrorRef </p>
<p>Output parameter of type Os_ErrorInformationRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CALLEVEL </p>
<p>Called from invalid context. (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given parameter pointer is NULL. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Returns error information of the last error occurred on the local core. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The ErrorRef output parameter is a struct which holds the 8 bit AUTOSAR error code, the detailed error </p>
<p>code and the service ID of the causing API service. </p>
<p>Table 5-149  API Service Os_GetDetailedError </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>281 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.7.2 </b></p>
<p><b>Unhandled Interrupt Requests </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetUnhandledIrq( </p>
<p>  Os_InterruptSourceIdRefType InterruptSource </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>InterruptSource </p>
<p>Output parameter of type Os_InterruptSourceIdRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CORE </p>
<p>Called from a non-AUTOSAR core (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Null pointer passed as argument (EXTENDED status) </p>
<p>E_OS_STATE </p>
<p>No unhandled interrupt reported since start up (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>In case of an unhandled interrupt request the triggering interrupt source can be distinguished with this </p>
<p>service. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The return value of this function may be interpreted differently for different controller families. </p>
<p>Table 5-150  API Service Os_GetUnhandledIrq </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>282 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.7.3 </b></p>
<p><b>Unhandled Exception Requests </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetUnhandledExc( </p>
<p>  Os_ExceptionSourceIdRefType ExceptionSource </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ExceptionSource </p>
<p>Output parameter of type Os_ExceptionSourceIdRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CORE </p>
<p>Called from a non-AUTOSAR core (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Null pointer passed as argument (EXTENDED status) </p>
<p>E_OS_STATE </p>
<p>No unhandled exception reported since start up. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>In case of an unhandled exception request the triggering exception source can be distinguished with this </p>
<p>service. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The return value of this function may be interpreted differently for different controller families. </p>
<p>Table 5-151  API Service Os_GetUnhandledExc </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>283 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.8 </b></p>
<p><b>Stack Usage API </b></p>
<p>All Service API functions which calculate stack usage are working in the same way. </p>
<p><b>&gt; </b></p>
<p>The service performs error checks: </p>
<p><b>&gt; </b></p>
<p>validity of passed parameters </p>
<p><b>&gt; </b></p>
<p>existence of OS Hook routine (if hook stacks are queried) </p>
<p><b>&gt; </b></p>
<p>cross core checks (when stack sizes are queried of stacks which are located on a </p>
<p>foreign core) </p>
<p><b>&gt; </b></p>
<p>if one of these checks fails, the OS initiates error handling (ErrorHook() is called) </p>
<p><b>&gt; </b></p>
<p>Calculates the maximum stack usage of the queried stack since call of StartOS() </p>
<p><b>&gt; </b></p>
<p>Returns the stack usage in bytes </p>
<p><b>&gt; </b></p>
<p>Stack Usage API services may be called from any context </p>
<p><b>&gt; </b></p>
<p>Stack Usage API services may be used cross core </p>
<p><b>Stack usage service API Prototypes </b></p>
<p>Parameter </p>
<p>FUNC(uint32, OS_CODE) Os_GetTaskStackUsage (TaskType TaskID) </p>
<p>Task ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetISRStackUsage (ISRType IsrID) </p>
<p>ISR ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetKernelStackUsage (CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetStartupHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetErrorHookStackUsage (CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetShutdownHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetProtectionHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>Table 5-152  Overview: Stack Usage Functions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Any stack usage function must not be used cross core with interrupts disabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>284 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.9 </b></p>
<p><b>RTE Interrupt API </b></p>
<p>MICROSAR OS provides optimized interrupt en-/disable functions for exclusive usage by </p>
<p>the RTE module of Vector. </p>
<p> </p>
<p><b>API Name </b></p>
<p><b>Alias (for backward </b></p>
<p><b>compatibility) </b></p>
<p><b>Comment </b></p>
<p>Os_DisableLevelAM() </p>
<p>osDisableLevelAM() </p>
<p>non nestable service to disable all category </p>
<p>2 interrupts callable from any mode </p>
<p>Os_DisableLevelKM() </p>
<p>osDisableLevelKM() </p>
<p>non nestable service to disable all category </p>
<p>2 interrupts callable from kernel mode </p>
<p>Os_DisableLevelUM() </p>
<p>osDisableLevelUM() </p>
<p>non nestable service to disable all category </p>
<p>2 interrupts callable from user mode </p>
<p>Os_EnableLevelAM() </p>
<p>osEnableLevelAM() </p>
<p>non nestable service to enable all category </p>
<p>2 interrupts callable from any mode </p>
<p>Os_EnableLevelKM() </p>
<p>osEnableLevelKM() </p>
<p>non nestable service to enable all category </p>
<p>2 interrupts callable from kernel mode </p>
<p>Os_EnableLevelUM() </p>
<p>osEnableLevelUM() </p>
<p>non nestable service to enable all category </p>
<p>2 interrupts callable from user mode </p>
<p>Os_DisableGlobalAM() </p>
<p>osDisableGlobalAM() </p>
<p>non nestable service to disable all interrupts </p>
<p>callable from any mode </p>
<p>Os_DisableGlobalKM() </p>
<p>osDisableGlobalKM() </p>
<p>non nestable service to disable all interrupts </p>
<p>callable from kernel mode </p>
<p>Os_DisableGlobalUM() </p>
<p>osDisableGlobalUM() </p>
<p>non nestable service to disable all interrupts </p>
<p>callable from user mode </p>
<p>Os_EnableGlobalAM() </p>
<p>osEnableGlobalAM() </p>
<p>non nestable service to enable all interrupts </p>
<p>callable from any mode </p>
<p>Os_EnableGlobalKM() </p>
<p>osEnableGlobalKM() </p>
<p>non nestable service to enable all interrupts </p>
<p>callable from kernel mode </p>
<p>Os_EnableGlobalUM() </p>
<p>osEnableGlobalUM() </p>
<p>non nestable service to enable all interrupts </p>
<p>callable from user mode </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>RTE interrupt handling functions should not be used by the application and are listed </p>
<p>here to avoid naming collisions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>285 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.10 </b></p>
<p><b>Time Conversion Macros </b></p>
<p>Based  on  counter  configuration  attributes  conversion  macros  are  generated  which  are </p>
<p>capable to convert from time into counter ticks and vice versa. </p>
<p>There are a set of conversion macros for each configured OS counter </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The conversion macros embody multiplication operations which may lead to a data </p>
<p>type overflow. The macros are not capable to detect these overflows </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Although the results of the macros are mathematically rounded the result will still be an </p>
<p>integer (e.g. results smaller than 0.5 are used as 0). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>5.2.10.1 </b></p>
<p><b>Convert from Time into Counter Ticks </b></p>
<p><b>OS_NS2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in nanoseconds </p>
<p><b>OS_US2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in microseconds </p>
<p><b>OS_MS2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in milliseconds </p>
<p><b>OS_SEC2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in seconds </p>
<p>Table 5-153  Conversion Macros from Time to Counter Ticks </p>
<p><b>5.2.10.2 </b></p>
<p><b>Convert from Counter Ticks into Time </b></p>
<p><b>OS_TICKS2NS_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in nanoseconds </p>
<p><b>OS_TICKS2US_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in microseconds </p>
<p><b>OS_TICKS2MS_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in milliseconds </p>
<p><b>OS_TICKS2SEC_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in seconds </p>
<p>Table 5-154  Conversion Macros from Counter Ticks to Time </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>286 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.11 </b></p>
<p><b>OS Initialization </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_Init(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function performs all the basic OS initialization which includes </p>
<p>&gt; </p>
<p>Variable initialization </p>
<p>&gt; </p>
<p>Interrupt controller initialization </p>
<p>&gt; </p>
<p>System MPU initialization in SC3 and SC4 systems (if supported by platform) </p>
<p>&gt; </p>
<p>Synchronization barriers in multi core systems </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>A function call to this service must be available on all available cores (even for cores which are intended </p>
<p>to be a non-AUTOSAR core) </p>
<p>&gt; </p>
<p>After call of </p>
<p>Os_Init()</p>
<p> the AUTOSAR interrupt API may be used. </p>
<p>&gt; </p>
<p>After Call of </p>
<p>Os_Init() </p>
<p>the API GetCoreID may be used. </p>
<p>&gt; </p>
<p>Pre-Condition: </p>
<p><b>&gt; </b></p>
<p>Os_Init may only be called if the interrupts are globally disabled. </p>
<p><b>&gt; </b></p>
<p>Either disable the interrupts by using the global flag or, in case of Cortex M platform, disable </p>
<p>the interrupts by setting the highest possible interrupt level (BASEPRI register). </p>
<p>Table 5-155  API Service Os_Init </p>
<p> </p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_InitMemory(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>&gt; </p>
<p>This is an API function which is provided within all BSWs of Vector. It initializes variables of the BSW. </p>
<p>Within the OS module this function is currently empty </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>This service must be called on all available cores (even for cores which are intended to be a non-</p>
<p>AUTOSAR core) </p>
<p>Table 5-156  API Service Os_InitMemory </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>287 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12 </b></p>
<p><b>Timing Hooks </b></p>
<p>Implementation of all timing hooks must conform to the following guidelines: </p>
<p><b>&gt; </b></p>
<p>They are expected to be implemented as a macro. </p>
<p><b>&gt; </b></p>
<p>Reentrancy is possible on multicore systems with different caller core IDs. </p>
<p><b>&gt; </b></p>
<p>Calls of any operating system API functions are prohibited within the hooks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All hooks are called from within an OS API service. Interrupts are disabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>5.2.12.1 </b></p>
<p><b>Timing Hooks for Activation </b></p>
<p><b>5.2.12.1.1 </b></p>
<p><b>Task Activation </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_ACTIVATION(TaskId, DestCoreId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which is activated </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task is activated </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the activation (has called ActivateTask(), has </p>
<p>called ChainTask() or has performed an alarm/schedule table action to activate a </p>
<p>task) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has successfully performed the activation of TaskId on </p>
<p>the destination core. On single core systems both core IDs are identical. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Due to internal implementation </p>
<p>DestCoreId</p>
<p> and </p>
<p>CallerCoreId</p>
<p> are always the same. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>288 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.1.2 </b></p>
<p><b>Task Activation Exeeding Limit </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_ACTIVATION_LIMIT(TaskId, DestCoreId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which is activated </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task is activated </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the activation (has called ActivateTask(), has </p>
<p>called ChainTask() or has performed an alarm/schedule table action to activate a </p>
<p>task) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has failed the activation of TaskId on the destination </p>
<p>core because number of activations exceeds the limit. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Due to internal implementation </p>
<p>DestCoreId</p>
<p> and </p>
<p>CallerCoreId</p>
<p> are always the same. </p>
<p> </p>
<p> </p>
<p><b>5.2.12.1.3 </b></p>
<p><b>Set Event </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_SETEVENT(TaskId, EventMask, StateChanged, </p>
<p>DestCoreId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which receives this event </p>
<p>EventMask </p>
<p>A bit mask with the events which shall be set </p>
<p>StateChanged </p>
<p>TRUE: The task state has changed from WAITING to READY  </p>
<p>FALSE: The task state hasn’t changed </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task receives the event </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the event setting (has called SetEvent() or </p>
<p>performed an alarm/schedule table action to set an event) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has successfully performed the event setting on the </p>
<p>destination core. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Due to internal implementation </p>
<p>DestCoreId</p>
<p> and </p>
<p>CallerCoreId</p>
<p> are always the same. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>289 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.1.4 </b></p>
<p><b>Wait Event Not Waiting  </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_WAITEVENT_NOWAIT(TaskId, EventMask, DestCoreId, </p>
<p>CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which is waiting for the event </p>
<p>EventMask </p>
<p>A bit mask with the events for which the task is waiting </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task is waiting for the event </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the wait event (has called WaitEvent()) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has successfully performed the wait event call on the </p>
<p>destination core and the events waiting are already set and calling task stays in state RUNNING. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Due to internal implementation </p>
<p>DestCoreId</p>
<p> and </p>
<p>CallerCoreId</p>
<p> are always the same. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>290 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.1.5 </b></p>
<p><b>Timing Hook for Context Switch </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_SCHEDULE(FromThreadId, FromThreadReason, </p>
<p>ToThreadId, ToThreadReason, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>FromThreadId </p>
<p>Identifier of the thread (task, ISR) which has run on the caller core before the </p>
<p>switch took place </p>
<p>FromThreadReason </p>
<p>OS_VTHP_TASK_TERMINATION </p>
<p>&gt; </p>
<p>The thread is a task, which has just been terminated. </p>
<p>OS_VTHP_ISR_END </p>
<p>&gt; </p>
<p>The thread is an ISR, which has reached its end. </p>
<p>OS_VTHP_TASK_WAITEVENT </p>
<p>&gt; </p>
<p>The thread is a task, which waits for an event. </p>
<p>OS_VTHP_TASK_WAITSEMA </p>
<p>&gt; </p>
<p>The thread is a task, which waits for the release of a semaphore. </p>
<p>OS_VTHP_THREAD_PREEMPT </p>
<p>&gt; </p>
<p>The thread is interrupted by another one, which has higher priority. </p>
<p>ToThreadId </p>
<p>The identifier of the thread, which runs from now on </p>
<p>ToThreadReason </p>
<p>OS_VTHP_TASK_ACTIVATION </p>
<p>&gt; </p>
<p>The thread is a task, which was activated. </p>
<p>OS_VTHP_ISR_START </p>
<p>&gt; </p>
<p>The thread is an ISR, which now starts execution. </p>
<p>OS_VTHP_TASK_SETEVENT </p>
<p>&gt; </p>
<p>The thread is a task, which has just received an event it was </p>
<p>waiting for. It resumes execution right behind the call of </p>
<p>WaitEvent(). </p>
<p>OS_VTHP_TASK_GOTSEMA </p>
<p>&gt; </p>
<p>The thread is a task, which has just got the semaphore it was </p>
<p>waiting for. </p>
<p>OS_VTHP_THREAD_RESUME: </p>
<p>&gt; </p>
<p>The thread is a task or ISR, which was preempted before and </p>
<p>becomes running again as all higher priority tasks and ISRs do not </p>
<p>run anymore. </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the thread switch </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core in case it performs a thread switch (from one task or  </p>
<p>ISR to another task or ISR). On single core systems both core IDs are always identical. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>None </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>291 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2 </b></p>
<p><b>Timing Hooks for Locking Purposes </b></p>
<p><b>5.2.12.2.1 </b></p>
<p><b>Get Resource </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_RES(ResId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>ResId </p>
<p>Identifier of the resource which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetResorce() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a successful call of the API function GetResource(). The priority of the calling </p>
<p>task or ISR has been increased so that other tasks and ISRs on the same core may need to wait until they </p>
<p>can be executed. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p><b>5.2.12.2.2 </b></p>
<p><b>Release Resource </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_RES(ResId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>ResId </p>
<p>Identifier of the resource which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where ReleaseResorce() was called </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a successful call of the API function ReleaseResource(). The priority of the </p>
<p>calling task or ISR has been decreased so that other tasks and ISRs on the same core may become </p>
<p>running as a result. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>292 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2.3 </b></p>
<p><b>Request Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REQ_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been requested </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetSpinlock() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on any attempt to get a spinlock. The calling task or ISR may end up in entering a </p>
<p>busy waiting loop. In such case other tasks or ISRs of lower priority have to wait until this task or ISR has </p>
<p>taken and released the spinlock. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.2.12.2.4 </b></p>
<p><b>Request Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REQ_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been requested </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock was requested </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on any attempt to get a spinlock for the OS itself. The OS may end up in entering a </p>
<p>busy waiting loop. In such case other program parts on this core have to wait until the OS has taken and </p>
<p>released the spinlock. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>293 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2.5 </b></p>
<p><b>Get Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetSpinlock() or TryToGetSpinlock() were called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook whenever a spinlock has successfully been taken. </p>
<p>If a previosly attempt of getting the spinlock  was not successful immediately (entered busy waiting loop), </p>
<p>this hook means that the core leaves the busy waiting loop. </p>
<p>From now on no other thread may get the spinlock until the current task or ISR has released it. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.2.12.2.6 </b></p>
<p><b>Get Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock has been taken </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook whenever a spinlock has successfully been taken by the OS itself. </p>
<p>If a previosly attempt of getting the spinlock  was not successful immediately (entered busy waiting loop), </p>
<p>this hook means that the core leaves the busy waiting loop. </p>
<p>From now on no other thread may get the spinlock until the OS has released it. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>294 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2.7 </b></p>
<p><b>Release Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where ReleaseSpinlock() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a release of a spinlock. Other tasks and ISR may take the spinlock now. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.2.12.2.8 </b></p>
<p><b>Release Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock has been released </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a release of a spinlock. Other tasks and ISR may take the spinlock now. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>295 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2.9 </b></p>
<p><b>Disable Interrupts </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_DISABLEDINT(IntLockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>IntLockId </p>
<p>OS_VTHP_CAT2INTERRUPTS: </p>
<p>Interrupts have been disabled by means of the current interrupt level. That </p>
<p>interrupt level has been changed in order to disable all category 2 interrupts, </p>
<p>which also prevents task switch and alarm/schedule table management. </p>
<p>OS_VTHP_ALLINTERRUPTS: </p>
<p>Interrupts have been disabled by means of the global interrupt enable/disable </p>
<p>flag. Additionally to the effects described above, also category 1 interrupts are </p>
<p>disabled. </p>
<p>CallerCoreId </p>
<p>Identifier of the core where interrupts are disabled </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook if the application has called an API function to disable interrupts. </p>
<p>The parameter IntLockId describes whether category 1 interrupts may still occur. Mind that the two types of </p>
<p>interrupt locking (as described by the IntLockId) are independent from each other so that the hook may be </p>
<p>called twice before the hook OS_VTH_ENABLEDINT is called, dependent on the application. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for operating system internal interrupt locks </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>296 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.12.2.10 Enable Interrupts </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_ENABLEDINT(IntLockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>IntLockId </p>
<p>OS_VTHP_CAT2INTERRUPTS </p>
<p>&gt; </p>
<p>Interrupts had been disabled by means of the current interrupt level </p>
<p>until this hook was called. The OS releases this lock right after the </p>
<p>hook has returned. </p>
<p>OS_VTHP_ALLINTERRUPTS </p>
<p>&gt; </p>
<p>Interrupts had been disabled by means of the global interrupt </p>
<p>enable/disable flag before this hook was called. The OS releases this </p>
<p>lock right after the hook has returned. </p>
<p>CallerCoreId </p>
<p>Identifier of the core where interrupts are disabled </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook if the application has called an API function to enable interrupts. Mind that the two </p>
<p>types of interrupt locking (as described by the IntLockId) are independent from each other so that interrupts </p>
<p>may still be disabled by means of the other locking type after this hook has returned. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for operating system internal interrupt locks </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>297 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.13 </b></p>
<p><b>PanicHook </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_PANICHOOK_CODE) Os_PanicHook(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Called upon kernel panic mode. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Trusted access rights </p>
<p>&gt; </p>
<p>Interrupts are disabled </p>
<p>&gt; </p>
<p>No OS API service calls are allowed </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>298 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.14 </b></p>
<p><b>Barriers </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_BarrierSynchronize( </p>
<p>  Os_BarrierIdType BarrierID </p>
<p>)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>BarrierID</p>
<p> </p>
<p>The barrier to which rhe task shall be synchronized. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error </p>
<p>E_OS_ID </p>
<p>Invalid BarrierID (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Called from invalid context (EXTENDED status) </p>
<p>E_OS_SYS_NO_BARRIER_PARTICIPANT  &gt; </p>
<p>The given barrier is not configured for the local core </p>
<p>(EXTENDED status) </p>
<p>&gt; </p>
<p>Task is not configured to participate the barrier </p>
<p>(EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Synchronize the calling task at the barrier given in &quot;BarrierID&quot;.  </p>
<p>The calling task is blocked until all other participating tasks call this API with the same &quot;BarrierID&quot;. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p>Call context </p>
<p>&gt; </p>
<p>Task </p>
<p>Table 5-157  Barriers </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>299 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.15 </b></p>
<p><b>Exception Context Manipulation </b></p>
<p><b>5.2.15.1 </b></p>
<p><b>Os_GetExceptionContext </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetExceptionContext( </p>
<p>  Os_ExceptionContextRefType Context </p>
<p>)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>Context</p>
<p> </p>
<p>Current exception context. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error </p>
<p>E_OS_PARAM_POINTER </p>
<p>given pointer is a NULL_PTR (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Called from invalid context (EXTENDED status) </p>
<p>E_OS_SYS_UNIMPLEMENTED_FUNCTIONALITY  Context manipulation is not supported on this </p>
<p>hardware (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Getter function for the exception context. </p>
<p>Returns the context structure of the thread interrupted by an exception. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p>Call context </p>
<p>&gt; </p>
<p>ProtectionHook </p>
<p>Table 5-158  Os_GetExceptionContext </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>300 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.2.15.2 </b></p>
<p><b>Os_SetExceptionContext </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_SetExceptionContext( </p>
<p>  Os_ExceptionContextRefType Context </p>
<p>)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>Context</p>
<p> </p>
<p>Context to set. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error </p>
<p>E_OS_PARAM_POINTER </p>
<p>given pointer is a NULL_PTR (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Called from invalid context (EXTENDED status) </p>
<p>E_OS_SYS_UNIMPLEMENTED_FUNCTIONALITY  Context manipulation is not supported on this </p>
<p>hardware (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Setter function for the exception context. </p>
<p>Writes the given context into the exception context structure. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p>Call context </p>
<p>&gt; </p>
<p>ProtectionHook </p>
<p>Table 5-159  Os_SetExceptionContext </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>301 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.3 </b></p>
<p><b>Calling Context Overview </b></p>
<p>The  following </p>
<p>table </p>
<p>gives </p>
<p>an </p>
<p>overview </p>
<p>about </p>
<p>the </p>
<p>valid </p>
<p>context </p>
<p>for </p>
<p>MICROSAR </p>
<p>OS </p>
<p>additional API service calls. </p>
<p><b>Calling Context </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>API Service </b></p>
<p>Task </p>
<p>Category 1 ISR </p>
<p>Category 2 ISR </p>
<p>Error Hook </p>
<p>PreTask Hook </p>
<p>PostTask Hook </p>
<p>Startup Hook </p>
<p>Shutdown Hook </p>
<p>Alarm Callback </p>
<p>Protection Hook </p>
<p>Before Start of OS </p>
<p>Pre-Start Task </p>
<p>IOC callbacks </p>
<p>Peripheral Access APIs </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_EnterPreStartTask </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p>Os_CallNonTrustedFunction </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_DisableInterruptSource </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_EnableInterruptSource </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_ClearPendingInterrupt </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetDetailedError </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetUnhandledIrq </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetUnhandledExc </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Stack Usage APIs </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Time Conversion Macros </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_Init </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p>CheckISRMemoryAccess </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>CheckTaskMemoryAccess </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>CallTrustedFunction </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_CallFastTrustedFunction </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_BarrierSynchronize </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetExceptionContext </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_SetExceptionContext </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 5-160  Calling Context Overview </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>302 </p>
<p>based on template version 6.0.1 </p>
<p><b>6 </b></p>
<p><b>Configuration </b></p>
<p>MICROSAR OS is configured with Vectors “DaVinci Configurator”. </p>
<p>The descriptions of all OS configuration attributes are described with tool tips within  the </p>
<p>configuration tool. </p>
<p>They can easily be look up during configuration of the OS component. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The configuration with OIL (OSEK implementation language) is not supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>303 </p>
<p>based on template version 6.0.1 </p>
<p><b>7 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>Non-trusted function (NTF) </p>
<p>A non-trusted function is a functional service provided by a non-</p>
<p>trusted OS application. </p>
<p>It runs in the non-privileged mode of the processor with restricted </p>
<p>memory rights. </p>
<p>Application </p>
<p>Any software parts that uses the OS. This may include other </p>
<p>software modules or customer software (don’t confuse this with the </p>
<p>OS-application object). </p>
<p>Pre-start task </p>
<p>An OS task which may run before StartOS has been called. Within </p>
<p>the pre-start task the usage of non-trusted functions is allowed. </p>
<p>OS-application </p>
<p>An OS object of type application. </p>
<p>Category 2 Lock Level </p>
<p>The priority of the highest category 2 ISR </p>
<p>Category 1 Lock Level </p>
<p>The priority of the highest category 1 ISR </p>
<p>TP Lock Level </p>
<p>The priority the timing protection interrupt </p>
<p>X-Signal </p>
<p>MICROSAR OS mechanism which realizes cross core service APIs. </p>
<p>Kernel Panic </p>
<p>An inconsistent state of the OS results in kernel panic mode. The </p>
<p>OS does not know how to proceed correctly. It goes into freeze as </p>
<p>fast as possible (interrupts are disabled, the panic hook is called </p>
<p>and afterwards an endless loop is entered). </p>
<p>Thread </p>
<p>Umbrella Term for OS Task, OS hooks and OS ISR objects </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2017 Vector Informatik GmbH </p>
<p>Version 2.12.0 </p>
<p>304 </p>
<p>based on template version 6.0.1 </p>
<p><b>8 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b> News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
</body>
</html>
{% endraw %}