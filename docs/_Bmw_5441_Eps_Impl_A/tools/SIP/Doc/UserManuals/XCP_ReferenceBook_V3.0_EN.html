---
layout: default
title: XCP_ReferenceBook_V3.0_EN
nav_order: 120
parent: Component Implementation
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p><b>Andreas Patzer | Rainer Zaiser</b></p>
<p><b>XCP – The Standard Protocol</b></p>
<p>for ECU Development</p>
<p><b>Fundamentals and Application Areas</b></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Andreas Patzer | Rainer Zaiser</b></p>
<p><b>XCP – The Standard Protocol for ECU Development</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Date December 2016</p>
<p>Reproduction only with expressed permission from </p>
<p>Vector Informatik GmbH, Ingersheimer Str. 24, 70499 Stuttgart, Germany</p>
<p>© 2016 by Vector Informatik GmbH. All rights reserved. This book is only intended for personal use, but not </p>
<p>for technical or commercial use. It may not be used as a basis for contracts of any kind. All information in this </p>
<p>book was compiled with the greatest possible care, but Vector Informatik does not assume any guarantee or </p>
<p>warranty whatsoever for the correctness of the information it contains. The liability of Vector Informatik is </p>
<p>excluded, except for malicious intent or gross negligence, to the extent that laws do not make it legally liable. </p>
<p>  </p>
<p>Information contained in this book may be protected by copyright and / or patent rights. Product names of </p>
<p>software, hardware and other product names that are used in this book may be registered brands or otherwise </p>
<p>protected by branding laws, regardless of whether or not they are identified as registered brands.</p>
<h1 style="page-break-before:always; "></h1>
<p><b>XCP</b></p>
<p><b>The Standard Protocol</b></p>
<p><b>for ECU Development</b></p>
<p><b>Fundamentals and Application Areas</b></p>
<p>Andreas Patzer, Rainer Zaiser </p>
<p>Vector Informatik GmbH</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Table of Contents</b></p>
<p><b>Introduction </b>...........................................................................................................................................<b> 7</b></p>
<p><b>1 </b></p>
<p><b>Fundamentals of the XCP Protocol </b>...........................................................................................<b>13</b></p>
<p><b>1.1 </b></p>
<p><b>XCP Protocol Layer </b>................................................................................................................<b> 19</b></p>
<p><b>  </b></p>
<p>1.1.1 </p>
<p>Identification Field ........................................................................................................21</p>
<p>  </p>
<p>1.1.2 </p>
<p>Timestamp .....................................................................................................................21</p>
<p>  </p>
<p>1.1.3 </p>
<p>Data Field ...................................................................................................................... 22</p>
<p><b>1.2 </b></p>
<p><b>Exchange of CTOs </b>..................................................................................................................<b> 22</b></p>
<p>  </p>
<p>1.2.1 </p>
<p>XCP Command Structure .......................................................................................... 22</p>
<p>  </p>
<p>1.2.2 </p>
<p>CMD ................................................................................................................................ 25</p>
<p>  </p>
<p>1.2.3 </p>
<p>RES .................................................................................................................................. 28</p>
<p>  </p>
<p>1.2.4 </p>
<p>ERR .................................................................................................................................. 28</p>
<p>  </p>
<p>1.2.5 </p>
<p>EV .................................................................................................................................... 29</p>
<p>  </p>
<p>1.2.6 </p>
<p>SERV ............................................................................................................................... 29</p>
<p>  </p>
<p>1.2.7 </p>
<p>Calibrating Parameters in the Slave ....................................................................... 29</p>
<p><b>1.3 </b></p>
<p><b>Exchanging DTOs – Synchronous Data Exchange </b>.........................................................<b> 32</b></p>
<p>  </p>
<p>1.3.1 </p>
<p>Measurement Methods: Polling versus DAQ ......................................................... 33</p>
<p>  </p>
<p>1.3.2 </p>
<p>DAQ Measurement Method ...................................................................................... 34</p>
<p>  </p>
<p>1.3.3 </p>
<p>STIM Calibration Method ........................................................................................... 42</p>
<p>  </p>
<p>1.3.4 </p>
<p>XCP Packet Addressing for DAQ and STIM ........................................................... 43</p>
<p>  </p>
<p>1.3.5 </p>
<p>Bypassing = DAQ + STIM ........................................................................................... 45</p>
<p>  </p>
<p>1.3.6 </p>
<p>Time Correlation and Synchronization ................................................................... 45</p>
<p><b>1.4 </b></p>
<p><b>XCP Transport Layers </b>...........................................................................................................<b> 49</b></p>
<p>  </p>
<p>1.4.1 </p>
<p>CAN ................................................................................................................................. 49</p>
<p>  </p>
<p>1.4.2 </p>
<p>CAN FD .......................................................................................................................... 52</p>
<p>  </p>
<p>1.4.3 </p>
<p>FlexRay ........................................................................................................................... 54</p>
<p>  </p>
<p>1.4.4 </p>
<p>Ethernet ......................................................................................................................... 57</p>
<p>  </p>
<p>1.4.5 </p>
<p>SxI .................................................................................................................................... 59</p>
<p>  </p>
<p>1.4.6 </p>
<p>USB ................................................................................................................................ 60</p>
<p>  </p>
<p>1.4.7 </p>
<p>LIN .................................................................................................................................. 60</p>
<p><b>1.5 </b></p>
<p><b>XCP Services </b>............................................................................................................................<b> 61</b></p>
<p>  </p>
<p>1.5.1 </p>
<p>Memory Page Swapping .............................................................................................61</p>
<p>  </p>
<p>1.5.2 </p>
<p>Saving Memory Pages – Data Page Freezing ....................................................... 63</p>
<p>  </p>
<p>1.5.3 </p>
<p>Flash Programming ..................................................................................................... 63</p>
<p>  </p>
<p>1.5.4 </p>
<p>Automatic Detection of the Slave ........................................................................... 65</p>
<p>  </p>
<p>1.5.5 </p>
<p>Block Transfer Mode for Upload, Download and Flashing .................................66</p>
<p>  </p>
<p>1.5.6 </p>
<p>Cold Start Measurement ........................................................................................... 67</p>
<p>  </p>
<p>1.5.7 </p>
<p>Security Mechanisms with XCP ................................................................................68</p>
<h1 style="page-break-before:always; "></h1>
<p><b>2 </b></p>
<p><b>ECU Description File A2L </b>.............................................................................................................<b>71</b></p>
<p><b>2.1 </b></p>
<p><b>Setting Up an A2L File for an XCP Slave </b>.........................................................................<b> 74</b></p>
<p><b>2.2  Manually Creating an A2L File </b>............................................................................................<b> 75</b></p>
<p><b>2.3  A2L Contents versus ECU Implementation </b>.....................................................................<b> 76</b></p>
<p><b>3 </b></p>
<p><b>Calibration Concepts </b>...................................................................................................................<b> 79</b></p>
<p><b>3.1 </b></p>
<p><b>Parameters in Flash </b>..............................................................................................................<b> 80</b></p>
<p><b>3.2  Parameters in RAM </b>................................................................................................................<b>82</b></p>
<p><b>3.3  Flash Overlay </b>...........................................................................................................................<b>84</b></p>
<p><b>3.4  Dynamic Flash Overlay Allocation </b>.....................................................................................<b>85</b></p>
<p><b>3.5  RAM Pointer Based Calibration Concept per AUTOSAR </b>.............................................<b>86</b></p>
<p>  </p>
<p>3.5.1 </p>
<p>Single Pointer Concept ...............................................................................................86</p>
<p>  </p>
<p>3.5.2 </p>
<p>Double Pointer Concept .............................................................................................88</p>
<p><b>3.6  Flash Pointer Based Calibration Concept </b>.......................................................................<b>89</b></p>
<p><b>4 </b></p>
<p><b>Application Areas of XCP </b>............................................................................................................<b> 91</b></p>
<p> </p>
<p><b>4.1 </b></p>
<p><b>Model in the Loop (MIL) </b>.......................................................................................................<b> 93</b></p>
<p><b>4.2  Software in the Loop (SIL) </b>..................................................................................................<b> 94</b></p>
<p><b>4.3  Hardware in the Loop (HIL) </b>.................................................................................................<b>95</b></p>
<p><b>4.4  Rapid Control Prototyping (RCP) </b>......................................................................................<b> 97</b></p>
<p><b>4.5  Bypassing </b>..................................................................................................................................<b>98</b></p>
<p><b>4.6  Shortening Iteration Cycles with Virtual ECUs </b>...........................................................<b> 101</b></p>
<p><b>5 </b></p>
<p><b>Example of an XCP Implementation </b>......................................................................................<b>105</b></p>
<p> </p>
<p><b>5.1 </b></p>
<p><b>Description of Functions </b>....................................................................................................<b>108</b></p>
<p><b>5.2  Parameterization of the Driver </b>........................................................................................<b> 110</b></p>
<p><b>6 </b></p>
<p><b>Protocol Development Overview </b>..............................................................................................<b>111</b></p>
<p> </p>
<p><b>6.1 </b></p>
<p><b>XCP Version 1.1 (2008) </b>.........................................................................................................<b> 112</b></p>
<p><b>6.2  XCP Version 1.2 (2013) </b>..........................................................................................................<b> 112</b></p>
<p><b>6.3  XCP Version 1.3 (2015)</b>..........................................................................................................<b> 113</b></p>
<p><b>The Authors</b>.....................................................................................................................................<b> 114</b></p>
<p><b>Table of Abbreviations and Acronyms </b>.....................................................................................<b>116</b></p>
<p><b>Literature </b>........................................................................................................................................<b> 117</b></p>
<p><b>Web Addresses</b>...............................................................................................................................<b> 117</b></p>
<p><b>Table of Figures </b>.............................................................................................................................<b>118</b></p>
<p><b>Appendix – XCP Solutions at Vector </b>......................................................................................<b>120</b></p>
<p><b>Index </b>.................................................................................................................................................<b> 122</b></p>
<h1 style="page-break-before:always; "></h1>
<p>7</p>
<p>Introduction</p>
<p><b>Introduction</b></p>
<p>In optimal parameterization (calibration) of electronic ECUs, you calibrate parameter values </p>
<p>during the system runtime and simultaneously acquire measured signals. The physical con&shy;</p>
<p>nection between the development tool and the ECU is via a measurement and calibration </p>
<p>protocol. XCP has become established as a standard here.</p>
<p>First, the fundamentals and mechanisms of XCP will be explained briefly and then the appli&shy;</p>
<p>cation areas and added value for ECU calibration will be discussed.</p>
<p>First, some facts about XCP:</p>
<p>&gt;</p>
<p>  XCP signifies “Universal Measurement and Calibration Protocol”. The “X” stands for the </p>
<p>variable and interchangeable transport layer.</p>
<p>&gt;</p>
<p>  It was standardized by an ASAM working committee (Association for Standardisation of </p>
<p>Automation and Measuring Systems). ASAM is an organization of automotive OEMs, sup&shy;</p>
<p>pliers and tool producers.</p>
<p>&gt;</p>
<p>   XCP is the protocol that succeeds CCP (CAN Calibration Protocol).</p>
<p>&gt;</p>
<p>   The conceptual idea of the CAN Calibration Protocol was to permit read and write access </p>
<p>to internal ECU data over CAN. XCP was developed to implement this capability via dif&shy;</p>
<p>ferent transmission media. Then one speaks of XCP on CAN, XCP on FlexRay or XCP on </p>
<p>Ethernet. </p>
<p>&gt;</p>
<p>  The primary applications of XCP are measurement and calibration of internal ECU para&shy;</p>
<p>meters. Here, the protocol offers the ability to acquire measured values “event synchro&shy;</p>
<p>nous” to processes in ECUs. This ensures consistency of the data between one another.</p>
<p>To visualize the underlying idea, we initially view the ECU and the software running in it as a </p>
<p>black box. In a black box, only the inputs into the ECU (e.g. CAN messages and sensor  values) </p>
<p>and the output from the ECU (e.g. CAN messages and actuator drives) are acquired. Details </p>
<p>about the internal processing of algorithms are not immediately apparent and can only be </p>
<p>determined from an analysis of the input and output data. </p>
<p>Now  imagine that you  had  a  look  into the  behavior  of your  ECU with  every  computation </p>
<p>cycle. At any time, you could acquire detailed information on how the algorithm is running. </p>
<p>You would no longer have a black box, but a white box instead with a full view of internal </p>
<p>processes. That is precisely what you get with XCP! </p>
<p>What contribution can XCP make for the overall development process? To check the func&shy;</p>
<p>tionality of the attained development status, the developer can execute the code repeatedly. </p>
<p>In this way, the  developer finds  out  how the  algorithm  behaves  and what  might  be  opti&shy;</p>
<p>mized.  It  does  not  matter  here  whether  a  compiled  code  runs  on  a  specific  hardware  or </p>
<p>whether  it  is  developed  in  a  model&shy;based  way  and  the  application  runs  in  the  form  of  a </p>
<p>model.</p>
<p>A central focus is on the evaluation of the algorithm process. For example, if the algorithm </p>
<p>is running as a model in a development environment, such as Simulink from The MathWorks, </p>
<p>it is helpful to developers if they can also acquire intermediate results to their applications, </p>
<p>in order to obtain findings about other changes. In the final analysis, this method enables </p>
<p>nothing other than read access to parameters so that they can be visualized and analyzed – </p>
<h1 style="page-break-before:always; "></h1>
<p>8</p>
<p>Introduction</p>
<p>and all of this at model runtime or retrospectively after a time&shy;limited test run has been </p>
<p>completed. A write access is needed if parameterizations are changed, e.g. if the propor&shy;</p>
<p>tional  component  of  a  PID  controller  is  modified  to  adapt  the  algorithm  behavior  to  the </p>
<p> </p>
<p>system under control. Regardless of where your application runs – focal points are always </p>
<p>the </p>
<p>detailed </p>
<p>analysis </p>
<p>of </p>
<p>algorithm </p>
<p>processes </p>
<p>and </p>
<p>optimization </p>
<p>by </p>
<p>changes </p>
<p>to </p>
<p>the </p>
<p>parameterization.</p>
<p>This generalization can be made: The algorithms may exist in any type of executable form </p>
<p>(code  or  model  description).  Different  systems  may  be  used  as  the  runtime  environment </p>
<p>(Simulink, as DLL on the PC, on a rapid prototyping platform, in the ECU etc.). Process flows </p>
<p>are analyzed by read access to data and acquisition of its time&shy;based flow. Parameter sets </p>
<p>are modified iteratively to optimize algorithms. To simplify the representation, the acquisi&shy;</p>
<p>tion of data can be externalized to an external PC&shy;based tool, although it is understood here </p>
<p>that runtime environments themselves can even offer analysis capabilities.</p>
<p><b>Figure 1: </b></p>
<p><b>Fundamental </b></p>
<p><b>communication with </b></p>
<p><b>a runtime environment</b></p>
<p>Application</p>
<p>Operating System</p>
<p>Runtime Environment</p>
<p>Communication</p>
<p>PC Tool</p>
<p>The type of runtime environment and the form of communication generally differ from one </p>
<p>another considerably. The reason is that the runtime environments are developed by differ&shy;</p>
<p>ent producers and are based on different solution approaches. Different types of protocols, </p>
<p>configurations, measurement data formats, etc. make it a futile effort to try to exchange </p>
<p>parameter sets and results in all development steps. In the end, however, all of these solu&shy;</p>
<p>tions can be reduced to read and write access at runtime. And there is a standard for this: </p>
<p>XCP.</p>
<p>XCP  is  an  ASAM  standard  whose  Version  1.0  was  released  in  2003.  The  acronym  ASAM </p>
<p>stands for “Association for Standardisation of Automation and Measuring Systems.” Sup&shy;</p>
<p>pliers, vehicle OEMs and tool manufacturers are all represented in the ASAM working group. </p>
<p>The purpose of the XCP working group is to define a generalized measurement and calibra&shy;</p>
<p>tion protocol that can be used independent of the specific transport medium. Experience </p>
<p>gained from working with CCP (CAN Calibration Protocol) flowed into the development as </p>
<p>well.</p>
<p>XCP was defined based on the ASAM interfaces model. The following figure shows a mea&shy;</p>
<p>surement and calibration tool’s interfaces to the XCP Slave, to the description file and the </p>
<p>connection to a higher&shy;level automation system. </p>
<h1 style="page-break-before:always; "></h1>
<p>9</p>
<p>Introduction</p>
<p>Measurement and</p>
<p>Calibration System</p>
<p>ASAM MCD-3 MC</p>
<p>ASAM MCD-1 MC</p>
<p>ASAM</p>
<p>MCD-2 MC</p>
<p>ECU Description File</p>
<p>Upper Level</p>
<p>Automation System</p>
<p>ECU </p>
<p><b>XCP Driver</b></p>
<p><b>XCP Driver</b></p>
<p>*.A2L</p>
<p><b>Figure 2: </b></p>
<p><b>The Interface Model </b></p>
<p><b>of ASAM</b></p>
<p><b>Interface 1: “ASAM MCD-1 MC” between ECU and measurement &amp; calibration system</b></p>
<p>This interface describes the physical and the protocol&shy;specific parts. Strictly speaking, a dis&shy;</p>
<p>tinction  was  made  between  interfaces  ASAP1a  and  ASAP1b  here.  The  ASAP1b  interface, </p>
<p>however, never received general acceptance and for all practical purposes it has no relevance </p>
<p>today. The XCP protocol is so flexible that it can practically assume the role of a general </p>
<p>manufacturer&shy;independent interface. For example, today all measurement and calibration </p>
<p>hardware  manufacturers  offer  systems  (xETK, VX1000,  etc.) which  can  be  connected via </p>
<p>the XCP on Ethernet standard. An ASAP1b interface – as it was still described for CCP – is </p>
<p>no longer necessary. </p>
<p><b>Interface 2: “ASAM MCD-2 MC” A2L ECU description file </b></p>
<p>As  already  mentioned, XCP  works  in  an  address&shy;oriented  way.  Read  or  write  accesses  to </p>
<p>objects are always based on an address entry. Ultimately, however, this would mean that </p>
<p>the user would have to search for his ECU objects in the Master based on the address. That </p>
<p>would be extremely inconvenient. To let users work with symbolic object names, for example, </p>
<p>a  file  is  needed  that  describes  the  relationship  between  the  object  name  and  the  object </p>
<p>address. The next chapter is devoted to this A2L description file.</p>
<p><b>Interface 3: “ASAM MCD-3 MC” automation interface </b></p>
<p>This interface is used to connect another system to the measurement and calibration tool, </p>
<p>e.g.  for  test  bench  automation.  The  interface  is  not  further  explained  in  this  document, </p>
<p>because it is irrelevant to understanding XCP. </p>
<h1 style="page-break-before:always; "></h1>
<p>10</p>
<p>Introduction</p>
<p>XCP is based on the Master&shy;Slave principle. The ECU is the Slave and the measurement and </p>
<p>calibration tool is the Master. A Slave may only communicate with one Master at any given </p>
<p>time; on the other hand, the Master can simultaneous communicate with many Slaves.</p>
<p><b>Figure 3: </b></p>
<p><b>An XCP Master can </b></p>
<p><b> </b></p>
<p><b>simultaneously </b></p>
<p><b> </b></p>
<p><b>communicate with  </b></p>
<p><b>multiple Slaves</b></p>
<p>Master</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Bus</p>
<p>To  be  able  to  access  data  and  configurations  over  the  entire  development  process,  XCP </p>
<p>must be used in every runtime environment. Fewer tools would need to be purchased, oper&shy;</p>
<p>ated and maintained. This would also eliminate the need for manual copying of configura&shy;</p>
<p>tions from one tool to another, a process that is susceptible to errors. This would simplify </p>
<p>iterative  loops,  in  which  results  from  later  work  steps  are  transferred  back  to  prior  work </p>
<p>steps. </p>
<p>But let us turn our attention away from what might be feasible to what is possible today: </p>
<p>everything! XCP solutions are already used in a wide variety of work environments. It is the </p>
<p>intention of this book to describe the main properties of the measurement and calibration </p>
<p>protocol and introduce its use in the various runtime environments. What you will not find in </p>
<p>this book: neither the entire XCP specification in detailed form, nor precise instructions for </p>
<p>integrating XCP drivers in a specific runtime environment. It explains the relationships, but </p>
<p>not the individual protocol and implementation details. Internet links in the appendix refer </p>
<p>to  openly  available  XCP  driver  source  code  and  sample  implementations,  which  let  you </p>
<p>understand and see how the implementation is made. </p>
<p>Screenshots of the PC tool used in this book were prepared using the CANape measurement </p>
<p>and calibration tool from Vector. Other process flows are also explained based on CANape, in</p>
<p> </p>
<p> </p>
<p> </p>
<p>&shy;</p>
<p>cluding how to create an A2L file and even more. With a cost&shy;free demo version, which is avail&shy;</p>
<p>able to you in the Download Center of the Vector website at www.vector.com/canape_demo,</p>
<p> </p>
<p>you can see for yourself</p>
<h1 style="page-break-before:always; "></h1>
<p>13</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1 Fundamentals of the XCP Protocol</b></p>
<h1 style="page-break-before:always; "></h1>
<p>14</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Interface 1 of the ASAM interfaces model describes sending and receiving commands and </p>
<p>data between the Slave and the Master. To achieve independence from a specific physical </p>
<p>transport layer, XCP was subdivided into a protocol layer and a transport layer. </p>
<p><b>Figure 4: Subdivision of the XCP protocol into protocol layer and  transport layer</b></p>
<p>CAN</p>
<p>Ethernet</p>
<p>FlexRay</p>
<p>SxI</p>
<p>USB</p>
<p>...</p>
<p>Depending  on  the  transport  layer,  one  refers  to  XCP  on  CAN,  XCP  on  Ethernet,  etc.  The </p>
<p>extendibility  to  new  transport  layers  was  proven  as  early  as  2005  when  XCP  on  FlexRay </p>
<p>made its debut. The current version of the XCP protocol is Version 1.3, which was approved </p>
<p>in 2015.</p>
<p>Adherence to the following principles was given high priority in designing the protocol:</p>
<p>&gt;</p>
<p>  Minimal resource usage in the ECU</p>
<p>&gt;</p>
<p>  </p>
<p>Efficient communication</p>
<p>&gt;</p>
<p>  Simple Slave implementation </p>
<p>&gt;</p>
<p>  Plug&shy;and&shy;play configuration with just a small number of parameters</p>
<p>&gt;</p>
<p>  </p>
<p>Scalability</p>
<h1 style="page-break-before:always; "></h1>
<p>15</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>A key functionality of XCP is that it enables read and write access to the memory of the </p>
<p>Slave. </p>
<p>Read access lets users measure the time response of an internal ECU parameter. ECUs are </p>
<p>systems with discrete time behavior, whose parameters only change at specific time inter&shy;</p>
<p>vals: only when the processor recalculates the value and updates it in RAM. One of the great </p>
<p>strengths of XCP lies in acquiring measured values from RAM which change synchronously </p>
<p>to process flows or events in the ECU. This lets users evaluate direct relationships between </p>
<p>time&shy;based  process  flows  in  the  ECU  and  the  changing  values.  These  are  referred  to  as </p>
<p>event&shy;synchronous measurements. The related mechanisms will be explained later in detail.</p>
<p>Write access lets the user optimize parameters of algorithms in the Slave. The accesses are </p>
<p>address&shy;oriented, i.e. the communication between Master and Slave references addresses in </p>
<p>memory. So, the measurement of a parameter is essentially implemented as a request of </p>
<p>the Master to the Slave: “Give me the value of memory location 0x1234”. Calibration of a </p>
<p>parameter – the write access – to the Slave means: “Set the value at address 0x9876 to 5”.</p>
<p>An XCP Slave does not absolutely need to be used in ECUs. It may be implemented in differ&shy;</p>
<p>ent environments: from a model&shy;based development environment to hardware&shy;in&shy;the&shy;loop </p>
<p>and software&shy;in&shy;the&shy;loop environments to hardware interfaces that are used to access ECU </p>
<p>memory via debug interfaces such as JTAG, NEXUS and DAP.</p>
<p><b>Figure 5: </b></p>
<p><b>XCP Slaves can be </b></p>
<p><b>used in many </b></p>
<p><b>different runtime </b></p>
<p><b>environments</b></p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>PC</p>
<p>Measurement/</p>
<p>Calibration </p>
<p>Hardware*</p>
<p>* Debug Interfaces, Memory Emulator ...</p>
<p>HIL/SIL Systems</p>
<p>EXE/DLL</p>
<p>Prototype or</p>
<p>ECU Hardware</p>
<p>Simulink</p>
<p>Master</p>
<p><b>XCP</b></p>
<h1 style="page-break-before:always; "></h1>
<p>16</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>How can algorithms be optimized using read and write access to the ECU and what bene&shy;</p>
<p>fits does this offer? To be able to modify individual parameters at runtime in the ECU, there </p>
<p>must be access to them. Not every type of memory permits this process. It is only possible </p>
<p>to perform a read and write access to memory addresses in RAM (intentionally excluding </p>
<p>the EEPROM here). The following is a brief summary of the differences between individual </p>
<p>memory technologies: knowledge of them is very important to understanding over the fur&shy;</p>
<p>ther course of this book.</p>
<p><b>Memory Fundamentals</b></p>
<p>Today, flash memories are usually integrated in the microcontroller chips for ECUs and are </p>
<p>used for long&shy;term storage of code and data, even without power supply. The special aspect </p>
<p>of a flash memory is that read and write access to individual bytes is indeed possible at any </p>
<p>time, but writing of new contents can only be done blockwise, usually in rather large blocks. </p>
<p>Flash memories have a limited life, which is specified in terms of a maximum number of era</p>
<p>&shy;</p>
<p>sure  cycles  (depending  on  the  specific  technology  the  maximum  may  be  up  to  one  million </p>
<p>cycles). This is also the maximum number of write cycles, because the memory must always </p>
<p>be erased as a block before it can be written again. The reason for this lies in the memory </p>
<p>structure: electrons are “pumped” via tunnel diodes. A bit is stored at a memory location as </p>
<p>follows: electrons must be transported into the memory location over an electrically insulating </p>
<p>layer. Once the electrons are then behind the insulating layer, they form an electric field with </p>
<p>their charge, which is interpreted as a 1 when reading the memory location. If there are no </p>
<p>electrons behind the layer, the cell information is interpreted as a 0. A 1 can indeed be set in </p>
<p>this way, but not a 0. Setting to 0 (= erasing the 1) is performed in a separate erasing routine, </p>
<p>in which electrons existing behind the insulating layer are discharged. However, for architec</p>
<p>&shy;</p>
<p>tural  reasons,  such  an  erasing  routine  does  not  just  act  on  single  bytes,  rather  only  on the </p>
<p>group or block level. Depending on the architecture, blocks of 128 or 256 bytes are usually used. </p>
<p>If one wishes to overwrite a byte within such a block, the entire block must first be erased. </p>
<p>Then the entire contents of the block can be written back.</p>
<p>When this erasing routine is repeated multiple times, the insulating layer (“Tunnel Oxide Film”) </p>
<p>can be damaged. This means that the electrons could slowly leak away, changing some of the </p>
<p>information  from  1  to  0  over  the  course  of  time.  Therefore,  the  number  of  allowable  flash </p>
<p>cycles is severely limited in an ECU. In the production ECU, it is often only on the order of  single </p>
<p>digit numbers. This restriction is monitored by the Flash Boot Loader, which uses a counter to </p>
<p>keep  track  of  how  many  flash  operations  have  already  been  executed.  When  the  specified </p>
<p>number is exceeded, the Flash Boot Loader rejects another flash request.</p>
<p>A RAM (Random Access Memory) requires a permanent power supply; otherwise it loses its </p>
<p>contents. While flash memory serves the purpose of long&shy;term storage of the application, </p>
<p>the RAM is used to buffer computed data and other temporary information. Shutting off </p>
<p>the power supply causes the RAM contents to be lost. In contrast to flash memory, it is easy </p>
<p>to read and write to RAM. </p>
<h1 style="page-break-before:always; "></h1>
<p>17</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>This fact is clear: if parameters need to be changed at runtime, it must be assured that they </p>
<p>are located in RAM. It is really very important to understand this circumstance. That is why </p>
<p>we will look at the execution of an application in the ECU based on the following example: </p>
<p>In the application, the y parameters are computed from the sensor values x. </p>
<p>// Pseudo&shy;code representation</p>
<p>a = 5;</p>
<p>b = 2;</p>
<p>y = a * x + b;</p>
<p>If  the  application  is  flashed  in  the  ECU,  the  controller  handles  this  code  as  follows  after </p>
<p>booting: the values of the x parameters correspond to a sensor value. At some time point, </p>
<p>the application must therefore poll the sensor value and the value is then stored in a mem&shy;</p>
<p>ory location assigned to the x parameters. Since this value always needs to be rewritten at </p>
<p>runtime, the memory location can only lie in RAM. </p>
<p>The parameter y is computed. The values a and b, as factor and offset, are included as infor&shy;</p>
<p>mation in flash memory. They are stored as constants there. The value of y must also be </p>
<p>stored in RAM, because once again that is the only place where write access is pos sible. At </p>
<p>precisely which location in RAM the parameters x and y are located, or where a and b lie in </p>
<p>flash, is set in the compiler/linker run. This is where objects are allocated to unique addresses. </p>
<p>The relationship between object name, data type and address is documented in the linker&shy;</p>
<p>map file. The linker&shy;map file is generated by the Linker run and can exist in different formats. </p>
<p>Common to all formats, however, is that they contain the object name and address at a </p>
<p>minimum. </p>
<p>In the example, if the offset b and factor a depend on the specific vehicle, the values of a and </p>
<p>b must be individually adapted to the specific conditions of the vehicle. This means that the </p>
<p>algorithm remains as it is, but the parameter values change from vehicle to vehicle.</p>
<p>In the normal operating mode of an ECU, the application runs from the flash memory. It </p>
<p>does not permit any write accesses to individual objects. This means that parameter values </p>
<p>which are located in the flash area cannot be modified at runtime. If a change to parameter </p>
<p>values should be possible during runtime, the parameters to be modified must lie in RAM </p>
<p>and not in flash. Now, how do the parameters and their initial values make their way into </p>
<p>RAM? How does one solve the problem of needing to modify more parameters than can be </p>
<p>simultaneously stored in RAM? These issues lead us to the topic of calibration concepts (see </p>
<p>chapter 3).</p>
<h1 style="page-break-before:always; "></h1>
<p>18</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>Summary of XCP fundamentals</b></p>
<p>Read and write accesses to memory contents are available with the mechanisms of the XCP </p>
<p>protocol. The accesses are made in an address&shy;oriented way. Read access enables measure&shy;</p>
<p>ment of parameters from RAM, and write access enables calibration of the parameters in </p>
<p>RAM. XCP permits execution of the measurement synchronous to events in the ECU. This </p>
<p>ensures  that  the  measured  values  correlate  with  one  another.  With  every  restart  of  a </p>
<p> </p>
<p>measurement,  the  signals  to  be  measured  can  be  freely  selected.  For  write  access,  the </p>
<p>parameters to be calibrated must be stored in RAM. This requires a calibration concept</p>
<p>This leads to two important questions:</p>
<p>&gt;</p>
<p>  </p>
<p> How does the user of the XCP protocol know the correct addresses of the measurement </p>
<p>and calibration parameters in RAM?</p>
<p>&gt;</p>
<p>  </p>
<p> What does the calibration concept look like?</p>
<p>The first question is answered in chapter 2 “ECUs description file A2L”. The topic of the cali&shy;</p>
<p>bration concept is addressed in chapter 3.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>19</p>
<p>1.1 XCP Protocol Layer</p>
<p><b>1.1 XCP Protocol Layer</b></p>
<p>XCP data is exchanged between the Master and Slave in a message&shy;based way. The entire </p>
<p>“XCP message frame” is embedded in a frame of the transport layer (in the case of XCP on </p>
<p>Ethernet with UDP in a UDP packet). The frame consists of three parts: the XCP header, the </p>
<p>XCP packet and the XCP tail. </p>
<p>In the following figure, part of a message is shown in red. It is used to send the current XCP </p>
<p>frame. The XCP header and XCP tail depend on the transport protocol.</p>
<p><b>Figure 6: </b></p>
<p><b>XCP packet</b></p>
<p>XCP Header</p>
<p>XCP Message (Frame)</p>
<p><b>XCP Packet</b></p>
<p><b>PID</b></p>
<p><b>Identification</b></p>
<p><b>Field</b></p>
<p><b>Timestamp</b></p>
<p><b>Field</b></p>
<p><b>Data </b></p>
<p><b>Field</b></p>
<p><b>FILL</b></p>
<p><b>DAQ</b></p>
<p><b>TIMESTAMP</b></p>
<p><b>DATA</b></p>
<p>XCP Tail</p>
<p>The XCP packet itself is independent of the transport protocol used. It always contains three </p>
<p>components:  “Identification  Field”,  “Timestamp  Field”  and  the  current  data  field  “Data </p>
<p>Field”. Each Identification Field begins with the Packet Identifier (PID), which identifies the </p>
<p>packet. </p>
<p>The following overview shows which PIDs have been defined:</p>
<p>0xFF</p>
<p>CMD</p>
<p>PID for frames </p>
<p>from Master to Slave</p>
<p>PID for frames</p>
<p>from Slave to Master </p>
<p>absolute or</p>
<p>relative</p>
<p>ODT number</p>
<p>for STIM </p>
<p>0xC0</p>
<p>0xBF</p>
<p>0x00</p>
<p>....</p>
<p>....</p>
<p>absolute or</p>
<p>relative</p>
<p>ODT number</p>
<p>for DAQ </p>
<p>0xFF</p>
<p>0xFE</p>
<p>0xFD</p>
<p>0xFC</p>
<p>RES</p>
<p>ERR</p>
<p>EV</p>
<p>SERV</p>
<p>0xFB</p>
<p>0x00</p>
<p>....</p>
<p><b>Figure 7: Overview of XCP Packet Identifier (PID)</b></p>
<h1 style="page-break-before:always; "></h1>
<p>20</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Communication via the XCP packet is subdivided into one area for commands (CTO) and </p>
<p>one area for sending synchronous data (DTO). </p>
<p><b>XCP Master</b></p>
<p><b>XCP Slave</b></p>
<p>CMD</p>
<p>SERV</p>
<p>RES</p>
<p>ERR</p>
<p>EV</p>
<p><b>CTO</b></p>
<p>STIM</p>
<p><b>DTO</b></p>
<p>Command / Response / Error / </p>
<p>Event / Service Request Processor </p>
<p>DAQ</p>
<p>Processor</p>
<p>STIM</p>
<p>Processor</p>
<p>DAQ</p>
<p>STIM</p>
<p>PGM</p>
<p>CAL</p>
<p>Bypass</p>
<p>XCP Handler</p>
<p>Resources</p>
<p>DAQ</p>
<p>XCP Driver</p>
<p><b>Figure 8: </b></p>
<p><b>XCP communication </b></p>
<p><b>model with CTO/DTO</b></p>
<p>The acronyms used here stand for</p>
<p>CMD </p>
<p>Command Packet  </p>
<p>sends commands </p>
<p>RES </p>
<p>Command Response Packet </p>
<p>positive response</p>
<p>ERR </p>
<p>Error </p>
<p>negative response</p>
<p>EV </p>
<p>Event Packet </p>
<p>asynchronous event</p>
<p>SERV  </p>
<p>Service Request Packet </p>
<p>service request</p>
<p>DAQ </p>
<p>Data AcQuisition </p>
<p>send periodic measured values</p>
<p>STIM </p>
<p>Stimulation </p>
<p>periodic stimulation of the Slave</p>
<p>Commands are exchanged via CTOs (Command Transfer Objects). The Master initiates con&shy;</p>
<p>tact in this way, for example. The Slave must always respond to a CMD with RES or ERR. </p>
<p>The  other  CTO  messages  are  sent  asynchronously.  The  Data  Transfer  Objects  (DTO)  are </p>
<p>used to exchange synchronous measurement and stimulation data.</p>
<h1 style="page-break-before:always; "></h1>
<p>21</p>
<p>1.1 XCP Protocol Layer</p>
<p><b>1.1.1 Identification Field</b></p>
<p><b>Figure 9: </b></p>
<p><b>Message identification</b></p>
<p>XCP Packet</p>
<p><b>PID</b></p>
<p><b>Identification Field</b></p>
<p><b>FILL</b></p>
<p><b>DAQ</b></p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>When messages are exchanged, both the Master and Slave must be able to determine which </p>
<p>message was sent by the other. This is accomplished in the identification field. That is why </p>
<p>each message begins with the Packet Identifier (PID).</p>
<p>In transmitting CTOs, the PID field is fully sufficient to identify a CMD, RES or other CTO </p>
<p>packet. In Figure 7, it can be seen that commands from the Master to the Slave utilize a PID </p>
<p>from 0xC0 to 0xFF. The XCP Slave responds or informs the Master with PIDs from 0xFC to </p>
<p>0xFF. This results in a unique allocation of the PIDs to the individually sent CTOs.</p>
<p>When DTOs are transmitted, other elements of the identification field are used (see chap&shy;</p>
<p>ter 1.3.4 “XCP Packet Addressing for DAQ and STIM”).</p>
<p><b>1.1.2 Timestamp</b></p>
<p><b>Figure 10: </b></p>
<p><b>Timestamp</b></p>
<p>XCP Packet</p>
<p><b>TIMESTAMP</b></p>
<p>PID FILL</p>
<p>DAQ</p>
<p>DATA</p>
<p>DTO packets use timestamps, but this is not possible in transmission of a CTO message. The </p>
<p>Slave  uses  the  timestamp  to  supply  time  information  with  measured  values. That  is,  the </p>
<p>Master  not  only  has the  measured value,  but  also the time  point  at which the  measured </p>
<p>value was  acquired. The  amount  of time  it takes for the  measured value to  arrive  at the </p>
<p>Master is no longer important, because the relationship between the measured value and </p>
<p>the time point comes directly from the Slave. </p>
<p>Transmission of a timestamp from the Slave is optional. This topic is discussed further in  </p>
<p>ASAM XCP Part 2 Protocol Layer Specification. </p>
<h1 style="page-break-before:always; "></h1>
<p>22</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.1.3 Data Field </b></p>
<p><b>Figure 11: </b></p>
<p><b>Data field in the </b></p>
<p><b>XCP packet</b></p>
<p>XCP Packet</p>
<p><b>DATA</b></p>
<p><b>Data Field</b></p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>Finally, the XCP packet also contains the data stored in the data field. In the case of CTO </p>
<p>packets,  the  data  field  consists  of  specific  parameters  for  the  different  commands.  DTO </p>
<p>packets contain the measured values from the Slave and when STIM data is sent the values </p>
<p>from the Master.</p>
<p><b>1.2 Exchange of CTOs </b></p>
<p>CTOs are used to transmit both commands from the Master to the Slave and responses </p>
<p>from the Slave to the Master.</p>
<p><b>1.2.1 XCP Command Structure</b></p>
<p>The Slave receives a command from the Master and must react to it with a positive or neg&shy;</p>
<p>ative response. The communication structure is always the same here:</p>
<p>Command (CMD):</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Packet Code CMD</p>
<p>1..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Command specific Parameters</p>
<p>A unique number is assigned to each command. In addition, other specific parameters may </p>
<p>be sent with the command. The maximum number of parameters is defined as MAX_CTO&shy;1 </p>
<p>here. MAX_CTO indicates the maximum length of the CTO packets in bytes. </p>
<p>Positive response:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Positive Response Packet Code = RES 0xFF</p>
<p>1..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Command specific Parameters </p>
<h1 style="page-break-before:always; "></h1>
<p>23</p>
<p>1.2 Exchange of CTOs </p>
<p>Negative response:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Error Packet Code = 0xFE</p>
<p>1 </p>
<p>BYTE </p>
<p>Error code</p>
<p>2..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Command specific Parameters</p>
<p>Specific </p>
<p>parameters </p>
<p>can </p>
<p>be </p>
<p>transmitted </p>
<p>as </p>
<p>supplemental </p>
<p>information </p>
<p>with </p>
<p>negative </p>
<p>responses as well and not just with positive responses. One example is when the connection </p>
<p>is made between Master and Slave. At the start of a communication between Master and </p>
<p>Slave, the Master sends a connect request to the Slave, which in turn must respond posi&shy;</p>
<p>tively to produce a continuous point&shy;to&shy;point connection.</p>
<p>Master à Slave:  Connect </p>
<p>Slave à Master:  Positive Response </p>
<p>Connect command:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Code = 0xFF</p>
<p>1 </p>
<p>BYTE </p>
<p>Mode </p>
<p> </p>
<p> </p>
<p>00 = Normal</p>
<p> </p>
<p> </p>
<p>01 = user defined</p>
<p>Mode 00 means that the Master wishes XCP communication with the Slave. If the Master </p>
<p>uses 0xFF 0x01 when making the connection, the Master is requesting XCP communication </p>
<p>with the Slave. Simultaneously, it informs the Slave that it should switch to a specific – user&shy;</p>
<p>defined – mode. </p>
<p>Positive response of the Slave:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet ID: 0xFF</p>
<p>1 </p>
<p>BYTE </p>
<p>RESOURCE</p>
<p>2 </p>
<p>BYTE </p>
<p>COMM_MODE_BASIC</p>
<p>3 </p>
<p>BYTE </p>
<p>MAX_CTO, Maximum CTO size [BYTE]</p>
<p>4 </p>
<p>WORD </p>
<p>MAX_DTO, Maximum DTO size [BYTE]</p>
<p>6 </p>
<p>BYTE </p>
<p>XCP Protocol Layer Version Number (most significant byte only)</p>
<p>7 </p>
<p>BYTE </p>
<p>XCP Transport Layer Version Number (most significant byte only)</p>
<p>The positive response of the Slave can assume a somewhat more extensive form. The Slave </p>
<p>already sends communication&shy;specific information to the Master when making the connec&shy;</p>
<p>tion. RESOURCE, for example, is information that the Slave gives on whether it supports </p>
<p>such features as page switching or whether flashing over XCP is possible. With MAX_DTO, </p>
<p>the Slave informs the Master of the maximum packet length it supports for transfer of the </p>
<p>measured values, etc. You will find details on the parameters in ASAM XCP Part 2 Protocol </p>
<p>Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>24</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>XCP  permits  three  different  modes  for  exchanging  commands  and  reactions  between </p>
<p> </p>
<p>Master and Slave: Standard, Block and Interleaved mode.</p>
<p><b>Figure 12: The three modes of the XCP protocol: Standard, Block and  Interleaved mode</b></p>
<p>MIN_ST</p>
<p>MAX_BS</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p><b>Standard Mode</b></p>
<p><b>Block Mode</b></p>
<p><b>Interleaved Mode</b></p>
<p>Request k+1</p>
<p>Response k</p>
<p>Response k+1</p>
<p>Request k</p>
<p>Request k</p>
<p>Request k+1</p>
<p>Response k</p>
<p>Response k+1</p>
<p>Response k</p>
<p>Request k+1</p>
<p>Response k+1</p>
<p>Request k</p>
<p>Part1</p>
<p>Part3</p>
<p>Part2</p>
<p>Part1</p>
<p>Part2</p>
<p>Part3</p>
<p>In  the  standard  communication  model,  each  request  to  a  Slave  is  followed  by  a  single </p>
<p>response. Except with XCP on CAN, it is not permitted for multiple Slaves to react to a com&shy;</p>
<p>mand from the Master. Therefore, each XCP message can always be traced back to a unique </p>
<p>Slave. This mode is the standard case in communication.</p>
<p>The block transfer mode is optional and saves time in large data transfers (e.g. upload or </p>
<p>download operations). Nonetheless, performance issues must be considered in this mode in </p>
<p>the  direction  of  the  Slave.  Therefore,  minimum  times  between  two  commands  (MIN_ST) </p>
<p>must be maintained and the total number of commands must be limited to an upper limit </p>
<p>MAX_BS. Optionally, the Master can read out these communication settings from the Slave </p>
<p>with GET_COMM_MODE_INFO. The aforementioned limitations do not need to be observed </p>
<p>in block transfer mode in the direction of the Master, because performance of the PC nearly </p>
<p>always suffices to accept the data from a microcontroller.</p>
<p>The  interleaved  mode  is  also  provided  for  performance  reasons.  But  this  method  is  also </p>
<p>optional and – in contrast to block transfer mode – it has no relevance in practice.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>25</p>
<p>1.2 Exchange of CTOs </p>
<p><b>1.2.2 CMD </b></p>
<p><b>Figure 13: Overview of the CTO packet structure</b></p>
<p>PID</p>
<p>DATA</p>
<p>Data Field</p>
<p>Identification Field</p>
<p>Timestamp Field</p>
<p>empty for CTO</p>
<p><b>XCP CTO Packet</b></p>
<p>The Master sends a general request to the Slave over CMD. The PID (Packet Identifier) field </p>
<p>contains the identification number of the command. The additional specific parameters are </p>
<p>transported in the data field. Then the Master waits for a reaction of the Slave in the form </p>
<p>of a RESponse or an ERRor.</p>
<p>XCP is also very scalable in its implementation, so it is not necessary to implement every </p>
<p>command.  In  the  A2L  file,  the  available  CMDs  are  listed  in  what  is  known  as  the  XCP  </p>
<p>IF_DATA. If there is a discrepancy between the definition in the A2L file and the implemen&shy;</p>
<p>tation in the Slave, the Master can determine, based on the Slave’s reaction, that the Slave </p>
<p>does  not  even  support the  command.  If the  Master  sends  a  command that  is  not  imple&shy;</p>
<p>mented in the Slave, the Slave must acknowledge with ERR_CMD_UNKNOWN and no fur&shy;</p>
<p>ther activities are initiated in the Slave. This lets the Master know quickly that an optional </p>
<p>command has not been implemented in the Slave. </p>
<p>Some  other  parameters  are  included  in  the  commands  as  well.  Please  take  the  precise </p>
<p>details from the protocol layer specification in document ASAM XCP Part 2. </p>
<p> </p>
<p>The  commands  are  organized  in  groups:  Standard,  Calibration,  Page,  Programming  and </p>
<p>DAQ measurement commands. If a group is not needed at all, its commands do not need to </p>
<p>be implemented. If the group is necessary, certain commands must always be available in </p>
<p>the Slave, while others from the group are optional.</p>
<p>The  following  overview  serves  as  an  example.  The  SET_CAL_PAGE  and  GET_CAL_PAGE </p>
<p>commands in the page switching group are identified as not optional. This means that in an </p>
<p>XCP  Slave  that  supports  page  switching  at  least  these  two  commands  must  be  imple&shy;</p>
<p>mented. If page switching support is unnecessary in the Slave, these commands do not need </p>
<p>to be implemented. The same applies to other commands.</p>
<h1 style="page-break-before:always; "></h1>
<p>26</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Standard commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>CONNECT </p>
<p>0xFF </p>
<p>No</p>
<p>DISCONNECT </p>
<p>0xFE </p>
<p>No</p>
<p>GET_STATUS </p>
<p>0xFD </p>
<p>No</p>
<p>SYNCH </p>
<p>0xFC </p>
<p>No</p>
<p>GET_COMM_MODE_INFO </p>
<p>0xFB </p>
<p>Yes</p>
<p>GET_ID </p>
<p>0xFA </p>
<p>Yes</p>
<p>SET_REQUEST </p>
<p>0xF9 </p>
<p>Yes</p>
<p>GET_SEED </p>
<p>0xF8 </p>
<p>Yes</p>
<p>UNLOCK </p>
<p>0xF7 </p>
<p>Yes</p>
<p>SET_MTA </p>
<p>0xF6 </p>
<p>Yes</p>
<p>UPLOAD </p>
<p>0xF5 </p>
<p>Yes</p>
<p>SHORT_UPLOAD </p>
<p>0xF4 </p>
<p>Yes</p>
<p>BUILD_CHECKSUM </p>
<p>0xF3 </p>
<p>Yes</p>
<p>TRANSPORT_LAYER_CMD </p>
<p>0xF2 </p>
<p>Yes</p>
<p>USER_CMD </p>
<p>0xF1 </p>
<p>Yes</p>
<p>Calibration commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>DOWNLOAD </p>
<p>0xF0 </p>
<p>No</p>
<p>DOWNLOAD_NEXT </p>
<p>0xEF </p>
<p>Yes</p>
<p>DOWNLOAD_MAX </p>
<p>0xEE </p>
<p>Yes</p>
<p>SHORT_DOWNLOAD </p>
<p>0xED </p>
<p>Yes</p>
<p>MODIFY_BITS </p>
<p>0xEC </p>
<p>Yes</p>
<p>Standard commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>SET_CAL_PAGE </p>
<p>0xEB </p>
<p>No</p>
<p>GET_CAL_PAGE </p>
<p>0xEA </p>
<p>No</p>
<p>GET_PAG_PROCESSOR_INFO </p>
<p>0xE9 </p>
<p>Yes</p>
<p>GET_SEGMENT_INFO </p>
<p>0xE8 </p>
<p>Yes</p>
<p>GET_PAGE_INFO </p>
<p>0xE7 </p>
<p>Yes</p>
<p>SET_SEGMENT_MODE </p>
<p>0xE6 </p>
<p>Yes</p>
<p>GET_SEGMENT_MODE </p>
<p>0xE5 </p>
<p>Yes</p>
<p>COPY_CAL_PAGE </p>
<p>0xE4 </p>
<p>Yes</p>
<h1 style="page-break-before:always; "></h1>
<p>27</p>
<p>1.2 Exchange of CTOs </p>
<p>Periodic data exchange – basics:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>SET_DAQ_PTR </p>
<p>0xE2 </p>
<p>No</p>
<p>WRITE_DAQ </p>
<p>0xE1 </p>
<p>No</p>
<p>SET_DAQ_LIST_MODE </p>
<p>0xE0 </p>
<p>No</p>
<p>START_STOP_DAQ_LIST </p>
<p>0xDE </p>
<p>No</p>
<p>START_STOP_SYNCH </p>
<p>0xDD </p>
<p>No</p>
<p>WRITE_DAQ_MULTIPLE </p>
<p>0xC7 </p>
<p>Yes</p>
<p>READ_DAQ </p>
<p>0xDB </p>
<p>Yes</p>
<p>GET_DAQ_CLOCK </p>
<p>0xDC </p>
<p>Yes</p>
<p>GET_DAQ_PROCESSOR_INFO </p>
<p>0xDA </p>
<p>Yes</p>
<p>GET_DAQ_RESOLUTION_INFO </p>
<p>0xD9 </p>
<p>Yes</p>
<p>GET_DAQ_LIST_INFO </p>
<p>0xD8 </p>
<p>Yes</p>
<p>GET_DAQ_EVENT_INFO </p>
<p>0xD7 </p>
<p>Yes</p>
<p>Periodic data exchange – static configuration: </p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>CLEAR_DAQ_LIST </p>
<p>0xE3 </p>
<p>No</p>
<p>GET_DAQ_LIST_INFO </p>
<p>0xD8 </p>
<p>Yes</p>
<p>Periodic data exchange – dynamic configuration: </p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>FREE_DAQ </p>
<p>0xD6 </p>
<p>Yes</p>
<p>ALLOC_DAQ </p>
<p>0xD5 </p>
<p>Yes</p>
<p>ALLOC_ODT </p>
<p>0xD4 </p>
<p>Yes</p>
<p>ALLOC_ODT_ENTRY </p>
<p>0xD3 </p>
<p>Yes</p>
<h1 style="page-break-before:always; "></h1>
<p>28</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Flash programming:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>PROGRAM_START </p>
<p>0xD2 </p>
<p>No</p>
<p>PROGRAM_CLEAR </p>
<p>0xD1 </p>
<p>No</p>
<p>PROGRAM </p>
<p>0xD0 </p>
<p>No</p>
<p>PROGRAM_RESET </p>
<p>0xCF </p>
<p>No</p>
<p>GET_PGM_PROCESSOR_INFO </p>
<p>0xCE </p>
<p>Yes</p>
<p>GET_SECTOR_INFO </p>
<p>0xCD </p>
<p>Yes</p>
<p>PROGRAM_PREPARE </p>
<p>0xCC </p>
<p>Yes</p>
<p>PROGRAM_FORMAT </p>
<p>0xCB </p>
<p>Yes</p>
<p>PROGRAM_NEXT </p>
<p>0xCA </p>
<p>Yes</p>
<p>PROGRAM_MAX </p>
<p>0xC9 </p>
<p>Yes</p>
<p>PROGRAM_VERIFY </p>
<p>0xC8 </p>
<p>Yes</p>
<p><b>1.2.3 RES </b></p>
<p>If the Slave is able to successfully comply with a Master’s request, it gives a positive acknowl&shy;</p>
<p>edge with RES. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = RES 0xFF</p>
<p>1..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Command response data</p>
<p>You  will  find  more  detailed  information  on  the  parameters  in ASAM XCP  Part  2  Protocol </p>
<p>Layer Specification.</p>
<p><b>1.2.4 ERR </b></p>
<p>If the request from the Master is unusable, it responds with the error message ERR and an </p>
<p>error code. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = ERR 0xFE</p>
<p>1 </p>
<p>BYTE </p>
<p>Error code</p>
<p>2..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Optional error information data</p>
<p>You will find a list of possible error codes in ASAM XCP Part 2 Protocol Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>29</p>
<p>1.2 Exchange of CTOs </p>
<p><b>1.2.5 EV </b></p>
<p>If the Slave wishes to inform the Master of an asynchronous event, an EV can be sent to do </p>
<p>this. Its implementation is optional.</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = EV 0xFD</p>
<p>1 </p>
<p>BYTE </p>
<p>Event code</p>
<p>2..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Optional event information data</p>
<p>You  will  find  more  detailed  information  on  the  parameters  in ASAM XCP  Part  2  Protocol </p>
<p>Layer Specification.</p>
<p>Events will be discussed much more in relation to measurements and stimulation. This has </p>
<p>nothing to do with the action of the XCP Slave that initiates sending of an EVENT. Rather it </p>
<p>involves the Slave reporting a disturbance such as the failure of a specific functionality.</p>
<p><b>1.2.6 SERV </b></p>
<p>The Slave can use this mechanism to request that the Master execute a service. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = SERV 0xFC</p>
<p>1 </p>
<p>BYTE </p>
<p>Service request code</p>
<p>2..MAX_CTO&shy;1 </p>
<p>BYTE </p>
<p>Optional service request data</p>
<p>You </p>
<p>will </p>
<p>find </p>
<p>the </p>
<p>Service </p>
<p>Request </p>
<p>Code </p>
<p>table </p>
<p>in </p>
<p>ASAM </p>
<p>XCP </p>
<p>Part </p>
<p>2 </p>
<p>Protocol </p>
<p>Layer </p>
<p>Specification. </p>
<p><b>1.2.7 Calibrating Parameters in the Slave</b></p>
<p>To change a parameter in an XCP Slave, the XCP Master must send the parameter’s loca&shy;</p>
<p>tion as well as the value itself to the Slave.</p>
<p>XCP always defines addresses with five bytes: four for the actual address and one byte for </p>
<p>the address extension. Based on a CAN transmission, only seven useful bytes are available </p>
<p>for XCP messages. For example, if the calibrator sets a 4&shy;byte value and wants to send both </p>
<p>pieces  of  information  in  one  CAN  message, there  is  insufficient  space to  do this.  Since  a </p>
<p>total of nine bytes are needed to transmit the address and the new value, the change can&shy;</p>
<p>not  be  transmitted  in  one  CAN  message  (seven  useful  bytes).  The  calibration  request  is </p>
<p>therefore  made  with  two  messages  from  Master  to  Slave.  The  Slave  must  acknowledge </p>
<p>both messages and in sum four messages are exchanged.</p>
<h1 style="page-break-before:always; "></h1>
<p>30</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>The following figure shows the communication between Master and Slave, which is neces&shy;</p>
<p>sary to set a parameter value. The actual message is located in the line with the envelope </p>
<p>symbol. The interpretation of the message is shown by “expanding” it with the mouse. </p>
<p> </p>
<p><b>Figure 14: Trace example from a calibration process in CANape</b></p>
<p>In the first message of the Master (highlighted in blue in Figure 14), the Master sends the  </p>
<p>command SET_MTA to the Slave with the address to which a new value should be written. </p>
<p>In  the  second  message,  the  Slave  gives  a  positive  acknowledge  to  the  command  with </p>
<p>Ok:SET_MTA.</p>
<p>The  third  message  DOWNLOAD  transmits  the  hex  value  as  well  as  the  valid  number  of </p>
<p>bytes. In this example, the valid number of bytes is four, because it is a float value. The Slave </p>
<p>gives another positive acknowledge in the fourth message.</p>
<p>This completes the current calibration process. In the Trace display, you can recognize a ter&shy;</p>
<p>minating SHORT_UPLOAD – a special aspect of CANape, the measurement and calibration </p>
<p>tool from Vector. To make sure that the calibration was performed successfully, the value is </p>
<p>read out again after the process and the display is updated with the read&shy;out value. This lets </p>
<p>the user directly recognize whether the calibration command was implemented. This com&shy;</p>
<p>mand also gets a positive acknowledge with Ok:SHORT_UPLOAD. </p>
<p>When the parameter changes in the ECU’s RAM, the application processes the new value. A </p>
<p>reboot of the ECU, however, would lead to erasure of the value and overwriting of the value </p>
<p>in RAM with the original value from the flash (see chapter 3 “Calibration Concepts”). So, </p>
<p>how can the modified parameter set be permanently saved?</p>
<h1 style="page-break-before:always; "></h1>
<p>31</p>
<p>1.2 Exchange of CTOs </p>
<p>Essentially, there are two possibilities: </p>
<p><b>A) Save the parameters in the ECU</b></p>
<p>The changed data in RAM could for example be saved in the ECU’s EEPROM: either auto&shy;</p>
<p>matically when ramping down the ECU, or manually by the user. A prerequisite is that the </p>
<p>data  can  be  stored  in  a  nonvolatile  memory  of  the  Slave.  In  an  ECU,  this  would  be  the </p>
<p>EEPROM or flash. ECUs with thousands of parameters, however, are seldom able to provide </p>
<p>so much unused EEPROM memory space, so this method is rare.</p>
<p>Another possibility is to write the RAM parameters back into the ECU’s flash memory. This </p>
<p>method is relatively complex. A flash memory must first be erased before it can be rewrit&shy;</p>
<p>ten. This, in turn, can only be done as a block. Consequently, it is not simply a matter of writ&shy;</p>
<p>ing </p>
<p>back </p>
<p>individual </p>
<p>bytes. </p>
<p>You </p>
<p>will </p>
<p>find </p>
<p>more </p>
<p>on </p>
<p>this </p>
<p>topic </p>
<p>in </p>
<p>chapter </p>
<p>3 </p>
<p>“Calibration </p>
<p>Concepts”. </p>
<p><b>B) Save the parameters in the form of a file on the PC</b></p>
<p>It is much more common to store the parameters on the PC. All parameters – or subsets of </p>
<p>them – are stored in the form of a file. Different formats are available for this; the simplest </p>
<p>case is that of an ASCII text file, which only contains the name of the object and its value. </p>
<p>Other formats also permit saving other information, such as findings about the maturity </p>
<p>level of the parameter of the history of revisions. </p>
<p>Scenario: After finishing his or her work, the calibrator wishes to enjoy a free evening. So, the </p>
<p>calibrator saves the executed changes in the ECU’s RAM in the form of a parameter set file </p>
<p>on a PC. The next day, the calibrator wants to continue working where he or she left off. The </p>
<p>calibrator starts the ECU. Upon booting, the parameters are initialized in RAM. However, </p>
<p>the ECU does this using values stored in flash. This means that the changes of the previous </p>
<p>day are no longer available in the ECU. To now continue where work was left off on the pre&shy;</p>
<p>vious day, the calibrator transfers the contents of the parameter set file to the ECU’s RAM </p>
<p>by XCP using the DOWNLOAD command.</p>
<p><b>Figure 15: Transfer of a parameter set file to an ECU’s RAM</b></p>
<h1 style="page-break-before:always; "></h1>
<p>32</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>Saving parameter set file in hex files and flashing</b></p>
<p>Flashing an ECU is another way to change the parameters in flash. They are then written to </p>
<p>RAM as new parameters when the ECU is booted. A parameter set file can also be trans&shy;</p>
<p>ferred to a C or H file and be made into the new flash file with another compiler/linker run. </p>
<p>However, depending on the parameters of the code, the process of generating a flashable </p>
<p>hex file could take a considerable amount of time. In addition, the calibrator might not have </p>
<p>any  ECU  source  code  –  depending  on  the  work  process. That  would  prevent  this  method </p>
<p>from being available to the calibrator. </p>
<p>As an alternative, the calibrator can copy the parameter set file into the existing flash file.</p>
<p><b>Figure 16: Hex window</b></p>
<p>In the flash file, there is a hex file that contains both the addresses and the values. Now a </p>
<p>parameter file can be copied to a hex file. To do this, CANape takes the address and the </p>
<p>value from the parameter set file and updates the parameter value at the relevant location </p>
<p>in the hex file. This results in a new hex file, which contains the changed parameter values. </p>
<p>However, this Hex file must now possibly run through further process steps to obtain a flash&shy;</p>
<p>able file. One recurring problem here is the checksums, which the ECU checks to determine </p>
<p>whether it received the data correctly. If the flashable file exists, it can be flashed in the ECU </p>
<p>and after the reboot the new parameter values are available in the ECU. </p>
<p><b>1.3 Exchanging DTOs – Synchronous Data Exchange </b></p>
<p>As depicted in Figure 8, DTOs (Data Transfer Objects) are available for exchanging synchro&shy;</p>
<p>nous  measurement  and  calibration  data.  Data from the  Slave  are  sent to the  Master  by </p>
<p>DAQ – synchronous to internal events. This communication is subdivided into two phases: </p>
<p>In  an  initialization  phase,  the  Master  communicates  to  the  Slave  which  data  the  Slave </p>
<p>should send for different events. After this phase, the Master initiates the measurement in </p>
<p>the  Slave  and  the  actual  measurement  phase  begins.  From  this  point  in  time,  the  Slave </p>
<p>sends the desired data to the Master, which only listens until it sends a “measurement stop” </p>
<p>to the Slave. Triggering of measurement data acquisition and transmission is controlled by </p>
<p>events in the ECU.</p>
<h1 style="page-break-before:always; "></h1>
<p>33</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>The  Master  sends  data  to  the  Slave  by  STIM.  This  communication  also  consists  of  two </p>
<p>phases:</p>
<p>In the initialization phase, the Master communicates to the Slave which data it will send to </p>
<p>the Slave. After this phase, the Master sends the data to the Slave and the STIM processor </p>
<p>saves the data. As soon as a related STIM event is triggered in the Slave, the data is trans&shy;</p>
<p>ferred to the application memory. </p>
<p><b>1.3.1 Measurement Methods: Polling versus DAQ </b></p>
<p>Before explaining how event&shy;synchronous, correlated data is measured from a Slave, here is </p>
<p>a  brief  description  of  another  measurement  method  known  as  Polling.  It  is  not  based  on </p>
<p>DTOs, but on CTOs instead. Actually, this topic should be explained in a separate chapter, </p>
<p>but a description of polling lets us derive, in a very elegant way, the necessity of DTO&shy;based </p>
<p>measurement, so a minor side discussion at this point makes sense. </p>
<p>The Master can use the SHORT_UPLOAD command to request the value of a measurement </p>
<p>para </p>
<p>meter  from  the  Slave.  This  is  referred  to  as  polling.  This  is  the  simplest  case  of  a </p>
<p>measure  </p>
<p>ment:  sending  the  measured  value  of  a  measurement  parameter  at  the  time  at </p>
<p>which the SHORT_UPLOAD command has been received and executed. </p>
<p>In  the  following  example,  the  measurement  parameter  “Triangle”  is  measured  from  the </p>
<p>Slave: </p>
<p><b>Figure 17: </b></p>
<p><b>Address information </b></p>
<p><b>of the parameter </b></p>
<p><b> </b></p>
<p><b>“Triangle” from the  </b></p>
<p><b>A2L file</b></p>
<p>The address 0x60483 is expressed as an address with five bytes in the CAN frame: one byte </p>
<p>for the address extension and four bytes for the actual address.</p>
<h1 style="page-break-before:always; "></h1>
<p>34</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>Figure 18: Polling communication in the CANape Trace window</b></p>
<p>The XCP specification sets a requirement for polling: that the value of each measurement </p>
<p>parameter must be polled individually. For each value to be measured via polling, two mes&shy;</p>
<p>sages must go over the bus: the Master’s request to the Slave and the Slave’s response to </p>
<p>the Master.</p>
<p>Besides this additional bus load, there is another disadvantage of the polling method: When </p>
<p>polling multiple data values, the user normally wants the data to correlate to one another. </p>
<p>However,  multiple  values  that  are  measured  sequentially  with  polling  do  not  necessarily </p>
<p>stand in correlation to one another, i.e. they might not originate from the same ECU com&shy;</p>
<p>puting cycle. </p>
<p>This limits the suitability of polling for measurement, because it produces unnecessarily high </p>
<p>data traffic and the measured values are not evaluated in relation to the process flows in </p>
<p>the ECU. </p>
<p>So, an optimized measurement must solve two tasks:</p>
<p>&gt;</p>
<p>  </p>
<p>Bandwidth optimization during the measurement</p>
<p>&gt;</p>
<p>  Assurance of data correlation</p>
<p>This task is handled by the already mentioned DAQ method. DAQ stands for Data Acquisi&shy;</p>
<p>tion and it is implemented by sending DTOs (Data Transfer Objects) from the Slave to the </p>
<p>Master.</p>
<p><b>1.3.2 DAQ Measurement Method </b></p>
<p>The DAQ method solves the two problems of polling as follows:</p>
<p>&gt;</p>
<p>  The correlation of measured values is achieved by coupling the acquisition of measured </p>
<p>values to the events in the ECU. The measured values are not acquired and transferred </p>
<p>until it has been assured that all computations have been completed.</p>
<p>&gt;</p>
<p>  To reduce bus load, the measurement process is subdivided into two phases: In a configu&shy;</p>
<p>ration phase, the Master communicates which values it is interested in to the Slave and </p>
<p>the  second  phase  just  involves  transferring  the  measured  values  of  the  Slave  to  the </p>
<p>Master. </p>
<h1 style="page-break-before:always; "></h1>
<p>35</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>How can the acquisition of measured values now be coupled to processes in the ECU?  Figure </p>
<p>19 shows the relationship between calculation cycles in the ECU and the changes in para&shy;</p>
<p>meters X and Y.</p>
<p>Calculation</p>
<p>cycle n</p>
<p>Calculation</p>
<p>cycle n+1</p>
<p>Calculation</p>
<p>cycle n+2</p>
<p>time</p>
<p>10</p>
<p>  8</p>
<p>  6</p>
<p>  4</p>
<p>  2</p>
<p>  0</p>
<p>10</p>
<p>  8</p>
<p>  6</p>
<p>  4</p>
<p>  2</p>
<p>  0</p>
<p>E1</p>
<p>E1</p>
<p>E1</p>
<p><b>X</b></p>
<p><b>Y</b></p>
<p>Calculate Y = X</p>
<p>Read sensor X</p>
<p><b>Figure 19: </b></p>
<p><b>Events in the ECU</b></p>
<p>Let’s have a look at the sequence in the ECU: When event E1 (= end of computation cycle) is </p>
<p>reached,  then  all  parameters  have  been  acquired  and  calculations  have  been  made.  This </p>
<p>means that all values must match one another and correlate at this time point. This means </p>
<p>that we  use  an  event&shy;synchronous  measurement  method. This  is  precisely what  is  imple&shy;</p>
<p>mented with the help of the DAQ mechanism: When the algorithm in the Slave reaches the </p>
<p>“Computational cycle completed” event, the XCP Slave collects the values of the measure&shy;</p>
<p>ment parameters, saves them in a buffer and sends them to the Master. This assumes that </p>
<p>the Slave knows which parameters should be measured for which event. </p>
<p>An event does not absolutely have to be a cyclic, time&shy;equidistant event, rather in the case </p>
<p>of  an  engine  controller,  for  example,  it  might  be  angle&shy;synchronous. This  makes  the  time </p>
<p>interval between two events dependent on the engine rpm. A singular event, such as activa&shy;</p>
<p>tion of a switch by the driver, is also an event that is not by any means equidistant in time. </p>
<p>The user selects the signals. Besides the actual measurement object, the user must select </p>
<p>the underlying event for the measurement parameters. The events as well as the possible </p>
<p>assignments of the measurement objects to the events must be stored in the A2L file.</p>
<p><b>Figure 20: </b></p>
<p><b>Event definition </b></p>
<p><b>in an A2L</b></p>
<h1 style="page-break-before:always; "></h1>
<p>36</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>In the normal case, it does not make any sense to be able to simultaneously assign a mea&shy;</p>
<p>sured value to multiple events. Generally, a parameter is only modified within a single cycle </p>
<p>(e.g. </p>
<p>only </p>
<p>at </p>
<p>10&shy;ms </p>
<p>intervals) </p>
<p>and </p>
<p>not </p>
<p>in </p>
<p>multiple </p>
<p>cycles </p>
<p>(e.g. </p>
<p>at </p>
<p>10&shy;ms </p>
<p>and </p>
<p>100&shy;ms </p>
<p>intervals). </p>
<p><b>Figure 21: </b></p>
<p><b>Allocation of </b></p>
<p><b>“Triangle” to possible </b></p>
<p><b>events in the A2L</b></p>
<p>Figure 21 shows that the “Triangle” parameter can in principle be measured with the 1 ms,  </p>
<p>10 ms and 100 ms events. The default setting is 10 ms.</p>
<p>Measurement parameters are allocated to events in the ECU during measurement configu&shy;</p>
<p>ration by the user.</p>
<p><b>Figure 22: </b></p>
<p><b>Selecting events </b></p>
<p><b> (measurement mode) </b></p>
<p><b>for each measurement </b></p>
<p><b>parameter</b></p>
<p>After configuring the measured signals, the user starts the measurement. The XCP Master </p>
<p>lists the desired measurement parameters in what are known as DAQ lists. In these lists, the </p>
<p>measured  signals  are  each  allocated to  selected  events. This  configuration  information  is </p>
<p>sent  to  the  Slave  before  the  actual  start  of  measurement.  Then  the  Slave  knows  which </p>
<p>addresses  it  should  read  out  and transmit when  an  event  occurs. This  distribution  of the </p>
<p>measurement into a configuration phase and a measurement phase was already mentioned </p>
<p>at the very beginning of this chapter. </p>
<p>This solves both problems that occur in polling: bandwidth is used optimally, because the </p>
<p>Master  no  longer  needs  to  poll  each  value  individually  during  the  measurement  and  the </p>
<p> </p>
<p>measured values correlate with one another. </p>
<h1 style="page-break-before:always; "></h1>
<p>37</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>Figure 23: Excerpt from the CANape Trace window of a DAQ measurement</b></p>
<p>Figure 23 illustrates an example of command&shy;response communication (color highlighting) </p>
<p>between Master and Slave (overall it is significantly more extensive and is only shown in part </p>
<p>here for reasons of space). This involves transmitting the DAQ configuration to the Slave. </p>
<p>Afterwards, the measurement start is triggered and the Slave sends the requested values </p>
<p>while the Master just listens. </p>
<p>Until  now, the  selection  of  a  signal was  described  based  on  its  name  and  allocation to  a </p>
<p>measurement event. But how exactly is the configuration transferred to the XCP Slave?</p>
<p>Let us look at the problem from the perspective of memory structure in the ECU: The user </p>
<p>has selected signals and wishes to measure them. So that sending a signal value does not </p>
<p>require the use of an entire message, the signals from the Slave are combined into message </p>
<p>packets. The Slave does not create this definition of the combination independently, or else </p>
<p>the Master would not be able to interpret the data when it received the messages. There&shy;</p>
<p>fore, the Slave receives an instruction from the Master describing how it should distribute </p>
<p>the values to the messages. </p>
<p>The sequence in which the Slave should assemble the bytes into messages is defined in what </p>
<p>are known as Object Description Tables (ODTs). The address and object length are impor&shy;</p>
<p>tant to uniquely identify a measurement object. An ODT provides the allocations of RAM </p>
<p>contents from the Slave to assemble a message on the bus. According to the communica&shy;</p>
<p>tion model, this message is transmitted as a DAQ DTO (Data Transfer Object).</p>
<h1 style="page-break-before:always; "></h1>
<p>38</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>RAM Cells</p>
<p>ODT</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>...</p>
<p>...</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>PID</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p><b>Figure 24: </b></p>
<p><b>ODT: Allocation of RAM </b></p>
<p><b>addresses to DAQ DTO</b></p>
<p>Stated  more  precisely,  an  entry  in  an  ODT  list  references  a  memory  area  in  RAM  by  the </p>
<p>address and length of the object. </p>
<p>After  receiving  the  measurement  start  command,  at  some  point  an  event  occurs  that  is </p>
<p>associated with a measurement. The XCP Slave begins to acquire the data. It combines the </p>
<p>individual objects into packets and sends them on the bus. The Master reads the bus mes&shy;</p>
<p>sage and can interpret the individual data, because it has defined the allocation of individ&shy;</p>
<p>ual objects to packets itself and therefore it knows their relationships. </p>
<p>However, each packet has a maximum number of useful bytes, which depends on the trans&shy;</p>
<p>port medium that is used. In the case of CAN, this amounts to seven bytes. If more data </p>
<p>needs to be measured, an ODT is no longer sufficient. If two or more ODTs need to be used </p>
<p>to transmit the measured values, then the Slave must be able to copy the data into the cor&shy;</p>
<p>rect ODT and the Master must be able to uniquely identify the received ODTs. If multiple </p>
<p>measurement intervals of the ECU are used, the relationship between ODT and measure&shy;</p>
<p>ment interval must also be uniquely identifiable. </p>
<h1 style="page-break-before:always; "></h1>
<p>39</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>The ODTs are combined into DAQ lists in the XCP protocol. Each DAQ list contains a num&shy;</p>
<p>ber of ODTs and is assigned to an event.</p>
<p><b>ODT #2</b></p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>0</p>
<p>1</p>
<p>...</p>
<p>2</p>
<p>3</p>
<p><b>ODT #1</b></p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>0</p>
<p>1</p>
<p>...</p>
<p>2</p>
<p>3</p>
<p><b>ODT #0</b></p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>PID=0 0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>PID=1</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>PID=2</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p><b>Figure 25: </b></p>
<p><b>DAQ list with three ODTs</b></p>
<p>For  example,  if  the  user  uses  two  measurement  intervals  (=  two  different  events  in  the </p>
<p>ECU), then two DAQ lists are used as well. One DAQ list is needed per event used. Each DAQ </p>
<p>list contains the entries related to the ODTs and each ODT contains references to the values </p>
<p>in the RAM cells.</p>
<p>It is also possible for the Slave to transfer time information. A DAQ list represents the val&shy;</p>
<p>ues belonging to a specific time event. Before these values in the Slave are recorded, the </p>
<p>point in time of the event is noted and transferred within the first ODT. The timestamp is </p>
<p>implemented using a counter. The time interval at which the counter is incremented is spec&shy;</p>
<p>ified in the A2L. </p>
<p>DAQ lists are subdivided into the types: static, predefined and dynamic. </p>
<h1 style="page-break-before:always; "></h1>
<p>40</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>Static DAQ lists:</b></p>
<p>If the DAQ lists and ODT tables are permanently defined in the ECU, as is familiar from CCP, </p>
<p>they are referred to as static DAQ lists. There is no definition of which measurement para&shy;</p>
<p>meters exist in the ODT lists, rather only the framework that can be filled (in contrast to </p>
<p>this, see predefined DAQ lists).</p>
<p>In static DAQ lists, the definitions are set in the ECU code and are described in the A2L. </p>
<p> </p>
<p>Figure 26 shows an excerpt of an A2L, in which static DAQ lists are defined: </p>
<p><b>Figure 26: </b></p>
<p><b>Static DAQ lists</b></p>
<p>In the above example, there is a DAQ list with the number 0, which is allocated to a 10&shy;ms </p>
<p>event and can carry a maximum of two ODTs. The DAQ list with the number 1 has four ODTs </p>
<p>and is linked to the 100 ms event.</p>
<p>The A2L matches the contents of the ECU. In the case of static DAQ lists, the number of </p>
<p>DAQ lists and the ODT lists they each contain are defined with the download of the applica&shy;</p>
<p>tion into the ECU. If the user now attempts to measure more signals with an event than fit </p>
<p>in the allocated DAQ list, the Slave in the ECU will not be able to fulfill the requirements and </p>
<p>the configuration attempt is terminated with an error. It does not matter that the other </p>
<p>DAQ list is still fully available and therefore actually still has transmission capacity.</p>
<p><b>Predefined DAQ lists:</b></p>
<p>Entirely predefined DAQ lists can also be set up in the ECU. However, this method is practi&shy;</p>
<p>cally never used in ECUs due to the lack of flexibility for the user. It is different for analog </p>
<p>measurement  systems  which  transmit  their  data  by  XCP:  Flexibility  is  unnecessary  here, </p>
<p>since the physical structure of the measurement system remains the same over its life.</p>
<h1 style="page-break-before:always; "></h1>
<p>41</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>Dynamic DAQ lists: </b></p>
<p>A special aspect of the XCP protocol are the dynamic DAQ lists. It is not the absolute param&shy;</p>
<p>eters of the DAQ and ODT lists that are permanently defined in the ECU code here, but just </p>
<p>the parameters of the memory area that can be used for the DAQ lists. The advantage is </p>
<p>that the measurement tool has more latitude in putting together the DAQ lists and it can </p>
<p>manage the structure of the DAQ lists dynamically.</p>
<p>Various  functions  especially  designed  for  this  dynamic  management  are  available  in  XCP </p>
<p>such as ALLOC_ODT which the Master can use to define the structure of a DAQ list in the </p>
<p>Slave.</p>
<p>DAQ0</p>
<p>DAQ1</p>
<p>MIN_DAQ + DAQ_COUNT</p>
<p>ODT_ENTERIES_COUNT</p>
<p>ALLOC_ODT</p>
<p>GRANULARITY_ODT_ENTRY_SIZE_DAQ</p>
<p>ODT_COUNT</p>
<p>AL</p>
<p>L</p>
<p>OC_</p>
<p>O</p>
<p>DT_</p>
<p>E</p>
<p>N</p>
<p>T</p>
<p>R</p>
<p>Y</p>
<p>ALLOC_DAQ</p>
<p><b>Figure 27: </b></p>
<p><b>Dynamic DAQ lists</b></p>
<p>In putting together the DAQ lists, the Master must be able to distinguish whether dynamic </p>
<p>or static DAQ lists are being used, how the parameters and structures of the DAQ lists look, </p>
<p>etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>42</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.3.3 STIM Calibration Method</b></p>
<p>The XCP calibration method was already introduced in the chapter about exchanging CTOs. </p>
<p>This type of calibration exists in every XCP driver and forms the basis for calibrating objects </p>
<p>in the ECU. However, no synchronization exists between sending a calibration command and </p>
<p>an event in the ECU.</p>
<p>In contrast to this, the use of STIM is not based on exchanging CTOs, rather on the use of </p>
<p>DTOs with communication that is synchronized to an event in the Slave. The Master must </p>
<p>therefore know to which events in the Slave it can even synchronize at all. This information </p>
<p>must also exist in the A2L. </p>
<p><b>Figure 28: Event for DAQ and STIM</b></p>
<p>If the Master sends data to the Slave by STIM, the XCP Slave must be informed of the loca&shy;</p>
<p>tion in the packets at which the calibration parameters can be found. The same mechanisms </p>
<p>are used here as are used for the DAQ lists.</p>
<h1 style="page-break-before:always; "></h1>
<p>43</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>1.3.4 XCP Packet Addressing for DAQ and STIM </b></p>
<p>Addressing of the XCP packets was already discussed at the beginning of this chapter. Now </p>
<p>that the concepts of DAQ, ODT and STIM have been introduced, XCP packet addressing will </p>
<p>be presented in greater detail. </p>
<p>During transmission of CTOs, the use of a PID is fully sufficient to uniquely identify a packet; </p>
<p>however, this is no longer sufficient for transmitting measured values. The following figure </p>
<p>offers an overview of the possible addressing that could occur with the DTOs:</p>
<p><b>XCP DTO Packet</b></p>
<p>PID</p>
<p>TS</p>
<p>FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>PID</p>
<p>PID</p>
<p>PID</p>
<p>DAQ</p>
<p>DAQ</p>
<p>TS</p>
<p>Identification Field</p>
<p>Timestamp Field</p>
<p>Data Field</p>
<p><b>Figure 29: </b></p>
<p><b>Structure of the </b></p>
<p><b>XCP packet for </b></p>
<p><b>DTO transmissions</b></p>
<p><b>Transmission type: “absolute ODT numbers”</b></p>
<p>Absolute means that the ODT numbers are unique throughout the entire communication – </p>
<p>i.e. across all DAQ lists. In turn, this means that the use of absolute ODT numbers assumes </p>
<p>a transformation step that utilizes a so&shy;called “FIRST_PID for the DAQ list.</p>
<p>If a DAQ list starts with the PID j, then the PID of the first packet has the value j, the second </p>
<p>packet has the PID value j + 1, the third packet has the PID value j + 2, etc. Naturally, the </p>
<p>Slave must ensure here that the sum of FIRST_PID + relative ODT number remains below </p>
<p>the PID of the next DAQ list.</p>
<p>DAQ&shy;list: 0 </p>
<p>≤ PID ≤ k</p>
<p>DAQ&shy;list: k + 1 </p>
<p>≤ PID ≤ m</p>
<p>DAQ&shy;list: m + 1 ≤ PID ≤ n</p>
<p>etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>44</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>In this case, the identification field is very simple:</p>
<p>Identification Field</p>
<p>absolute ODT number</p>
<p>PID</p>
<p><b>Figure 30: </b></p>
<p><b>Identification field with absolute </b></p>
<p><b>ODT numbers</b></p>
<p><b>Transmission type: “relative ODT numbers and absolute DAQ lists numbers”</b></p>
<p>In this case, both the DAQ lists number and the ODT number can be transmitted in the Iden&shy;</p>
<p>tification Field. However, there is still space left over in the number of bytes that is available </p>
<p>for the information:</p>
<p>Identification Field</p>
<p>PID DAQ</p>
<p>absolute DAQ list number</p>
<p>relative ODT number</p>
<p><b>Figure 31: </b></p>
<p><b>ID field with relative ODT and absolute </b></p>
<p><b>DAQ numbers (one byte)</b></p>
<p>In the figure, one byte is available for the DAQ number and one byte for the ODT number.</p>
<p>The maximum number of DAQ lists can be transmitted using two bytes: </p>
<p>Identification Field</p>
<p>PID</p>
<p>DAQ</p>
<p>absolute DAQ list number</p>
<p>relative ODT number</p>
<p><b>Figure 32: </b></p>
<p><b>ID field with relative ODT and absolute </b></p>
<p><b>DAQ numbers (two bytes)</b></p>
<h1 style="page-break-before:always; "></h1>
<p>45</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>If it is not possible to send three bytes, it is also possible to work with four bytes by using a </p>
<p>fill byte:</p>
<p>Identification Field</p>
<p>PID</p>
<p>FILL</p>
<p>DAQ</p>
<p>absolute DAQ list number</p>
<p>for alignement</p>
<p>relative ODT number</p>
<p><b>Figure 33: </b></p>
<p><b>ID field with relative ODT and </b></p>
<p><b>absolute DAQ numbers as well as </b></p>
<p><b>fill byte (total of four bytes)</b></p>
<p>How does the XCP Master now learn which method the Slave is using? First, by the entry in </p>
<p>the A2L and second by the request to the Slave to determine which communication version </p>
<p>it has implemented.</p>
<p>The  response to the  GET_DAQ_PROCESSOR_INFO request also sets the DAQ_KEY_BYTE </p>
<p>that the Slave uses to inform the Master which transmission type is being used. If not only </p>
<p>DAQ is being used, but also STIM, the Master must use the same method for STIM that the </p>
<p>Slave uses for DAQ.</p>
<p><b>1.3.5 Bypassing = DAQ + STIM </b></p>
<p>Bypassing can be implemented by joint use of DAQ and STIM (see Figure 8) and it repre&shy;</p>
<p>sents a special form of a rapid prototyping solution. For a deeper understanding, however, </p>
<p>further details are necessary, so this method is not explained until chapter 4.5 “Bypassing”.</p>
<p><b>1.3.6. Time Correlation and Synchronization</b></p>
<p>Various mechanisms are available to the Master for correlating the timestamp of the mea&shy;</p>
<p>surement data of a Slave to the timestamps of other measurement data. In the simplest </p>
<p>form of a Slave implementation, the Slave features a clock and can access its value at any </p>
<p>time. The DAQ timestamps sent by the XCP Slave are based on this clock. Here, the Slave </p>
<p>transfers the time information in the first ODT of each DAQ event. The Slave retrieves the </p>
<p>timestamp at the point in time at which the event was initiated and at which it copies the </p>
<p>measurement data from RAM. </p>
<p>The correlation of this clock to other clocks is unknown to the Master, as the DAQ messages </p>
<p>require an undefined amount of time to reach the Master from the Slave. The clocks can be </p>
<p>correlated using the GET_DAQ_CLOCK command. Before the start of measurement, and </p>
<p>usually  at  regular  intervals,  the  Master  sends  the  GET_DAQ_CLOCK  command  and  the </p>
<h1 style="page-break-before:always; "></h1>
<p>46</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Slave responds with the current value of the Slave clock. Since the Master knows the point </p>
<p>in time at which it sent the command, it can calculate a time offset between the Master </p>
<p>clock and the Slave clock using the timestamp of the Slave and the point in time the com&shy;</p>
<p>mand was sent. </p>
<p>Naturally, this method is also afflicted with inaccuracies if the run time of the GET_DAQ_CLOCK</p>
<p> </p>
<p>command is not precisely defined or the point in time at which the clocks are read in the </p>
<p>Master  and  Slave  cannot  be  determined  precisely  when  sending/receiving  the  command. </p>
<p>This is why version 1.3 of the XCP specification provides improved methods enabling correla&shy;</p>
<p>tion of the Master and Slave clocks with a precision of just a few microseconds.</p>
<p><b>1.3.6.1 Multicast</b></p>
<p>For better correlation of the clocks of multiple Slaves to one another, the Master reads the </p>
<p>clocks of multiple Slaves at the same time. For this purpose, the Master sends a command </p>
<p>to all Slaves which are accessible using the same transport medium. Each Slave records the </p>
<p>point in time at which it receives the command and transfers the value to the Master. To </p>
<p>achieve  maximum  precision,  two  requirements  must  be  fulfilled  to  the  greatest  degree </p>
<p>possible:</p>
<p>On the one hand, the Slave implementation should ensure (as in the past) that the record&shy;</p>
<p>ing of the timestamp is initiated as soon as possible upon receipt of the command. On the </p>
<p>other hand, the latency times between the Slaves and the Master should be the same to the </p>
<p>greatest degree possible.</p>
<p>The </p>
<p>GET_DAQ_CLOCK_MULTICAST </p>
<p>command </p>
<p>is </p>
<p>available </p>
<p>for </p>
<p>this </p>
<p>purpose.  The </p>
<p>Slave </p>
<p>responds with an EV_TIME_SYNC message, in which the timestamp is transferred. </p>
<p>XCP Slave Clock</p>
<p>free running</p>
<p><b>XCP Slave</b></p>
<p><b>XCP Master</b></p>
<p>GET_DAQ_CLOCK_MULTICAST</p>
<p>EV_TIME_SYNC</p>
<p>GET_DAQ_CLOCK_MULTICAST</p>
<p>EV_TIME_SYNC</p>
<p>t</p>
<p><b>Figure 34: </b></p>
<p><b>XCP Slave with </b></p>
<p><b>free-running clock</b></p>
<h1 style="page-break-before:always; "></h1>
<p>47</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>1.3.6.2. Grandmaster Clock</b></p>
<p>A  further  solution  involves  the  time  of  the  Slave  already  being  synchronized/coordinated </p>
<p>with another clock, the so&shy;called grandmaster clock.</p>
<p><b>First, an explanation of the terms “synchronized” and “coordinated”:</b></p>
<p>Stated simply, two clocks are synchronized with one another if they supply the identical </p>
<p>timestamp when they are read at the same time.</p>
<p>In contrast, clocks which are coordinated to one another do not necessarily need to sup&shy;</p>
<p>ply the same timestamp. In both clocks, 1 second is exactly the same length.</p>
<p>IEEE 1588 with PTP (Precision Time Protocol) is used. In the first step, the XCP Master must </p>
<p>know whether the Slave is linked to an external clock. As there can be more than one grand&shy;</p>
<p>master clock in an overall system, information on the exact clock to which the Slave is linked </p>
<p>must be available to the XCP Master. </p>
<p><b>XCP Slave</b></p>
<p><b>XCP Master</b></p>
<p>GET_DAQ_CLOCK_MULTICAST</p>
<p>EV_TIME_SYNC</p>
<p>GET_DAQ_CLOCK_MULTICAST</p>
<p>EV_TIME_SYNC</p>
<p>t</p>
<p>XCP Slave Clock</p>
<p>synchronized to a</p>
<p>Grandmaster Clock</p>
<p>e.g. </p>
<p>IEEE 1588</p>
<p><b>Grandmaster Clock</b></p>
<p><b>Figure 35: The clock of the XCP Slave is synchronized with the grandmaster clock</b></p>
<h1 style="page-break-before:always; "></h1>
<p>48</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>The XCP standard supports additional scenarios which can only briefly be sketched out here </p>
<p>briefly. Further details can be found in the XCP specifications. </p>
<p>&gt;</p>
<p>  Should  it  be  possible  to  coordinate  the  XCP  Slave  clock  with  the  external  clock,  but  </p>
<p>not  synchronize  them,  there  will  be  an  offset  between  the  grandmaster  clock  and  </p>
<p>the Slave clock. The XCP Master can request the details from the Slave using the TIME_</p>
<p>CORRELATION_PROPERTIES command. </p>
<p>&gt;</p>
<p>  The free&shy;running clock of the Slave cannot be synchronized with a grandmaster clock, but </p>
<p>there is another clock in the Slave, e.g. a clock synchronized with the grandmaster clock in </p>
<p>the Ethernet PHY of the Slave. If the Master receives both times at the same point in time, </p>
<p>it can correlate the DAQ timestamp of the free&shy;running clock with the grandmaster clock </p>
<p>and its own time domain. </p>
<p>&gt;</p>
<p>  Another scenario arises when there is a free&shy;running clock of the XCP Slave and an ECU </p>
<p>clock and the DAQ timestamps originate from the ECU clock. This is the case when an </p>
<p>external XCP Slave, such as the VX1000 measurement and calibration hardware is used </p>
<p>from Vector, is used. </p>
<p>&gt;</p>
<p>  If all of the sketched solutions are combined, a total of three different clocks are involved: </p>
<p>the free&shy;running Slave clock, a clock which is synchronized with a grandmaster clock and </p>
<p>the ECU clock. </p>
<p>&gt;</p>
<p>  In the last scenario, there is no Slave clock, but there is an ECU clock which is synchronized </p>
<p>with a grandmaster clock.</p>
<p>Synchronization between the DAQ timestamps and the Master domain time can be realized </p>
<p>for all scenarios in the Master using the XCP mechanisms.</p>
<h1 style="page-break-before:always; "></h1>
<p>49</p>
<p>1.4 XCP Transport Layers </p>
<p><b>1.4 XCP Transport Layers </b></p>
<p>A main requirement in designing the XCP protocol was that it must support different trans&shy;</p>
<p>port layers. At the time this document was defined, the following layers had been defined: </p>
<p>XCP on CAN, FlexRay, Ethernet, SxI and USB. The bus systems CAN, LIN and FlexRay are </p>
<p>explained on the Vector E&shy;Learning platform, as well as an introduction to AUTOSAR. For </p>
<p>details see the website www.vector&shy;elearning.com.</p>
<p><b>1.4.1 CAN </b></p>
<p>XCP was  developed  as  a  successor  protocol  of the  CAN  Calibration  Protocols  (CCP)  and </p>
<p>must absolutely satisfy the requirements of the CAN bus. The communication over the CAN </p>
<p>bus is defined by the associated description file. Usually the DBC format is used, but in some </p>
<p>isolated cases the AUTOSAR format ARXML is being used too. </p>
<p>A CAN message is identified by a unique CAN identifier. The communication matrix is defined </p>
<p>in the description file: Who sends which message and how are the eight useful bytes of the </p>
<p>CAN bus being used? The following figure illustrates the process: </p>
<p><b>Data</b></p>
<p><b>Frame</b></p>
<p>ID=0x12</p>
<p>Sender</p>
<p>Receiver</p>
<p>ID=0x34</p>
<p>ID=0x52</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Sender</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Sender</p>
<p>Sender</p>
<p>Receiver</p>
<p>Sender</p>
<p>Sender</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>ID=0x67</p>
<p>ID=0xB4</p>
<p>ID=0x3A5</p>
<p><b>CAN </b></p>
<p><b>Node A</b></p>
<p><b>CAN</b></p>
<p><b>Node B</b></p>
<p><b>CAN</b></p>
<p><b>Node C</b></p>
<p><b>CAN</b></p>
<p><b>Node D</b></p>
<p><b>Figure 36: </b></p>
<p><b>Definition of which </b></p>
<p><b>bus nodes send which </b></p>
<p><b>messages</b></p>
<p>The message with ID 0x12 is sent by CAN node A and all other nodes on the bus receive this </p>
<p>message. In the framework of acceptance testing, CAN nodes C and D conclude that they </p>
<p>do not need the message and they reject it. CAN node B, on the other hand, determines that </p>
<p>its higher&shy;level layers need the message and they provide them via the Rx buffer. The CAN </p>
<p>nodes are interlinked as follows:</p>
<h1 style="page-break-before:always; "></h1>
<p>50</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>CAN Node A</b></p>
<p><b>CAN</b></p>
<p><b>CAN Node C</b></p>
<p><b>CAN Node D</b></p>
<p><b>CAN Node B</b></p>
<p>Host</p>
<p>Tx</p>
<p>Buffer</p>
<p>Rx</p>
<p>Buffer </p>
<p>Acceptance</p>
<p>Test</p>
<p>Receive</p>
<p>Send</p>
<p>CAN Interface</p>
<p>Host</p>
<p>Tx</p>
<p>Buffer</p>
<p>Rx</p>
<p>Buffer </p>
<p>Acceptance</p>
<p>Test</p>
<p>Receive</p>
<p>Send</p>
<p>CAN Interface</p>
<p>Host</p>
<p>Receive</p>
<p>Acceptance</p>
<p>Test</p>
<p>Rx</p>
<p>Buffer </p>
<p>Send</p>
<p>Tx</p>
<p>Buffer</p>
<p>CAN Interface</p>
<p>Host</p>
<p>Receive</p>
<p>Acceptance</p>
<p>Test</p>
<p>Rx</p>
<p>Buffer </p>
<p>Send</p>
<p>Tx</p>
<p>Buffer</p>
<p>CAN Interface</p>
<p><b>Figure 37: </b></p>
<p><b>Representation of a </b></p>
<p><b>CAN network</b></p>
<p>The XCP messages are not described in the communication matrix! If measured values are </p>
<p>sent  from  the  Slave  via  dynamic  DAQ  lists,  e.g.  with  the  help  of  XCP,  the  messages  are </p>
<p>assembled according to the signals selected by the user. If the signal selection changes, the </p>
<p>message contents change as well. Nonetheless, there is a relationship between the commu&shy;</p>
<p>nication matrix and XCP: CAN identifiers are needed to transmit the XCP messages over </p>
<p>CAN. To minimize the number of CAN identifiers used, the XCP communication is limited to </p>
<p>the use of just two CAN identifiers that are not being used in the DBC for “normal” commu&shy;</p>
<p>nication.  One  identifier  is  needed  to  send  information  from  the  Master  to  the  Slave;  the </p>
<p>other is used by the Slave for the response to the Master.</p>
<p>The excerpt from the CANape Trace window shows the CAN identifiers that are used under </p>
<p>the “ID” column. In this example, just two different identifiers are used: 554 as the ID for the </p>
<p>message from Master to Slave (direction Tx) and 555 for sending messages from the Slave </p>
<p>to the Master (direction Rx). </p>
<h1 style="page-break-before:always; "></h1>
<p>51</p>
<p>1.4 XCP Transport Layers </p>
<p><b>Figure 38: Example of XCP-on-CAN communication</b></p>
<p>In this example, the entire XCP communication is handled by the two CAN identifiers 554 </p>
<p>and 555. These two IDs may not be allocated for other purposes in this network. </p>
<p>The CAN bus transmits a maximum of eight useful bytes per message. In the case of XCP, </p>
<p>however, we need information on the command used or the sent response. This is provided </p>
<p>in the first byte of the CAN useful data. This means that seven bytes are available per CAN </p>
<p>message for transporting useful data. </p>
<p><b>Figure 39: Representation of an XCP-on-CAN message</b></p>
<p>XCP Packet</p>
<p>XCP Tail</p>
<p>FILL</p>
<p><b>XCP on CAN Message (Frame)</b></p>
<p>Control Field</p>
<p>for CAN</p>
<p>Control Field</p>
<p> empty for CAN</p>
<p>XCP Header</p>
<p>empty for CAN</p>
<p>PID</p>
<p>FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>In CANape, you will find an XCP&shy;on&shy;CAN demo with the virtual ECU XCPsim. You can learn </p>
<p>about </p>
<p>more </p>
<p>details </p>
<p>of </p>
<p>the </p>
<p>standard </p>
<p>in </p>
<p>ASAM </p>
<p>XCP </p>
<p>on </p>
<p>CAN </p>
<p>Part </p>
<p>3 </p>
<p>Transport </p>
<p>Layer </p>
<p>Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>52</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.4.2 CAN FD</b></p>
<p>CAN  FD  (CAN  with  flexible  data  rate)  is  an  extension  of  the  CAN  protocol  developed  by   </p>
<p>Robert Bosch GmbH. Its primary difference to CAN involves extending the useful data from </p>
<p>8 to  64 bytes. CAN FD also offers the option of sending the useful data at a higher data </p>
<p>rate. After the arbitration phase, the data bytes are sent at a higher transmission rate than </p>
<p>during the arbitration phase. This covers the need for greater bandwidth in automotive net&shy;</p>
<p>works while preserving valuable experience gained from CAN development.</p>
<p>The XCP&shy;on&shy;CAN&shy;FD specification was defined in the XCP&shy;on&shy;CAN description of the XCP </p>
<p>standard, Version 1.2 (June 2013). </p>
<p><b>Figure 40: Illustration of a CAN FD frame</b></p>
<p>EDL = Extended Data Length:</p>
<p> </p>
<p>CAN (dominant (0) = CAN frame</p>
<p> Recessive (1) = CAN FD frame</p>
<p>BRS = Bit Rate Switch:</p>
<p> CAN FD data phase starts immediately at sampling point of BRS:</p>
<p> </p>
<p>Dominant (0) = No change of bit rate for data phase</p>
<p> Recessive (1) = Change to higher bit rate for data phase</p>
<p>ESI = Error State Indicator:</p>
<p> </p>
<p>Dominant (0) = CAN FD node is error active</p>
<p> Recessive (1) = CAN FD node is error passive</p>
<p><b>Arbitration phase</b></p>
<p>(standard bit rate)</p>
<p><b>Arbitration phase</b></p>
<p>(standard bit rate)</p>
<p><b>Data phase</b></p>
<p>(optional high bit rate)</p>
<p>1</p>
<p>11</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>1</p>
<p>7</p>
<p>3</p>
<p>1</p>
<p>4</p>
<p>DLC</p>
<p>Data</p>
<p>CRC</p>
<p>EOF</p>
<p>IFS</p>
<p>0…512</p>
<p>17/21</p>
<p>SOF</p>
<p>Identifier</p>
<p>r1</p>
<p>IDE</p>
<p>EDL</p>
<p>r0</p>
<p>BRS</p>
<p>ESI</p>
<p>CRC Delim.</p>
<p>ACK</p>
<p>ACK Delim.</p>
<p>Despite the largely similar modes of operation, this protocol requires extensions and modifi&shy;</p>
<p>cations to the hardware and software. Among other things, CAN FD introduces three new </p>
<p>bits to the control field:</p>
<p>&gt; </p>
<p>Extended Data Length (EDL)</p>
<p>&gt; </p>
<p>Bit Rate Switch (BRS) </p>
<p>&gt; </p>
<p>Error State Indicator (ESI)</p>
<h1 style="page-break-before:always; "></h1>
<p>53</p>
<p>1.4 XCP Transport Layers </p>
<p>A recessive EDL bit (high level) distinguishes frames in extended CAN&shy;FD format from those </p>
<p>in standard CAN format, because they are identified by a dominant EDL bit (low level). Sim&shy;</p>
<p>ilarly, a recessive BRS bit causes the transmission of the data field to be switched to the </p>
<p>higher bit rate. The ESI bit identifies the error state of a CAN FD node. Another four bits </p>
<p>make  up what  is  known  as the  Data  Length  Code  (DLC), which  represents the  extended </p>
<p>useful data length as a possible value of 12, 16, 20, 24, 32, 48 and 64 bytes. </p>
<p>The use of XCP on CAN FD assumes that a second transmission rate has been defined for </p>
<p>the useful data in the A2L file. This is fully transparent to the user, who gets a complete A2L </p>
<p>parameterization. A measurement configuration in the XCP Master considers the maximum </p>
<p>packet length, and the user does not need to make any other settings. </p>
<p>CAN FD is supported in CANape, Version 12.0 and higher. Every CAN hardware product from </p>
<p> Vector which begins with “VN” supports the CAN FD transport protocol.</p>
<h1 style="page-break-before:always; "></h1>
<p>54</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.4.3 FlexRay</b></p>
<p>A  basic  idea  in  the  development  of  FlexRay  was  to  implement  a  redundant  system  with </p>
<p>deterministic time behavior. The connection redundancy was achieved by using two chan&shy;</p>
<p>nels: channel A and channel B. If multiple FlexRay nodes (= ECUs) are redundantly intercon&shy;</p>
<p>nected and one branch fails, the nodes can switch over to the other channel to make use of </p>
<p>the connection redundancy. </p>
<p><b>Figure 41: Nodes K and L are redundantly interconnected</b></p>
<p>CH A</p>
<p>CH B</p>
<p>Node K</p>
<p>Node L</p>
<p>Node M</p>
<p>Node N</p>
<p>Node O</p>
<p>Deterministic  behavior  is  achieved  by  transmitting  data  within  defined  time  slots.  Also </p>
<p>defined here is which node sends which content in which time slot. These time slots are com&shy;</p>
<p>bined to form one cycle. The cycles repeat here, as long as the bus is active. The assembly of </p>
<p>the time slots and their transport contents (who sends what at which time) is known as </p>
<p>scheduling. </p>
<p>t1</p>
<p>Slot 1</p>
<p>Slot 2</p>
<p>Slot 3</p>
<p>Slot 1</p>
<p>Slot 2</p>
<p>...</p>
<p>Real-time</p>
<p>t2</p>
<p>t3</p>
<p>t4</p>
<p>t5</p>
<p>t6</p>
<p>Communication Cycle</p>
<p>Next Communication Cycle</p>
<p>Node K</p>
<p>Node L</p>
<p>Node M</p>
<p>Frame: a</p>
<p>Frame: b</p>
<p>Frame: x</p>
<p>Frame: a</p>
<p>Frame: b</p>
<p>Frame: x</p>
<p>x</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>a</p>
<p>Direction</p>
<p>Frame</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>a</p>
<p>b</p>
<p>Direction</p>
<p>Frame</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>x</p>
<p>Direction</p>
<p>Frame</p>
<p>a</p>
<p><b>Figure 42: Communication by slot definition</b></p>
<h1 style="page-break-before:always; "></h1>
<p>55</p>
<p>1.4 XCP Transport Layers </p>
<p>In the first communication cycle, node K sends frame a in slot 1. The scheduling is also stored </p>
<p>in the software of nodes L and M. Therefore, the contents of frame a are passed to the next </p>
<p>higher communication levels. </p>
<p>Scheduling is consolidated in a description file. This is not a DBC file, as in the case of CAN, </p>
<p>rather it is a FIBEX file. FIBEX stands for “Field Bus Exchange Format” and could also be </p>
<p>used for other bus systems. However, its current use is practically restricted to the descrip&shy;</p>
<p>tion  of  the  FlexRay  bus.  FIBEX  is  an  XML  format  and  the  XCP&shy;on&shy;FlexRay  specification </p>
<p>relates to FIBEX Version 1.1.5 and FlexRay specification Version 2.1.</p>
<p><b>Static Segment</b></p>
<p>Node L</p>
<p><b>Dynamic Segment</b></p>
<p>Node M</p>
<p>Node L</p>
<p>Node O</p>
<p>Node N</p>
<p>Node L</p>
<p>Node O</p>
<p>Node L</p>
<p>Node K</p>
<p><b>ECU</b></p>
<p><b>Slot</b></p>
<p>Node K</p>
<p>Node M</p>
<p><b>Channel</b></p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p>A</p>
<p>B</p>
<p><b>6</b></p>
<p><b>0</b></p>
<p><b>1</b></p>
<p><b>2</b></p>
<p><b>3</b></p>
<p><b>4</b></p>
<p><b>5</b></p>
<p><b>63</b></p>
<p><b>Cycles</b></p>
<p><b>...</b></p>
<p> 7</p>
<p> 1</p>
<p> 3</p>
<p> 4</p>
<p> 5</p>
<p> 6</p>
<p> 2</p>
<p>b [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p>a [rep: 1] </p>
<p>d [rep: 1] </p>
<p>n [rep: 1] </p>
<p>m [rep: 1] </p>
<p>r [rep: 1] </p>
<p> u [rep: 4] </p>
<p>b [rep: 1] </p>
<p>b [rep</p>
<p>: 1]</p>
<p>x [rep: 2]</p>
<p>o [rep: 1]</p>
<p>o [rep: 1]</p>
<p>t [rep: 2]</p>
<p>w [rep: 4] </p>
<p>y [rep: 4]</p>
<p>o [rep: 1]</p>
<p>p [rep: 4]</p>
<p>v [rep: 8]</p>
<p>o [rep: 1]</p>
<p>t [rep: 2]</p>
<p>a [rep: 1]</p>
<p>d [rep: 1]</p>
<p>n [rep: 1]</p>
<p>m [rep: 1]</p>
<p>r [rep: 1]</p>
<p>o [rep: 1]</p>
<p>o [rep: 1]</p>
<p>t [rep: 2]</p>
<p>w [rep: 4]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>x [rep: 2]</p>
<p>o [rep: 1]</p>
<p>b [rep: 1]</p>
<p>y [rep: 4]</p>
<p>o [rep: 1]</p>
<p>p [rep: 4]</p>
<p>c [rep: 4]</p>
<p>c [rep: 4]</p>
<p>b [rep: 1] </p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p>b [rep: 1]</p>
<p> u [rep: 4]</p>
<p>x [rep: 2]</p>
<p>t  [rep: 2]</p>
<p>b [rep: 1]</p>
<p>x [rep: 2]</p>
<p><b>Figure 43: Representation of a FlexRay communication matrix</b></p>
<p>Another format for describing bus communication has been defined as a result of the devel&shy;</p>
<p>opment of AUTOSAR solutions: the AUTOSAR Description File, which is available in XML for&shy;</p>
<p>mat. The definition of XCP&shy;on&shy;FlexRay was taken into account in the AUTOSAR 4.0 specifi&shy;</p>
<p>cation. However, at the time of publication of this book this specification has not yet been </p>
<p>officially approved and therefore it will not be discussed further. </p>
<p>Due to other properties of the FlexRay bus, it is not sufficient to just give the slot number as </p>
<p>a reference to the contents. One reason is that multiplexing is supported: whenever a cycle </p>
<p>is repeated, the transmitted contents are not necessarily the same. Multiplexing might spec&shy;</p>
<p>ify that a certain piece of information is only sent in the slot in every second pass. </p>
<h1 style="page-break-before:always; "></h1>
<p>56</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Instead  of  indicating  the  pure  slot  number,  “FlexRay  Data  Link  Layer  Protocol  Data  Unit </p>
<p>Identifiers” (FLX_LPDU_ID) are used, which can be understood as a type of generalized Slot </p>
<p>ID. Four pieces of information are needed to describe such an LPDU:</p>
<p>&gt; </p>
<p>FlexRay Slot Identifier (FLX_SLOT_ID)</p>
<p>&gt; </p>
<p>Cycle Counter Offset (OFFSET)</p>
<p>&gt; </p>
<p>Cycle Counter Repetition (CYCLE_REPETITION)</p>
<p>&gt; </p>
<p>FlexRay Channel (FLX_CHANNEL)</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p><b>LPDU_ID</b></p>
<p>Slot ID</p>
<p>Channel A</p>
<p>Channel B</p>
<p>Cycle ID</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p><b>Figure 44: </b></p>
<p><b>Representation of the </b></p>
<p><b>FlexRay LPDUs</b></p>
<p>Scheduling also has effects on the use of XCP on FlexRay, because it defines what is sent </p>
<p>precisely. This cannot be readily defined in XCP; not until the measurement runtime does the </p>
<p>user define which measured values are sent by assembling signals. This means that it is only </p>
<p>possible to choose which aspect of XCP communication can be used in which LPDU: CTO or </p>
<p>DTO from Master to Slave or from Slave to Master.</p>
<p>The following example illustrates this process: the XCP Master may send a command (CMD) </p>
<p>in slot n and Slave A gives the response (RES) in slot n + 2. XCP&shy;on&shy;FlexRay messages are </p>
<p>always defined using LPDUs.</p>
<p>The A2L description file is needed for access to internal ECU parameters; the objects with </p>
<p>their addresses in the ECU are defined in this file. In addition, the FIBEX file is necessary, so </p>
<p>that the XCP Master knows which LPDUs it may send and to which LPDUs the XCP Slaves </p>
<p>send their responses. Communication between XCP Master and XCP Slave(s) can only func&shy;</p>
<p>tion through combination of the two files, i.e. by having an A2L file reference a FIBEX file.</p>
<h1 style="page-break-before:always; "></h1>
<p>57</p>
<p>1.4 XCP Transport Layers </p>
<p>Excerpt of an A2L with XCP&shy;on&shy;FlexRay parameter setting:</p>
<p> </p>
<p>…</p>
<p>/begin XCP_ON_FLX</p>
<p> </p>
<p>… </p>
<p>„XCPsim.xml“</p>
<p>„Cluster_1“</p>
<p> </p>
<p>… </p>
<p>In this example, “XCPsim.xml” is the reference from the A2L file to the FIBEX file. </p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p>Slot ID</p>
<p>Channel A</p>
<p>Channel B</p>
<p>Cycle ID</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p><b>XCP-dedicated LPDU_IDs</b></p>
<p><b>Figure 45: </b></p>
<p><b>Allocation of XCP </b></p>
<p><b>communication </b></p>
<p><b>to LPDUs</b></p>
<p>You can read more details about XCP on FlexRay in CANape’s Online Help. Supplied with </p>
<p>CANape is the FIBEX Viewer, which lets users conveniently view the scheduling. It is easy to </p>
<p>allocate the XCP messages to the LPDUs by making driver settings for the XCP&shy;on&shy;FlexRay </p>
<p>device in CANape.</p>
<p>The protocol is explained in detail in ASAM XCP on FlexRay Part 3 Transport Layer Specifi&shy;</p>
<p>cation. You will find an XCP&shy;on&shy;FlexRay demo in CANape with the virtual ECU XCPsim. The </p>
<p>demo requires real Vector FlexRay hardware.</p>
<p><b>1.4.4 Ethernet</b></p>
<p>XCP on Ethernet can be used with either TCP/IP or UDP/IP. TCP is a protected transport </p>
<p>protocol on Ethernet, in which the handshake method is used to detect any loss of a packet. </p>
<p>In case of packet loss, TCP organizes a repetition of the packet. UDP does not offer this pro&shy;</p>
<p>tection mechanism. If a packet is lost, UDP does not offer any mechanisms for repeated </p>
<p>sending of the lost packet on the protocol level. </p>
<p>Not only can XCP on Ethernet be used with real ECUs, it can also be used for measurement </p>
<p>and calibration of virtual ECUs. Here, a virtual ECU is understood as the use of code that </p>
<p>would other </p>
<p>wise run in the ECU as an executable program (e.g. DLL) on the PC. Entirely dif&shy;</p>
<p>ferent resources are available here compared to an ECU (CPU, memory, etc.). </p>
<h1 style="page-break-before:always; "></h1>
<p>58</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>But first the actual protocol will be discussed. IP packets always contain the addresses of </p>
<p>the sender and receiver. The simplest way to visualize an IP packet is as a type of letter that </p>
<p>contains the addresses of the recipient and the sender. The addresses of individual nodes </p>
<p>must always be unique. A unique address comprises the IP address and port number. </p>
<p><b>Figure 46: XCP packet with TCP/IP or UDP/IP</b></p>
<p>XCP Header</p>
<p>XCP Packet</p>
<p>LEN</p>
<p>CTR</p>
<p><b>XCP on Ethernet (TCP/IP and UDP/IP) Message (Frame)</b></p>
<p>Length (LEN)</p>
<p>Control Field</p>
<p>for Ethernet</p>
<p>(TCP/ IP and UDP/IP)  </p>
<p>Control Field</p>
<p>empty for Ethernet</p>
<p>(TCP&amp;IP and UDP&amp;IP)</p>
<p>XCP Tail</p>
<p>empty for Ethernet</p>
<p>(TCP/IP and UDP/IP)</p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>The header consists of a Control Field with two words in Intel format (= four bytes). These </p>
<p>words contain the length (LEN) and a counter (CTR). LEN indicates the number of bytes in </p>
<p>the XCP packet. The CTR is used to detect the packet loss. UDP/IP is not a protected proto&shy;</p>
<p>col. If a packet is lost, this is not recognized by the protocol layer. Packet loss is monitored by </p>
<p>counter information. When the Master sends its first message to the Slave, it generates a </p>
<p>counter number that is incremented with each additional transmission of a frame. The Slave </p>
<p>responds  with  the  same  pattern:  It  increments  its  own  counter  with  each  frame  that  it </p>
<p>sends.  The  counters  of  the  Slave  and  the  Master  operate  independently  of  one  another. </p>
<p>UDP/IP is well suited for sending measured values. If a packet is lost, then the measured </p>
<p> </p>
<p>values it contains are lost, resulting in a measurement gap. If this occurs infrequently, the </p>
<p>loss might just be ignored. But if the measured data is to be used as the basis for fast con&shy;</p>
<p>trol, it might be advisable to use TCP/IP.</p>
<p>An  Ethernet  packet  can  transport  multiple  XCP  packets,  but  an  XCP  packet  may  never </p>
<p>exceed the limits of a UDP/IP packet. In the case of XCP on Ethernet, there is no “Tail”, i.e. </p>
<p>an empty control field.</p>
<h1 style="page-break-before:always; "></h1>
<p>59</p>
<p>1.4 XCP Transport Layers </p>
<p><b>Detection of XCP-on-Ethernet Slaves</b></p>
<p>With version 1.3 of the XCP standard, an expansion for XCP Slave detection was defined </p>
<p>specifically for XCP on Ethernet. </p>
<p>The Master can detect the XCP Slaves using the GET_SLAVE_ID command. Here, the  Master </p>
<p>broadcasts  a  multicast  message  (IPv4)  with  the  IP  address  239.255.0.0  on  port  5556. </p>
<p>Regardless of whether or not an XCP Slave already has a connection to a Master, the Slave </p>
<p>must process the request and return a response. </p>
<p>The response of the Slave contains, among other things:</p>
<p>&gt; </p>
<p>The IP address (IPv4)</p>
<p>&gt; </p>
<p>The port number </p>
<p>&gt; </p>
<p>TCP, UDP or both</p>
<p>&gt;   </p>
<p>Information  on  the  status  of  whether  or  not  there  is  already  a  connection  to  an  XCP </p>
<p>Master</p>
<p>You will find more detailed information on the protocol in ASAM XCP on Ethernet Part 3 </p>
<p>Transport Layer Specification. In CANape, you will also find an XCP on Ethernet demo with </p>
<p>the virtual ECU XCPsim or with virtual ECUs in the form of DLLs, which have been imple&shy;</p>
<p>mented by Simulink models and the Simulink Coder.</p>
<p><b>1.4.5 SxI </b></p>
<p>SxI is a collective term for SPI or SCI. Since they are not buses, but instead are controller </p>
<p>interfaces which are only suited for point&shy;to&shy;point connections, there is no addressing in this </p>
<p>type of transmission. The communication between any two nodes runs either synchronously </p>
<p>or asynchronously.</p>
<p><b>Figure 47: XCP-on-SxI packet</b></p>
<p>XCP Header</p>
<p>XCP Packet</p>
<p>XCP Tail</p>
<p><b>XCP on Sxl Message (Frame)</b></p>
<p>Length (LEN)</p>
<p>Checksum (CS)</p>
<p>Control Field</p>
<p>for SxI </p>
<p>Control Field</p>
<p>for SxI</p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>LEN</p>
<p>CTR</p>
<p>FILL</p>
<p>CS</p>
<p>The XCP header consists of a control field with two pieces of information: the length LEN </p>
<p>and the counter. The length of these parameters may be in bytes or words (Intel format). </p>
<p>LEN indicates the number of bytes of the XCP packet. The CTR is used to detect the loss of </p>
<p>a packet. This is monitored in the same way as for XCP on Ethernet: with counter informa&shy;</p>
<h1 style="page-break-before:always; "></h1>
<p>60</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>tion. Under certain circumstances it may be necessary to add fill bytes to the packet, e.g. if </p>
<p>SPI  is  used  in  WORD  or  DWORD  mode  or  to  avoid  the  message  being  shorter  than  the </p>
<p> </p>
<p>minimal packet length. These fill bytes are appended in the control field.</p>
<p>You will find more detailed information on the protocol in ASAM XCP on SxI Part 3 Transport </p>
<p>Layer Specification.</p>
<p><b>1.4.6 USB </b></p>
<p>Currently, XCP on USB has no practical significance. Therefore, no further mention will be </p>
<p>made  of  this  topic;  rather  we  refer you  to ASAM  documents  that  describe  the  standard: </p>
<p>ASAM XCP on USB Part 3 Transport Layer Specification.</p>
<p><b>1.4.7 LIN </b></p>
<p>At this time, ASAM has not yet defined an XCP&shy;on&shy;LIN standard. However, a solution exists </p>
<p>from Vector (XCP&shy;on&shy;LIN driver and CANape as XCP&shy;on&shy;LIN Master), which violates neither </p>
<p>the LIN nor the XCP specification and is already being used on some customer projects. For </p>
<p>more detailed information, please contact Vector.</p>
<h1 style="page-break-before:always; "></h1>
<p>61</p>
<p>1.5 XCP Services</p>
<p><b>1.5 XCP Services</b></p>
<p>This chapter contains a listing and explanation of other services that can be realized over </p>
<p>XCP. They are all based on the already described mechanisms of communication with the </p>
<p>help of CTOs and DTOs. Some XCP services have already been explained, e.g. synchronous </p>
<p>data acquisition/stimulation and read/write access to device memory. </p>
<p>The XCP specification does indeed uniquely define the different services; at the same time it </p>
<p>indicates whether the service always needs to be implemented or whether it is optional. For </p>
<p>example, an XCP Slave must support “Connect” for the Master to set up a connection. On </p>
<p>the other hand, flashing over XCP is not absolutely necessary and the XCP Slave does not </p>
<p>need to support it. This simply depends on the requirements of the project and the software. </p>
<p>All of the services described in this chapter are optional. </p>
<p><b>1.5.1 Memory Page Switching </b></p>
<p>As  already  explained  in  the  description  of  calibration  concepts,  parameters  are  normally </p>
<p>located in flash memory and are copied to RAM as necessary. Some calibration concepts </p>
<p>offer the option of switching memory segment pages from RAM and Flash. XCP describes a </p>
<p>somewhat more general, generic approach, in which a memory segment may contain multi&shy;</p>
<p>ple switchable pages. Normally, this consists of a RAM page and a flash page. But multiple </p>
<p>RAM pages or the lack of a flash page are conceivable as well. </p>
<p>For a better understanding of the XCP commands for page switching, the concepts of sec&shy;</p>
<p>tor, segment and page will be explained once again at this point.</p>
<p>Segment 0</p>
<p>Page 0</p>
<p>Segmemt 0</p>
<p>Segment 1</p>
<p>Page 0</p>
<p>Segment 1</p>
<p>Page 1</p>
<p>Segment 1</p>
<p>Page 2</p>
<p>Segmemt 1</p>
<p>ECU access</p>
<p>address</p>
<p>XCP access</p>
<p>Sector 2</p>
<p>Sector 1</p>
<p>Sector 0</p>
<p><b>Figure 48: </b></p>
<p><b>Memory representation</b></p>
<h1 style="page-break-before:always; "></h1>
<p>62</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>From an XCP perspective, the memory of a Slave consists of a continuous memory that is </p>
<p>addressed  with  a  40&shy;bit  width.  The  physical  layout  of  the  memory  is  based  on  sectors. </p>
<p>Know </p>
<p>ledge of the flash sectors is absolutely necessary in flashing, because the flash mem&shy;</p>
<p>ory can only be erased a block at a time. </p>
<p>The logical structure is based on what are known as segments; they describe where calibra&shy;</p>
<p>tion data is located in memory. The start address and parameters of a segment do not have </p>
<p>to be aligned with the start addresses and parameters of the physical sectors. Each seg&shy;</p>
<p>ment  can  be  subdivided  into  multiple  pages.  The  pages  of  a  segment  describe  the  same </p>
<p>parameters at the same addresses. The values of these parameters and read/write rights </p>
<p>can be controlled individually for each page. </p>
<p>The allocation of an algorithm to a page within a segment must always be unique. Only one </p>
<p>page may be active in a segment at any given time. This page is known as the “active page </p>
<p>for the ECU in this segment.” The particular page that the ECU and the XCP driver actively </p>
<p>access can be individually switched. No interdependency exists between these settings. Sim&shy;</p>
<p>ilar to the naming convention for the ECU, the active page for XCP access is referred to as </p>
<p>the “active page for XCP access in this segment“. </p>
<p>In turn, this applies to each individual segment. Segments must be listed in the A2L file and </p>
<p>each segment gets a number that is used to reference the segment. Within an XCP Slave, </p>
<p>the SEGMENT_NUMBER must always begin at 0 and it is then incremented in consecutive </p>
<p>numbers. Each segment has at least one page. The pages are also referenced by numbers. </p>
<p>The first page is PAGE 0. One byte is available for the number, so that a maximum of 255 </p>
<p>pages can be defined per segment. </p>
<p>The </p>
<p>Slave </p>
<p>must </p>
<p>initialize </p>
<p>all </p>
<p>pages  for </p>
<p>all </p>
<p>segments.  The </p>
<p>Master </p>
<p>uses  the </p>
<p>command  </p>
<p>GET_CAL_PAGE to ask the Slave which page is currently active for the ECU and which page </p>
<p>for XCP access. It can certainly be the case that mutual blocking may be necessary for the </p>
<p>accesses. For example, the XCP Slave may not access a page, if this page is currently active </p>
<p>for the ECU. As mentioned, there may be a dependency – but not necessarily. It is a question </p>
<p>of how the Slave has been implemented. </p>
<p>If the Slave supports the optional commands GET_CAL_PAGE and SET_CAL_PAGE, then it </p>
<p>also supports what is known as page switching. These two commands let the Master poll </p>
<p>which pages are currently being used and if necessary it can switch pages for the ECU and </p>
<p>XCP access. The XCP Master has full control over switching of pages. The XCP Slave cannot </p>
<p>initiate  switching  by  itself.  But  naturally  the  Master  must  respect  any  restrictions  of  the </p>
<p>Slave implementation. </p>
<p>What is the benefit of switching?</p>
<p>First, switching permits very quick changing of entire parameter sets – essentially a before&shy;</p>
<p>and&shy;after comparison. Second, the plant remains in a stable state, while the calibrator per&shy;</p>
<p>forms extensive parameter changes on another page in the ECU. This prevents the plant </p>
<p>from going into a critical or unstable state, e.g. due to incomplete datasets during para&shy;</p>
<p>meter setting.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>63</p>
<p>1.5 XCP Services</p>
<p><b>1.5.2 Saving Memory Pages – Data Page Freezing </b></p>
<p>When a calibrator calibrates parameters on a page, there is the conceptual ability in XCP to </p>
<p>save the data directly in the ECU. This involves saving the data of a RAM page to a page in </p>
<p>nonvolatile memory. If the nonvolatile memory is flash, it must be taken into account that </p>
<p>the segment start address and the segment size might not necessarily agree with the flash </p>
<p>sectors, which represents a problem in erasing and rewriting the flash memory (see ASAM </p>
<p>XCP Part 2 Protocol Layer Specification).</p>
<p><b>1.5.3 Flash Programming </b></p>
<p>Flashing means writing data in an area of flash memory. This requires precise knowledge of </p>
<p>how the memory is laid out. A flash memory is subdivided into multiple sectors (physical sec&shy;</p>
<p>tions), which are described by a start address and a length. To distinguish them from one </p>
<p>another, they  each  get  a  consecutive  identification  number.  One  byte  is  available for this </p>
<p>number, resulting in a maximum of 255 sectors. </p>
<p>SECTOR_NUMBER [0, 1, 2 … 255]</p>
<p>The information about the flash sectors is also part of the A2L data set.</p>
<p><b>Figure 49: </b></p>
<p><b>Representation </b></p>
<p><b>of driver settings </b></p>
<p><b>for the flash area</b></p>
<h1 style="page-break-before:always; "></h1>
<p>64</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Flashing can be implemented using what are referred to as “flash kernels”. A flash kernel is </p>
<p>executable code that is sent to the Slave’s RAM area before the actual flashing; the kernel </p>
<p>then handles communication with the XCP Master. It might contain the algorithm that is </p>
<p>responsible for erasing the flash memory. For security and space reasons, very frequently </p>
<p>this code is not permanently stored in the ECU’s flash memory. Under some circumstances, </p>
<p>a converter might be used, e.g. if checksum or similar computations need to be performed.</p>
<p>Flashing with XCP roughly subdivides the overall flash process into three areas:</p>
<p>&gt;   </p>
<p>Preparation (e.g. for version control and therefore to check whether the new contents can </p>
<p>even be flashed)</p>
<p>&gt;   </p>
<p>Execution (the new contents are sent to the ECU) </p>
<p>&gt;   </p>
<p>Post&shy;processing (e.g. checksum checking etc.)</p>
<p>In the XCP standard, the primary focus is directed to the actual execution of flashing. Any&shy;</p>
<p>one who compares this operation to flashing over diagnostic protocols will discover that the </p>
<p>process&shy;specific elements, such as serial number handling with meta&shy;data, are supported in </p>
<p>a rather spartan fashion in XCP. Flashing in the development phase was clearly the main </p>
<p>focus in its definition and not the complex process steps that are necessary in end&shy;of&shy;line </p>
<p>flashing.</p>
<p>Therefore, what is important in the preparation phase is to determine whether the new con&shy;</p>
<p>tents  are  even  relevant  to  the  ECU.  There  are  no  special  commands  for  version  control. </p>
<p>Rather the practice has been to support those commands specific to the project. </p>
<p>The following XCP commands are available:</p>
<p>PROGRAM_START: Beginning of the flash procedure</p>
<p>This command indicates the beginning of the flash process. If the ECU is in a state that does </p>
<p>not permit flashing (e.g. vehicle speed &gt; 0), the XCP Slave must acknowledge with an ERRor. </p>
<p>The actual flash process may not begin until the PROGRAM_START has been successfully </p>
<p>acknowledged by the Slave.</p>
<p>PROGRAM_CLEAR: Call the current flash memory erasing routine </p>
<p>Before flash memory can be overwritten with new contents, it must first be cleared. The call </p>
<p>of the erasing routine via this command must be implemented in the ECU or be made avail&shy;</p>
<p>able to the ECU with the help of the flash kernel.</p>
<p>PROGRAM_FORMAT: Select the data format for the flash data </p>
<p>The XCP Master uses this command to define the format (e.g. compressed or encrypted) in </p>
<p>which the data are transmitted to the Slave. If the command is not sent, the default setting </p>
<p>is non&shy;compressed and non&shy;encrypted transmission.</p>
<p>PROGRAM: Transfer the data to the XCP Slave</p>
<p>For the users who are very familiar with flashing via diagnostics: this command corresponds </p>
<p>to  TRANSFERDATA  in  diagnostics.  Using  this  command,  data  is  transmitted  to  the  XCP </p>
<p>Slave, which is then stored in flash memory.</p>
<h1 style="page-break-before:always; "></h1>
<p>65</p>
<p>1.5 XCP Services</p>
<p>PROGRAM_VERIFY: Request to check the new flash contents</p>
<p>The Master can request that the Slave perform an internal check to determine whether the </p>
<p>new contents are OK. </p>
<p>PROGRAM_RESET: Reset request to the Slave</p>
<p>Request by the Master to the Slave to execute a Reset. Afterwards, the connection to the </p>
<p>Slave is always terminated and a new CONNECT must be sent.</p>
<p><b>1.5.4 Automatic Detection of the Slave </b></p>
<p>The  XCP  protocol  lets  the  Master  poll  the  Slave  about  its  protocol&shy;specific  properties.  A </p>
<p>number of commands are available for this.</p>
<p>GET_COMM_MODE_INFO</p>
<p>The response to this command gives the Master information about the various communica&shy;</p>
<p>tion  options  of  the  Slave,  e.g.  whether  it  supports  block  transfer  or  interleaved  mode  or </p>
<p>which minimum time intervals the Master must maintain between requests in these modes. </p>
<p>GET_STATUS</p>
<p>The  response  to  this  request  returns  all  current  status  information  of  the  Slave.  Which </p>
<p>resources (calibration, flashing, measurement, etc.) are supported? Are any types of mem&shy;</p>
<p>ory  activities  (DAQ  list  configuration,  etc.)  still  running  currently?  Are  DTOs  (DAQ,  STIM) </p>
<p>being exchanged right now?</p>
<p>GET_DAQ_PROCESSOR_INFO</p>
<p>The Master gets general information, which it needs to know about the Slave limitations: </p>
<p>number of predefined DAQ lists, available DAQ lists and events, etc.</p>
<p>GET_DAQ_RESOLUTION_INFO</p>
<p>Other information about the DAQ capabilities of the Slave is exchanged via this command: </p>
<p>maximum number of parameters for an ODT for DAQ and for STIM, granularity of the ODT </p>
<p>entries, number of bytes in timestamp transmission, etc.</p>
<p>GET_DAQ_EVENT_INFO</p>
<p>When this command is used, the call is made once per ECU event. Information is transmit&shy;</p>
<p>ted here on whether the event can be used for DAQ, STIM or DAQ/STIM, whether the event </p>
<p>occurs periodically and if so which cycle time it has, etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>66</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.5.5 Block Transfer Mode for Upload, Download and Flashing </b></p>
<p>In the “normal” communication mode, each command from the Master is acknowledged by </p>
<p>a response of the Slave. However, in some cases it may be desirable, for performance rea&shy;</p>
<p>sons, to use what is referred to as the block transfer mode. </p>
<p>MIN_ST</p>
<p>MAX_BS</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Response k</p>
<p>Request k+1</p>
<p>Request k</p>
<p>Part1</p>
<p>Part3</p>
<p>Part2</p>
<p><b>Figure 50: </b></p>
<p><b>Representation of the block transfer mode</b></p>
<p>The use of such a method accelerates the procedure when transmitting large amounts of </p>
<p>data (UPLOAD, SHORT_UPLOAD, DOWNLOAD, SHORT_DOWNLOAD and PROGRAM). The </p>
<p>Master can find out whether the Slave supports this method with the request GET_COMM_</p>
<p>MODE_INFO. You will find more on this in ASAM XCP Part 2 Protocol Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>67</p>
<p>1.5 XCP Services</p>
<p><b>1.5.6 Cold Start Measurement (during Power-On) </b></p>
<p>Even with the capabilities of XCP described to this point, it would be impossible to imple&shy;</p>
<p>ment an event&shy;driven measurement that can in practice be executed early in the ECU’s start </p>
<p>phase. The reason is that the measurement must be configured before the actual measure&shy;</p>
<p>ment takes place. If one attempts to do this, the ECU’s start phase has long been over by </p>
<p>the time the first measured values are transmitted. The approach that is used to overcome </p>
<p>this problem is based on a simple idea. </p>
<p>It involves separating the configuration and the measurement in time. After the configura&shy;</p>
<p>tion phase, the measurement is not started immediately; rather the ECU is shut down. After </p>
<p>a reboot, the XCP Slave accesses the existing configuration directly and immediately begins </p>
<p>to send the first messages. The difficulties associated with this are obvious: the configura&shy;</p>
<p>tion of the DAQ lists is stored in RAM, and therefore the information no longer exists after </p>
<p>a reboot. </p>
<p>To enable what is known as the RESUME mode to enable a Cold Start Measurement, a non&shy;</p>
<p>volatile  memory  is  needed  in  the XCP  Slave  which  preserves  its  data  even when  it  is  not </p>
<p>being supplied with power. EEPROMs are used in this method. In this context, it is irrelevant </p>
<p>whether it is a real EEPROM or one that is emulated by a flash memory.</p>
<p>You will find more details in ASAM XCP Part 1 Overview Specification in the chapter 1.4.2.2 </p>
<p>“Advanced Features”.</p>
<h1 style="page-break-before:always; "></h1>
<p>68</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1.5.7 Security Mechanisms with XCP </b></p>
<p>An unauthorized user should be prevented as much as possible from being able to make a </p>
<p>connection to an ECU. The “seed &amp; key” method is available for checking whether or not a </p>
<p>connection attempt is authorized. The three different access types can be protected by seed </p>
<p>&amp; key: measurement / stimulation, calibration and flashing.</p>
<p>The  “seed  &amp;  key”  method  operates  as  follows:  in  the  connect  request  by  the  Master,  the </p>
<p>Slave sends a random number (= seed) to the Master. Now, the Master must use an algo&shy;</p>
<p>rithm to generate a response (= key). The key is sent to the Slave. The Slave also computes </p>
<p>the expected response and compares the key of the Master with its own result. If the two </p>
<p>results  agree,  both  the  Master  and  Slave  have  used  the  same  algorithm.  Then  the  Slave </p>
<p>accepts the connection to the Master. If there is no agreement, the Slave declines commu&shy;</p>
<p>nication with the Master.</p>
<p>Normally, the algorithm is available as a DLL in the Master. So, if a user has the “seed &amp; key” </p>
<p>DLL and the A2L file, nothing stands in the way of accessing the ECU’s memory. When the </p>
<p>ECU  is  approaching  a  production  launch,  the  XCP  driver  is  often  deactivated.  A  unique </p>
<p>sequence of individual diagnostic commands is usually used to restore XCP access to the </p>
<p>ECU. This makes the XCP driver largely available even in production vehicles, but it is nor&shy;</p>
<p>mally deactivated to protect against unauthorized manipulation of the ECU (see ASAM XCP </p>
<p>Part 2 Protocol Layer Specification). </p>
<p>Whether or not seed &amp; key or deactivation of the XCP driver is used in a project is implemen&shy;</p>
<p>tation&shy;specific and independent of the XCP specification. </p>
<h1 style="page-break-before:always; "></h1>
<p>71</p>
<p>2 ECU Description File A2L</p>
<p><b>2 ECU Description File A2L </b></p>
<h1 style="page-break-before:always; "></h1>
<p>72</p>
<p>2 ECU Description File A2L</p>
<p>One reason why an A2L file is needed has already been named: to allocate symbolic names </p>
<p>to addresses. For example, if a software developer has implemented a PID controller and </p>
<p>assigned the names P1, I1 and D1 in his application for the proportional, integral and differ&shy;</p>
<p>ential components, then the calibrator should be able to access these parameters with their </p>
<p>symbolic names. Let us take the following figure as an example:</p>
<p><b>Figure 51: </b></p>
<p><b>Parameters in a calibration window</b></p>
<p>The user can conveniently modify values using symbolic names. Another example is provided </p>
<p>by viewing signal variables that are measured from the ECU:</p>
<p><b>Figure 52: Signal response over time</b></p>
<p>In the legend, the user can read the logical names of the signals. The addresses at which the </p>
<p>parameters were located in the ECU are of secondary importance in the offline analysis of </p>
<p>values. Naturally, the correct address is needed to request the values in the ECU, but the </p>
<p>numeric value of the address itself is of no importance to the user. The user uses the logical </p>
<p>name  for  selection  and  visualization  purposes.  That  is,  the  user  selects  the  object  by  its </p>
<p>name and the XCP Master looks for the associated address and data type in the A2L.</p>
<h1 style="page-break-before:always; "></h1>
<p>73</p>
<p>2 ECU Description File A2L</p>
<p>Another attribute of a parameter might be the definition of a minimum or maximum value. </p>
<p>The value of the object would then have to lie within these limits. Imagine that you as the </p>
<p>software developer define a parameter that has a direct effect on a power output stage. </p>
<p>You must now prevent the user – whatever the user’s reasons might be – from configuring </p>
<p>the  output  stage  that  would  result  in  catastrophic  damage.  You  can  accomplish  this  by </p>
<p>defining minimum and maximum values in the A2L to limit the permitted values. </p>
<p>Rules for conversion between physical and raw values are also defined in the A2L. You can </p>
<p>visualize a simple example of such a conversion rule in a sensor that has an 8&shy;bit value. The </p>
<p>numeric values output by the sensor lie between 0 and 255, but you wish to see the value as </p>
<p>a percentage value. Mapping of the sensor value [0 … 255] to [0 … 100 %] is performed with </p>
<p>a conversion rule, which in turn is stored in the A2L. If an object is measured, which exists as </p>
<p>a raw value in the ECU and is also transmitted as such, the measurement and calibration </p>
<p>tool uses the stored formula and visualizes the physical value.</p>
<p>Besides scalar parameters, characteristic curves and maps are frequently used. Some might </p>
<p>utilize a proximity sensor such as a Hall sensor, which determines distance as a function of </p>
<p>magnetic field strength and you may wish to use this distance value in your algorithm. The </p>
<p>magnetic  field  and  distance  value  do  not  run  linear  to  one  another.  This  nonlinearity  of </p>
<p> values would make formulation of the algorithm unnecessarily difficult. With the help of a </p>
<p>characteristic curve, you can first linearize the values before you input the values into your </p>
<p>algorithm as input variables.</p>
<p>Another  application  area  for  characteristic  maps  is  their  use  as  substitutes  for  complex </p>
<p>computations. For example, if there is a relationship y = f(x) and the function f is associated </p>
<p>with  a  lot  of  computing  effort,  it  is  often  simpler  to  simply  compute  the  values  over  the </p>
<p>potential range of x in advance and store the results in the form of a table (= characteristic </p>
<p>curve). If the value x is now in the ECU, the value y does not need to be computed at the con&shy;</p>
<p>troller’s runtime, rather the map returns the result y to the input variable x. It may be neces&shy;</p>
<p>sary to interpolate between two values, but that would be the extent of the calculations. </p>
<p>How is this characteristic curve stored in memory? Are all x values input first and then all y </p>
<p>values? Or does storage follow the pattern: x1, y1; x2, y2; x3, y3 …? Since various options are </p>
<p>available, the type of memory storage is defined in a storage scheme in the A2L. </p>
<p>The convenience for the user comes from the ability to work with symbolic names for param&shy;</p>
<p>eters, the direct look at the physical values and access to complex elements such as charac&shy;</p>
<p>teristic maps, without having to concern oneself with complex storage schemes.</p>
<p>Another advantage is offered by the communication parameters. They are also defined in </p>
<p>the A2L. In the communication between the measurement and calibration tool and the ECU, </p>
<p>the parameter set from the A2L is used. The A2L contains everything that the measurement </p>
<p>and calibration tool needs to communicate with the ECU. </p>
<h1 style="page-break-before:always; "></h1>
<p>74</p>
<p>2 ECU Description File A2L</p>
<p><b>2.1 Setting Up an A2L File for an XCP Slave </b></p>
<p>The  A2L  file  is  an  ASCII&shy;readable  file,  which  describes  the  following  with  the  help  of </p>
<p>keywords:</p>
<p>&gt;   </p>
<p>Interface&shy;specific  parameters  between  measurement  and  calibration  tool  and  A2L  file </p>
<p>(the description is located at the beginning of the A2L file and is located in what is referred </p>
<p>to as the AML tree),</p>
<p>&gt;   </p>
<p>Communication to the ECU,</p>
<p>&gt;   </p>
<p>Storage scheme for characteristic curves and maps (keyword RECORD_LAYOUT),</p>
<p>&gt;   </p>
<p>Conversion rules for converting raw values to physical values (keyword COMPU_METHOD),</p>
<p>&gt;   </p>
<p>Measurement parameters (keyword MEASUREMENT),</p>
<p>&gt;   </p>
<p>Calibration parameters (keyword CHARACTERISTIC) and</p>
<p>&gt;   </p>
<p>Events that are relevant for triggering a measurement keyword EVENT),</p>
<p>A summary of parameters and measurement parameters is made with the help of groups </p>
<p>(keyword GROUP).</p>
<p>Example of a measurement parameter with the name “Shifter_B3”:</p>
<p>    /begin MEASUREMENT Shifter_B3 „Single bit signal (bit from a byte shifting)“</p>
<p>      UBYTE HighLow 0 0 0 1</p>
<p>      READ_WRITE</p>
<p>      BIT_MASK 0x8</p>
<p>      BYTE_ORDER MSB_LAST</p>
<p>      ECU_ADDRESS 0x124C02</p>
<p>      ECU_ADDRESS_EXTENSION 0x0</p>
<p>      FORMAT „%.3“</p>
<p>      /begin IF_DATA CANAPE_EXT</p>
<p>        100</p>
<p>        LINK_MAP „byteShift“ 0x124C02 0x0 0 0x0 1 0x87 0x0</p>
<p>        DISPLAY 0 0 20</p>
<p>      /end IF_DATA</p>
<p>    /end MEASUREMENT</p>
<p>Example of a parameter map with the name KF1:</p>
<p>    /begin CHARACTERISTIC KF1 „8*8 BYTE no axis“</p>
<p>      MAP 0xE0338 __UBYTE_Z 0 Factor100 0 2.55</p>
<p>      ECU_ADDRESS_EXTENSION 0x0</p>
<p>      EXTENDED_LIMITS 0 2.55</p>
<p>      BYTE_ORDER MSB_LAST</p>
<p>      BIT_MASK 0xFF</p>
<p>      /begin AXIS_DESCR</p>
<p>        FIX_AXIS NO_INPUT_QUANTITY BitSlice.CONVERSION 8 0 7</p>
<p>        EXTENDED_LIMITS 0 7</p>
<h1 style="page-break-before:always; "></h1>
<p>75</p>
<p>2.1 Setting Up an A2L File for an XCP Slave</p>
<p>        READ_ONLY</p>
<p>        BYTE_ORDER MSB_LAST</p>
<p>        FORMAT „%.0“</p>
<p>        FIX_AXIS_PAR_DIST 0 1 8</p>
<p>      /end AXIS_DESCR</p>
<p>      /begin AXIS_DESCR</p>
<p>        FIX_AXIS NO_INPUT_QUANTITY BitSlice.CONVERSION 8 0 7</p>
<p>        EXTENDED_LIMITS 0 7</p>
<p>        READ_ONLY</p>
<p>        BYTE_ORDER MSB_LAST</p>
<p>        FORMAT „%.0“</p>
<p>        FIX_AXIS_PAR_DIST 0 1 8</p>
<p>      /end AXIS_DESCR</p>
<p>      /begin IF_DATA CANAPE_EXT</p>
<p>        100</p>
<p>        LINK_MAP „map3_8_8_uc“ 0xE0338 0x0 0 0x0 1 0x87 0x0</p>
<p>        DISPLAY 0 0 255</p>
<p>      /end IF_DATA</p>
<p>      FORMAT „%.3“</p>
<p>    /end CHARACTERISTIC</p>
<p>The ASCII text is not easy to understand. You will find a description of its structure in ASAM </p>
<p>XCP Part 2 Protocol Layer Specification in chapter 2.</p>
<p>The sections below describe how to create an A2L. Let us focus on the actual contents of an </p>
<p>A2L and their meanings and leave the details of the A2L description language to an editor. </p>
<p>The A2L Editor that is supplied with CANape is used here. </p>
<p><b>2.2 Manually Creating an A2L File</b></p>
<p>The A2L mainly describes the contents of the memory of the XCP Slave. The contents depend </p>
<p>on the application in the Slave, which was developed as C code. After the compiler/linker run </p>
<p>of the application code, important elements of an A2L file already exist in the linker&shy;map file: </p>
<p>the  names  of  the  objects,  their  data  types  and  memory  addresses.  Still  lacking  are  the </p>
<p>parameters for communication between XCP Master and Slave. Other information is usually </p>
<p>needed  such  as  minimum  and  maximum  values  of  parameters,  conversion  rules,  storage </p>
<p>schemes for characteristic maps etc.</p>
<p>Let us begin by creating an empty A2L and the communication parameters: If you wish to </p>
<p>create an A2L that describes an ECU with an XCP&shy;on&shy;CAN interface, for example, you cre&shy;</p>
<p>ate a new device in CANape and select XCP on CAN as the interface. Then you can supple&shy;</p>
<p>ment this with other communication&shy;specific information (e.g. CAN identifiers). After saving </p>
<p>the file, you have an A2L that contains the entire communication content of the A2L. Still </p>
<p>lacking are the definitions of the actual measurement and calibration parameters. </p>
<h1 style="page-break-before:always; "></h1>
<p>76</p>
<p>2 ECU Description File A2L</p>
<p>In the A2L Editor, the linker&shy;map file is associated to the A2L. In a selection dialog, the user </p>
<p>can  now  select  those  parameters  from  the  map  file  which  it  needs  in  the  A2L:  scalar </p>
<p> </p>
<p>measurement  and  calibration  parameters,  characteristic  curves  and  maps.  The  user  can </p>
<p>gradually add the desired parameters to the A2L step by step and group them. Other object&shy;</p>
<p>specific information is also added using the editor. </p>
<p>What should be done when you modify your code, recompile it and link it? It is highly proba&shy;</p>
<p>ble that the addresses of objects will change. Essentially, it is not necessary to generate a </p>
<p>new A2L. If you wish to have objects just added to the code also be available in the A2L, you </p>
<p>must of course add them to the A2L. Address updating is always necessary in the A2L. This </p>
<p>is done with the editor; it searches for the relevant entry in the linker&shy;map file based on the </p>
<p>name of the A2L object, reads out the address and updates it in the A2L.</p>
<p>If your application changes very dynamically – objects are renamed, data types are adapted, </p>
<p>parameters are deleted and others added – then the manual work method is impractical. To </p>
<p>generate an A2L from a C code, other tools are available for automatic processing. </p>
<p>On the Vector homepage you will find information on the “ASAP2 Tool&shy;Set“ with which you </p>
<p>can automate the generation of A2Ls from the source code in a batch process.</p>
<p><b>2.3 A2L Contents versus ECU Implementation</b></p>
<p>When an XCP Master tool reads in an A2L that does not fully match the ECU, misunder&shy;</p>
<p>standings in the communication might occur. For example, another value related to time&shy;</p>
<p>stamp resolution might be in the A2L file that differs from the value implemented in the </p>
<p>ECU. If this is the case, the problem must be detected and solved. The user gets support </p>
<p>from the Master, who can poll the Slave via the protocol to determine what was really imple&shy;</p>
<p>mented in the Slave. </p>
<p>XCP offers a number of functions that were developed for automatic detection of the Slave. </p>
<p>Of course, this assumes that automatic detection is implemented in the Slave. If the Master </p>
<p>polls the Slave and the Slave’s responses do not agree with the parameter set of the A2L </p>
<p>description file, the Master must decide which settings to use. In CANape, the information </p>
<p>that is read out by the Slave is given a higher priority than the information from the A2L.</p>
<h1 style="page-break-before:always; "></h1>
<p>77</p>
<p>2.3 A2L Contents versus ECU Implementation</p>
<p>Here is an overview of possible commands that are used to find out something about the </p>
<p>XCP implementation in the Slave:</p>
<p>GET_DAQ_PROCESSOR_INFO</p>
<p>Returns </p>
<p>general </p>
<p>information </p>
<p>on </p>
<p>the </p>
<p>DAQ </p>
<p>lists: </p>
<p>MAX_DAQ, </p>
<p>MAX_EVENT_CHANNEL, </p>
<p>MIN_DAQ</p>
<p>GET_DAQ_RESOLUTION_INFO </p>
<p>Maximum parameter of an ODT entry for DAQ/STIM, time interval information</p>
<p>GET_DAQ_EVENT_INFO (Event_channel_number)</p>
<p>Returns information for a specific time interval: Name and resolution of the time interval, </p>
<p>number of DAQ lists that may be assigned to this time interval …</p>
<p>GET_DAQ_LIST_INFO (DAQ_List_Number)</p>
<p>Returns information on the selected DAQ list: MAX_ODT, MAX_ODT_ENTRIES exist as pre&shy;</p>
<p>defined DAQ lists …</p>
<h1 style="page-break-before:always; "></h1>
<p>79</p>
<p>3 Calibration Concepts</p>
<p><b>3 Calibration Concepts</b></p>
<h1 style="page-break-before:always; "></h1>
<p>80</p>
<p>3 Calibration Concepts</p>
<p>ECU  parameters  are  constant  parameters  that  are  adapted  and  optimized  during  the </p>
<p>development of the ECU or an ECU variant. This is an iterative process, in which the optimal </p>
<p>value of a parameter is found by repeated measurements and changes. </p>
<p>The calibration concept answers the question of how parameters in the ECU can be changed </p>
<p>during an ECU’s development and calibration phases. There is not one calibration concept </p>
<p>that exists, rather several. Which concept is utilized usually depends very much on the capa&shy;</p>
<p>bilities and resources of the microcontroller that is used. </p>
<p>Normally, parameters are stored in the production ECU’s flash memory. The underlying pro&shy;</p>
<p>gram variables are defined as constants in the software. To make parameters modifiable at </p>
<p>runtime during an ECU’s development, additional RAM memory is needed.</p>
<p>A calibration concept is concerned with such questions as these: How do the parameters ini&shy;</p>
<p>tially find their way from flash to RAM? How is the microcontroller’s access to RAM rerouted? </p>
<p>What does the solution look like when there are more parameters than can be simultane&shy;</p>
<p>ously stored in RAM? How are the parameters copied back into flash? Are changes to the </p>
<p>parameters persistent, i.e. are they preserved when the ECU is turned off?</p>
<p>A distinction is made between transparent and non&shy;transparent calibration concepts. Trans&shy;</p>
<p>parent  means  that  the  calibration  tool  does  not  need  to  be  concerned  with  the  above </p>
<p> </p>
<p>questions, because all necessary mechanisms are implemented in the ECU. </p>
<p>Several methods are briefly introduced in the following.</p>
<p><b>3.1 Parameters in Flash</b></p>
<p>The software developer defines in the source code whether a parameter is a variable or a </p>
<p>constant, i.e. whether a parameter is stored in flash or in RAM memory.</p>
<p>C code example: </p>
<p>const float factor = 0.5; </p>
<p>The “factor” parameter represents a constant with the value 0.5. During compiling and link&shy;</p>
<p>ing of the code, memory space is provided in flash for the “factor” object. The object is allo&shy;</p>
<p>cated an address that lies in the data area of the flash memory. The value 0.5 is found at </p>
<p>the relevant address in the hex file and the address appears in the linker&shy;map file.</p>
<p>The simplest conceivable calibration concept involves modifying the value in C code, gener&shy;</p>
<p>ating  a  new  hex  file  and  flashing.  However,  this  method  is  very  laborious,  because  every </p>
<p>value change must be made in code, resulting in the need for a compiler/linker run with sub&shy;</p>
<p>sequent flashing. An alternative approach would be to only modify the value in the hex file </p>
<p>and then reflash this file. Every calibration tool is capable of doing this. It is referred to as </p>
<p>“offline calibration” of the hex file, which is a very commonly used method.</p>
<h1 style="page-break-before:always; "></h1>
<p>81</p>
<p>3.1 Parameters in Flash</p>
<p>Under some circumstances, with certain compilers it may be necessary to explicitly ensure </p>
<p>that parameters are always also stored in flash memory and not integrated in the code, for </p>
<p>example and therefore do not appear at all in the linker&shy;map file. Usually, one does not want </p>
<p>to leave to chance where a constant is created in flash memory. The necessary means for </p>
<p>accomplishing this are almost always compiler&shy;specific pragma instructions. To prevent the </p>
<p>compiler  from  embedding  them  in  the  code,  it  is  generally  sufficient  to  use  the  “volatile” </p>
<p>attribute for constant parameters. A typical definition of a flash constant appears as in the </p>
<p>following example:</p>
<p> </p>
<p>C code example: </p>
<p>#pragma section “FLASH_Parameter”</p>
<p>volatile const float factor = 0.5;</p>
<p>It is normally not possible to calibrate parameters in flash online. Indeed, most microcon&shy;</p>
<p>trollers are able to program their flash themselves, which is necessary for the purposes of </p>
<p>re&shy;programming in the field. Nonetheless, flash memory always has the property of being </p>
<p>organized into larger blocks (sectors), which can only be erased as a whole. It is practically </p>
<p>impossible to flash just individual parameters, because the ECU normally does not have the </p>
<p>resources to buffer the rest of the sector and reprogram it. In addition, this process would </p>
<p>take too much time.</p>
<p>Some ECUs have the ability to store data in what is known as an EEPROM memory. In con&shy;</p>
<p>trast to flash memories, EEPROM memories can erase and program each memory cell indi&shy;</p>
<p>vidually.  The  amount  of  available  EEPROM  memory  is  always  considerably  less  than  the </p>
<p>available flash memory and it is usually limited to just a few kilobytes. EEPROM memory is </p>
<p>often used to store programmable parameters in the service shop or to implement a persis&shy;</p>
<p>tence mechanism in the ECU, e.g. for the odometer. Online calibration would be conceivable </p>
<p>here, but it is seldom used, because access to EEPROM cells is relatively slow and during the </p>
<p>booting process EEPROM parameters are usually copied over to RAM memory, where it is </p>
<p>possible to access them directly. ECUs which have no EEPROM memory often implement </p>
<p>what is known as an EEPROM emulation. In this method, multiple small flash sectors are </p>
<p>used in alternation to record parameter changes, so that the last valid value can always be </p>
<p>determined. Online calibration would also be conceivable with this method.</p>
<p>In  both  cases,  the  relevant  memory  accesses  would  then  be  intercepted  in  the  software </p>
<p>components of the XCP driver and implemented with the software routines of the EEPROM </p>
<p>or the EEPROM emulation. The Vector XCP Professional driver offers the software hooks </p>
<p>needed for this.</p>
<h1 style="page-break-before:always; "></h1>
<p>82</p>
<p>3 Calibration Concepts</p>
<p><b>3.2 Parameters in RAM</b></p>
<p>The  most frequently  used  approach to  modifying  parameters  at  runtime  (“online  calibra&shy;</p>
<p>tion”) is to create the parameters in the available RAM memory. </p>
<p>C code example: </p>
<p>#pragma section “RAM_Parameter”</p>
<p>volatile float factor = 0.5; </p>
<p>This defines the parameter “factor” as a RAM variable with the initial value 0.5. During com&shy;</p>
<p>piling and linking of the code, memory space is reserved for the object “factor” in RAM and </p>
<p>the associated RAM address appears in the linker&shy;map file. The initial value 0.5 is stored in </p>
<p>flash memory and at the relevant location in the hex file. The addresses of the initial values </p>
<p>in flash memory are defined by parameterization of the linker, but they do not appear in the </p>
<p>linker&shy;map file. </p>
<p>During  booting  of  the  ECU,  all  RAM  variables  are  initialized  once  with  their  initial  values </p>
<p>from flash memory. This is usually executed in the start&shy;up code of the compiler producer </p>
<p>and the application programmer does not need to be concerned with it. The application uses </p>
<p>the values of parameters located in RAM and they can be modified via normal XCP memory </p>
<p>accesses. </p>
<p>From the perspective of the ECU software, calibration parameters in RAM are always still </p>
<p>unchangeable, i.e. the application itself does not change them. Many compilers discover this </p>
<p>fact  by  code  analysis  and  simply  optimize  the  necessary  RAM  memory  space  away.  Nor&shy;</p>
<p>mally, it is therefore also necessary to prevent the  compiler from optimizing by using the </p>
<p>“volatile” attribute.</p>
<p>From  the  perspective  of  the  calibration  tool,  the  RAM  area  in  which  the  parameters  are </p>
<p>located is referred to as calibration RAM (memory that can be calibrated). </p>
<p>FLASH</p>
<p>RAM</p>
<p>Parameters</p>
<p>Calibration RAM</p>
<p><b>Figure 53: </b></p>
<p><b>Initial parameter setting in RAM</b></p>
<p>The calibration RAM does not need to consist of a fully contiguous RAM area. It may also be </p>
<p>distributed into multiple areas or even in any desired way. Nonetheless, it offers significant </p>
<p>advantages for organizing the parameters in just a few contiguous RAM areas and isolating </p>
<p>them  from  other  RAM  parameters  such  as  changing  state  variables  and  intermediate </p>
<p>results. This is especially important if offline calibration of the calibration RAM with a hex </p>
<p>file should be enabled. At the user’s request, the calibration tool must be able to load the </p>
<h1 style="page-break-before:always; "></h1>
<p>83</p>
<p>3.2 Parameters in RAM</p>
<p>parameters that were modified offline into the ECU during the transition from offline cali&shy;</p>
<p>bration to online calibration. </p>
<p>This case occurs very frequently. For example, when calibrators reconnect with their ECU on </p>
<p>the next work day, they want to resume work at the point at which they stopped the evening </p>
<p>before. However, booting of the ECU causes the flashed contents to be copied to the RAM </p>
<p>as an initial dataset. To let users resume with work accomplished on the previous day, the </p>
<p>parameter set file saved the previous evening in the ECU’s RAM must be loaded. This load&shy;</p>
<p>ing process may be time optimized by limiting the number of necessary transmissions to a </p>
<p>minimum. It is advantageous here if the tool can quickly and reliably determine – by forming </p>
<p>a checksum over larger contiguous areas – whether there are differences. If there are no dif&shy;</p>
<p>ferences between the calibration RAM contents in the ECU and the file modified using the </p>
<p>tool,  this  area  does  not  need  to  be  transferred.  If  the  memory  area  with  the  calibration </p>
<p>parameters is not clearly defined, or if it includes parameters that are modified by the ECU </p>
<p>software, a checksum calculation always shows a difference and the parameter values are </p>
<p>transmitted, either from the ECU to the XCP Master or in a reverse direction. Depending on </p>
<p>the transmission speed and amount of data, this transmission could take several minutes. </p>
<p>Another advantage of clearly defined memory segments is that the memory area for initial </p>
<p>values in flash memory can be used for offline calibration. The contents of the flash memory </p>
<p>are defined using flashable hex files. If the calibration tool knows the location of parameters </p>
<p>in the  hex file,  it  can  modify their values  and  implement  new  initial values  in the  ECU  by </p>
<p>flashing the modified hex file. </p>
<p>The calibration tool not only needs to know the location of parameters in RAM, but also the </p>
<p>initial values in flash. A prerequisite is that the RAM memory segment must be initialized by </p>
<p>copying  from  an  identically  laid  out  memory  segment  in  flash,  as  is  the  usual  practice  in </p>
<p>most compilers/linkers. If the addresses of parameters in RAM are in the A2L file, it is only </p>
<p>necessary to let the tool know the offset to the start address of the calibration RAM, which </p>
<p>it must add to get to the start address of the relevant flash area. This offset then applies to </p>
<p>each individual parameter in the A2L. </p>
<p>The calibration tool can then either generate flashable hex files for this area itself, or it can </p>
<p>place them directly on the original hex files of the linker to modify the initial values of para&shy;</p>
<p>meters in the hex file.</p>
<h1 style="page-break-before:always; "></h1>
<p>84</p>
<p>3 Calibration Concepts</p>
<p><b>3.3 Flash Overlay</b></p>
<p>Many microcontrollers offer options for overlaying memory areas in flash with internal or </p>
<p>external RAM. This process is referred to as flash emulation or flash overlay. A lot is possible, </p>
<p>from the use of a Memory Management Unit all the way to dedicated mechanisms that pre&shy;</p>
<p>cisely serve this purpose. In this case the parameters are created as parameters in flash just </p>
<p>as  in  calibration  concept  1.  This  method  offers  enormous  advantages  compared  to  the </p>
<p>described calibration concept 2 “Parameters in RAM”:</p>
<p>&gt;   </p>
<p>No distinction is made between flash and RAM addresses. The flash addresses are always </p>
<p>located in the A2L file, the hex file and linker&shy;map file. This produces clear relationships, </p>
<p>the hex file is directly flashable and the A2L file matches it exactly.</p>
<p>&gt;   </p>
<p>The  overlay  can  be  activated  or  deactivated  as  a  whole,  which  enables  lightning&shy;quick </p>
<p>swapping between values in flash and those in RAM. They are referred to as the RAM page </p>
<p>and the flash page of a memory segment. XCP supports control of memory page switch&shy;</p>
<p>ing with special commands. </p>
<p>&gt;   </p>
<p>The memory pages might be switched separately, e.g. for XCP access and ECU access, i.e. </p>
<p>XCP could access a memory page while the ECU software works with the other page. This </p>
<p>permits such operations as downloading of the offline calibration data to RAM, while the </p>
<p>ECU is still working with the flash data; this avoids potential inconsistencies that could be </p>
<p>problematic on a running ECU.</p>
<p>&gt;   </p>
<p>The overlay with RAM does not need to be complete and it can be adapted to the applica&shy;</p>
<p>tion case. It is possible to work with less RAM than with flash. More on this later.</p>
<p>A  typical  procedure  for  connecting  the  calibration  tool  to  the  ECU  with  the  subsequent </p>
<p>download of values that were calibrated offline appears as follows:</p>
<p>Connects to the ECU </p>
<p>CONNECT</p>
<p>Connects XCP Master to RAM page </p>
<p>SET_CAL_PAGE XCP to RAM</p>
<p>Checksum calculation </p>
<p>CALC_CHECKSUM</p>
<p>When a difference has been detected in the checksum calculation over the RAM area, first </p>
<p>the user is normally asked how to proceed. Should the contents of ECU RAM be sent to the </p>
<p>Master, or should the contents of a file on the Master page be sent to the ECU’s RAM? If the </p>
<p>user decides to write the offline changes to the ECU, the subsequent process appears as </p>
<p>follows:</p>
<p>ECU should use the dataset of the flash page  SET_CAL_PAGE ECU to FLASH</p>
<p>Copy file from Master to the RAM page  </p>
<p>DOWNLOAD …</p>
<p>ECU should use the dataset of the RAM page  SET_CAL_PAGE ECU to RAM</p>
<p>Afterwards, the memory page is always switched over to RAM, so that parameters can be  </p>
<p>modified. But the user can also explicitly indicate which memory page should be active in the </p>
<p>ECU. For example, the behavior of the RAM parameter set can be compared to that of the </p>
<p>flash parameter set, or in an emergency it can be switched back to a proven parameter set </p>
<p>in flash at lightning speed.</p>
<h1 style="page-break-before:always; "></h1>
<p>85</p>
<p>3.4 Dynamic Flash Overlay Allocation</p>
<p><b>3.4 Dynamic Flash Overlay Allocation</b></p>
<p>The  concepts for  calibration  RAM  described  so far  are  unproblematic  if  sufficient  RAM  is </p>
<p>available for all parameters. But what if the total number of parameters does not fit into </p>
<p>the available RAM area? </p>
<p>Here, it is advisable to overlay flash with RAM dynamically and do not overlay the affected </p>
<p>flash memory with RAM until the actual write access to a parameter. This procedure can </p>
<p>occur with a certain granularity and – depending on the implementation – it may be trans&shy;</p>
<p>parent to the calibration tool from the XCP perspective. If the XCP driver detects a write </p>
<p>access to flash in the ECU which would lead to a change, a part of calibration RAM is used </p>
<p>to copy over the relevant part of flash and activate the overlay mechanism for this part. This </p>
<p>involves allocating the RAM, i.e. in a fixed layout and it is identified as utilized. However, the </p>
<p>resources of the calibration RAM are limited. During the calibration process, RAM area that </p>
<p>has already been allocated is no longer released, so the available calibration RAM dwindles </p>
<p>with further requests. If the RAM resources are used up and a new allocation is required, the </p>
<p>user is informed of the exhausted RAM resources. The user is offered the option of flashing </p>
<p>or saving the changes made up to that point. This frees up the allocated RAM area again </p>
<p>and the user can once again calibrate. The variant in which the ECU autonomously flashes </p>
<p>the previously changed parameters is usually ruled out here for the reasons already cited in </p>
<p>calibration concept “Parameter in Flash”.</p>
<p>In some cases, the download of a parameter set created offline might not be executable due </p>
<p>to insufficient RAM resources. The only alternative is to flash it. The user can always cancel </p>
<p>the changes from the tool and this releases the allocated RAM blocks again.</p>
<p>In this concept, page switching between the RAM and flash pages is also possible without </p>
<p>any limitations. The parameters should be organized together in flash according to function, </p>
<p>so that the available RAM blocks can be used as efficiently as possible. The software devel&shy;</p>
<p>oper then specifies that the parameters, which belong together thematically, also lie in a </p>
<p>contiguous memory area. After copying to RAM, the parameters needed for tuning the par&shy;</p>
<p>ticular function are fully ready for use. </p>
<h1 style="page-break-before:always; "></h1>
<p>86</p>
<p>3 Calibration Concepts</p>
<p><b>3.5 RAM Pointer Based Calibration Concept per AUTOSAR</b></p>
<p>This concept does not require necessarily the use of an AUTOSAR operating system; it can </p>
<p>even be used in a different environment – e.g. without an operating system. The concept </p>
<p>exhibits a key similarity to the previous concept. The primary difference is that the substitu&shy;</p>
<p>tion of flash for RAM is not implemented by hardware mechanisms, but by software mech&shy;</p>
<p>anisms instead. The calibration parameters are always referenced by pointers from the ECU </p>
<p>software. Flash or RAM contents are accessed by changing this pointer. The flash parame&shy;</p>
<p>ters to be modified are copied to a defined block with available RAM. This method can be </p>
<p>implemented fully transparently from the XCP perspective, just as in the previous method. </p>
<p>As an alternative, the user of the calibration tool can explicitly select the parameters to be </p>
<p>modified by preselecting the desired parameters. The advantage of this is that resource uti&shy;</p>
<p>lization and loading is visible to the user and the user is not surprised by a lack of memory in </p>
<p>the midst of working.</p>
<p><b>3.5.1 Single Pointer Concept</b></p>
<p>The pointer table is located in RAM. When booting the ECU, all pointers indicate the para&shy;</p>
<p>meter values in flash. The location and parameters of the calibration RAM are indeed known, </p>
<p>but  it  does  not  yet  contain  any  parameter  values  after  booting.  Initially,  the  application </p>
<p>works entirely from flash.</p>
<p>FLASH</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Parameters</p>
<p><b>Figure 54: </b></p>
<p><b>Initial situation after booting</b></p>
<p>When the user selects a parameter from the A2L file for the first time after booting and </p>
<p>wishes to write access it, this triggers a copying operation within the ECU first. The XCP </p>
<p>Slave  determines  that  the  address  to  which  the  access  should  be  made  is  located  in  the </p>
<p>flash area, and it copies the parameter value to the calibration RAM. A change is also made </p>
<p>in the pointer table to ensure that the application no longer gets the parameter value from </p>
<p>flash, but instead from the RAM area: </p>
<h1 style="page-break-before:always; "></h1>
<p>87</p>
<p>3.5 RAM Pointer Based Calibration Concept per AUTOSAR</p>
<p>FLASH</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Parameters</p>
<p><b>Figure 55: </b></p>
<p><b>Pointer change and copying to RAM</b></p>
<p>The application continues to get the parameter value via the pointer table. But since the </p>
<p>pointer indicates the RAM address, the value is retrieved from there. As a result, the user can </p>
<p>change the parameter value via XCP and observe the effects of the change in the measure&shy;</p>
<p>ment. The disadvantage of this method is that an entry in a pointer table must be available </p>
<p>for each parameter and in turn the method is associated with substantial additional RAM </p>
<p>memory requirements for the pointer table. </p>
<p>The next figure illustrates the problem. Three parameters of a PID controller (P, I and D) are </p>
<p>contained in an ECU’s flash area. The RAM addresses and parameter values in RAM are also </p>
<p>already changed in the pointer table.</p>
<p><b>Figure 56: Pointer table for individual parameters</b></p>
<p><b>Flash</b></p>
<p>0x11</p>
<p>0x22</p>
<p>0x33</p>
<p>0x0000100A </p>
<p>0x000012BC </p>
<p>0x00007234 </p>
<p><b>Parameter</b></p>
<p><b>P</b></p>
<p><b>I</b></p>
<p><b>D</b></p>
<p><b>Pointertable</b></p>
<p>0x000A100A</p>
<p>0x000A100B</p>
<p>0x000A100C</p>
<p><b>RAM</b></p>
<p>0x44</p>
<p>0x55</p>
<p>0x66</p>
<p>0x000A100A</p>
<p>0x000A100B</p>
<p>0x000A100C</p>
<p>Address</p>
<p>Address</p>
<p>Address</p>
<p>Content</p>
<p>Content</p>
<p>Calibration  concepts  are  very  important,  because  RAM  resources  are  scarce.  Large  RAM </p>
<p>pointer tables would make a concept self&shy;defeating. </p>
<p>To avoid having to create a pointer for each individual parameter and having the method be </p>
<p>used as such, the parameters can be combined into structures. This requires just one pointer </p>
<p>per structure. When the user selects a parameter, not only is this parameter copied to RAM, </p>
<p>but so is the entire associated structure. The granularity of the structures is of key impor&shy;</p>
<p>tance here. With large structures only a few pointers are necessary. In turn, this means that </p>
<p>with the decision for a specific parameter, a rather large associated structure is copied to </p>
<p>the RAM area and this can cause the limits of calibration RAM space to be reached quickly.</p>
<h1 style="page-break-before:always; "></h1>
<p>88</p>
<p>3 Calibration Concepts</p>
<p>Example: </p>
<p>The calibration RAM should be 400 bytes in size. Four structures are defined in the software </p>
<p>with the following parameters:</p>
<p>Structure A: 250 bytes</p>
<p>Structure B: 180 bytes</p>
<p>Structure C: 120 bytes</p>
<p>Structure D: 100 bytes</p>
<p>When the user selects a parameter from structure A, the 250 bytes are copied from flash to </p>
<p>the calibration RAM, and the user has XCP access to all parameters located in structure A. </p>
<p>If the calibration task is limited to the parameters of this structure, the calibration RAM is </p>
<p>fully sufficient. However, if the user selects another parameter located in a different struc&shy;</p>
<p>ture, e.g. structure C, these 120 bytes must also be copied to the calibration RAM. Since the </p>
<p>calibration RAM can handle 400 bytes, the user can access all parameters of structures A </p>
<p>and C simultaneously.</p>
<p>If another selected parameter is not located in structure C, but rather in structure B, the 180 </p>
<p>bytes of structure B would have to be copied to RAM in addition to the 250 bytes of struc&shy;</p>
<p>ture A. However, since the space in RAM is inadequate for this, the user indeed has access to </p>
<p>the parameters of structure A, but not to the data of structure B, because the ECU cannot </p>
<p>execute the copy command.</p>
<p>You  can  learn  more  about  how  this  approach  works  in  CANape.  Start  CANape  with  the </p>
<p> </p>
<p>“AUTOSAR  Single  Pointered  Demo”  project.  You  will  find  more  information  on  its  use  in </p>
<p> </p>
<p>CANape on the “Introduction” page of the project.</p>
<p>You will find a source code example under the “Demos” category at the Vector Download </p>
<p>Center. A code example on how to use the calibration concept is contained in the “XCP  Sample</p>
<p> </p>
<p>Implementation” under &lt;Installation DIR&gt;\Samples\CAN\CAN MPC55xx\XCPDemo.</p>
<p><b>3.5.2 Double Pointer Concept</b></p>
<p>A disadvantage of the single pointer concept is that memory page switching is not easy to </p>
<p>implement. The calibration tool could simply describe the pointer table completely for page </p>
<p>swapping, but this is not feasible in a short period of time without resulting in temporary </p>
<p>inconsistencies and side effects. A tool&shy;transparent implementation would double the mem&shy;</p>
<p>ory space requirement for the pointer table, because when switching the memory page into </p>
<p>flash, a copy of the previous pointer table would have to be created with RAM pointers.</p>
<p>For applications with large pointer tables, a transparent implementation or a fully consis&shy;</p>
<p>tent switching, there is the option of extending the method to a double pointer concept. To </p>
<p>explain how this is done, we return once again to the initial RAM setting. </p>
<h1 style="page-break-before:always; "></h1>
<p>89</p>
<p>3.5 RAM Pointer Based Calibration Concept per AUTOSAR</p>
<p>Figure 57 represents the pointer table. It lies in RAM. As already mentioned, this table must </p>
<p>be copied from flash into RAM. As a result, this table lies in flash memory. If another pointer </p>
<p>is now used (a table pointer), which points to either the pointer table in RAM or in flash, one </p>
<p>arrives at a double pointer solution. </p>
<p>FLASH</p>
<p>RAM</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Tablepointer</p>
<p>FLASH</p>
<p>Pointertable</p>
<p><b>Figure 57: </b></p>
<p><b>Double pointer concept</b></p>
<p>The parameter values are initially accessed via the table pointer. If the table pointer indi&shy;</p>
<p>cates the pointer table in RAM, the application essentially accesses the actual parameters </p>
<p>via the contents of the RAM pointer table. The low access speed and the creation of more </p>
<p>program code are disadvantages of this solution.</p>
<p><b>3.6 Flash Pointer Based Calibration Concept </b></p>
<p>This method was patented several years ago by the company ZF Friedrichshafen under the </p>
<p>name “InCircuit2” and bears a strong resemblance to the pointer&shy;based concept of AUTOSAR.</p>
<p> </p>
<p>Here too, the application in the ECU accesses parameter data using a pointer table. How&shy;</p>
<p>ever, this pointer table is not located in RAM, but in flash instead. Changes to the pointer </p>
<p>table can therefore only be made by flash programming. A tool&shy;transparent implementation </p>
<p>is not possible. The advantage lies in the RAM memory that is saved since it no longer con&shy;</p>
<p>tains the pointer table.</p>
<p>You can find out how this approach works in CANape. Start CANape with the “InCircuit2” </p>
<p>project. You will find more information on its use in CANape on the “Introduction” page of </p>
<p>the project.</p>
<h1 style="page-break-before:always; "></h1>
<p>91</p>
<p>4 Application Areas of XCP</p>
<p><b>4 Application Areas of XCP</b></p>
<h1 style="page-break-before:always; "></h1>
<p>92</p>
<p>4 Application Areas of XCP</p>
<p>When ECU calibrators think about the use of XCP, they are usually fixated on use of the pro&shy;</p>
<p>tocol in the ECU.</p>
<p><b>Figure 58: </b></p>
<p><b>Application areas and </b></p>
<p><b>application cases</b></p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>PC</p>
<p>Measurement/</p>
<p>Calibration </p>
<p>Hardware*</p>
<p>* Debug Interfaces, Memory Emulator ...</p>
<p>HIL/SIL Systems</p>
<p>EXE/DLL</p>
<p>Prototype or</p>
<p>ECU Hardware</p>
<p>Simulink</p>
<p>Master</p>
<p><b>XCP</b></p>
<p>In a survey of development processes, one encounters many different solution approaches </p>
<p>for the development of electronics and software. HIL (Hardware in the Loop), SIL (Software </p>
<p>in the Loop) and Rapid Prototyping are keywords here and they describe different scenarios. </p>
<p>They always have a “plant” and a “controller” in common. </p>
<p><b>Figure 59: Plants and controllers</b></p>
<p>Offset</p>
<p>Manipulated </p>
<p>Variable</p>
<p>Disturbance </p>
<p>Variable</p>
<p>Controlled Variable</p>
<p>(Actual Value)</p>
<p>Reference Variable</p>
<p>(Set Value)</p>
<p><b>Controller</b></p>
<p><b>Plant</b></p>
<p>In the context of automotive development, the controller is represented by the ECU and the </p>
<p>plant is the physical system to be controlled such as the transmission, engine, side mirrors, </p>
<p>etc.</p>
<p>The  rough  subdivision  is  made  between  different  development  approaches  according  to </p>
<p>whether the controller or the plant runs in real or simulated mode. Some combinations will </p>
<p>be described in greater detail. </p>
<h1 style="page-break-before:always; "></h1>
<p>93</p>
<p>4.1 MIL: Model in the Loop </p>
<p><b>4.1 Model in the Loop (MIL) </b></p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p>Simulink</p>
<p><b>Figure 60: </b></p>
<p><b>Model in the Loop </b></p>
<p><b>in Simulink</b></p>
<p>In  this  development  environment,  both  the  controller  and  the  plant  are  simulated  as  a </p>
<p>model. In the example shown, both models run in Simulink as the runtime environment. The </p>
<p>capabilities  of  the  Simulink  runtime  environment  are  available  to  you  for  analyzing  the </p>
<p>behavior. </p>
<p>To realize the convenience of a measurement and calibration tool like CANape in an early </p>
<p>development phase, an XCP Slave can be integrated in the controller model. In an authoring </p>
<p>step, the Slave generates the A2L that matches the model and the user already has the full </p>
<p>range of convenient operating features with visualization of process flows in graphic win&shy;</p>
<p>dows, access to characteristic curves and maps and much more.</p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p>Simulink</p>
<p><b>Simulink</b></p>
<p><b>XCP Server</b></p>
<p><b>CANape</b></p>
<p>A2L</p>
<p><b>Figure 61: </b></p>
<p><b>CANape as measurement </b></p>
<p><b>and calibration tool </b></p>
<p><b>with Simulink models</b></p>
<p>Neither a code generation step nor instrumentation of the model is necessary for this. Time&shy;</p>
<p>stamps are also included with transmissions over XCP. CANape completely adapts to the </p>
<p>time  behavior  of  the  Simulink  runtime  environment  here.  Whether  the  model  is  running </p>
<p>faster or slower than in real time is of no consequence. For example, if the functional devel&shy;</p>
<p>oper uses the Simulink Debugger in the model to step through the model, CANape still takes </p>
<p>the time transmitted via XCP as the reference time.</p>
<h1 style="page-break-before:always; "></h1>
<p>94</p>
<p>4 Application Areas of XCP</p>
<p><b>4.2 Software in the Loop (SIL) </b></p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Windows DLL</b></p>
<p>Simulink</p>
<p>Code Generation</p>
<p><b>Figure 62: </b></p>
<p><b>Software in the Loop </b></p>
<p><b>with Simulink </b></p>
<p><b>environment</b></p>
<p>In this development step, code is generated from the model of the controller, which is then </p>
<p>used in a PC&shy;based runtime environment. Naturally, the controller may also have been devel&shy;</p>
<p>oped without any sort of model&shy;based approach. The plant continues to be simulated. XCP </p>
<p>can  be  used  to  measure  and  calibrate  the  controller.  If  the  controller  originates  from  a </p>
<p> </p>
<p>Simulink model, a code generation step (Simulink Coder with the target “CANape”) is used </p>
<p>to generate the C code for a DLL and the associated A2L. If the Controller development is </p>
<p>conducted based on manually written code, it is embedded in a C++ project that is delivered </p>
<p>with CANape.</p>
<p>After compiling and linking, the DLL is used in the CANape context. With the support of the </p>
<p>XCP connection, the algorithms in the DLL can be measured and calibrated exactly as if the </p>
<p>application were already integrated in an ECU.</p>
<p>A2L</p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Windows DLL</b></p>
<p>Simulink</p>
<p>Code generation</p>
<p><b>CANape</b></p>
<p><b>Figure 63: </b></p>
<p><b>CANape as SIL </b></p>
<p><b>development platform</b></p>
<h1 style="page-break-before:always; "></h1>
<p>95</p>
<p>4.3 HIL: Hardware in the Loop</p>
<p><b>4.3 Hardware in the Loop (HIL) </b></p>
<p>Many different kinds of HIL systems are available. They range from very simple, cost&shy;effec&shy;</p>
<p>tive systems all the way to very large and expensive expansion stages. The following figure </p>
<p>shows the rough concept:</p>
<p><b>Plant Model</b></p>
<p>HIL Platform</p>
<p>ECU</p>
<p>I/O</p>
<p><b>Controller Model</b></p>
<p><b>Figure 64: </b></p>
<p><b>HIL solution</b></p>
<p>The controller algorithm runs in a microcontroller platform (e.g. the ECU), while the plant </p>
<p>continues to be simulated. Depending on the parameters and the complexity of the plant </p>
<p>and the necessary I/O, requirements of the HIL platform and the associated costs can rise </p>
<p>steeply. Since the ECU runs in real time, the model of the plant must also be computed in </p>
<p>real time.</p>
<p>To now introduce XCP for optimization appears trivial, because another ECU is being added. </p>
<p>The whole system looks like this:</p>
<p>ECU</p>
<p>I/O</p>
<p><b>CANape</b></p>
<p><b>Plant Model</b></p>
<p>HIL Platform</p>
<p><b>Controller Model</b></p>
<p>A2L</p>
<p><b>Figure 65: </b></p>
<p><b>HIL with CANape </b></p>
<p><b>as measurement and </b></p>
<p><b> calibration tool</b></p>
<p>From CANape, the user has access to the algorithms in the ECU over XCP. </p>
<h1 style="page-break-before:always; "></h1>
<p>96</p>
<p>The Vector Tool CANoe is also used by many customers as a HIL system. With CANoe, a HIL </p>
<p>system might look like this:</p>
<p><b>CANoe RT User PC</b></p>
<p>Ethernet</p>
<p>CANoe RT Server</p>
<p>Digital I/O</p>
<p>Analog I/O</p>
<p>CAN</p>
<p>LIN</p>
<p>MOST</p>
<p>FlexRay</p>
<p>ECU</p>
<p><b>Plant Model</b></p>
<p><b>CANape</b></p>
<p>XCP</p>
<p>A2L</p>
<p><b>Figure 66: </b></p>
<p><b>CANoe as HIL system</b></p>
<p>The ability to access XCP data directly from CANoe for testing purposes results in the fol&shy;</p>
<p>lowing variant as well:</p>
<p><b>CANoe RT User PC</b></p>
<p>Ethernet</p>
<p>CANoe RT Server</p>
<p>Digital I/O</p>
<p>Analog I/O</p>
<p>CAN</p>
<p>LIN</p>
<p>MOST</p>
<p>FlexRay</p>
<p>ECU</p>
<p>XCP</p>
<p><b>Plant Model</b></p>
<p>A2L</p>
<p><b>Figure 67: </b></p>
<p><b>CANoe as HIL system </b></p>
<p><b>with XCP access </b></p>
<p><b>to the ECU</b></p>
<p>Here the  model  of the  plant  runs  on the  CANoe  real&shy;time  server. At the  same time, XCP </p>
<p>access to the ECU is also realized from CANoe. This gives a tool simultaneous access to the </p>
<p>plant and the controller. </p>
<p>4 Application Areas of XCP</p>
<h1 style="page-break-before:always; "></h1>
<p>97</p>
<p>4.3 HIL: Hardware in the Loop</p>
<p>To round out the picture, yet another HIL solution option should be mentioned. The plant </p>
<p>might also run as a DLL in CANape. This gives the user full access to the plant and to the </p>
<p>controller over XCP. </p>
<p><b>Figure 68: CANape as HIL solution</b></p>
<p>ECU</p>
<p>ECU</p>
<p>Plant</p>
<p>XCP</p>
<p><b>Plant Model</b></p>
<p><b>Windows DLL</b></p>
<p><b>CANape</b></p>
<p>XCP</p>
<p>A2L</p>
<p>A2L</p>
<p><b>4.4 Rapid Control Prototyping (RCP) </b></p>
<p>In this development phase, the control algorithm runs on real&shy;time hardware instead of an </p>
<p>ECU.  This  situation  often  occurs  when  the  necessary  ECU  hardware  is  not  yet  available. </p>
<p> Several platforms come in question as suitable hardware: from simple evaluation boards all </p>
<p>the  way  to  special  automotive&shy;level  hardware  solutions,  depending  on  which  additional </p>
<p>requirements need to be fulfilled. Here too, integration with XCP helps in setting up an OEM&shy;</p>
<p>independent tool chain.</p>
<p><b>Figure 69: Solution for Rapid Control Prototyping</b></p>
<p>XCP</p>
<p>I/O</p>
<p><b>EVA Board</b></p>
<p><b>CANape</b></p>
<p><b>Controller Model</b></p>
<p>Plant</p>
<p>A2L</p>
<p>The concepts “Rapid” and “Prototyping” describe the task very well. The aim is to develop a </p>
<p>functional prototype as quickly as possible, to use and test it in the runtime environment. </p>
<p>This just requires simple work steps throughout the entire process.</p>
<h1 style="page-break-before:always; "></h1>
<p>98</p>
<p>In the literature, the RCP approach is frequently subdivided into two areas: fullpassing and </p>
<p>bypassing.</p>
<p>As  depicted  in  Figure  69,  the  entire  controller  runs  on  separate  real&shy;time  hardware.  This </p>
<p>method is known as fullpassing, because the entire controller runs on the controller hard&shy;</p>
<p>ware. It must have the necessary I/O to be able to interface with the plant. Very often, it is </p>
<p>only possible to fulfill technical requirements for the I/O with suitable power electronics. </p>
<p>It is not only the I/O that represents a challenge; often functional elements of the ECU soft&shy;</p>
<p>ware (e.g. network management) are needed to enable functionality in a more complex net&shy;</p>
<p>work. However, if a complete ECU is used for Rapid Control Prototyping instead of a general </p>
<p>controller platform, the complexity of the flash process, the size of the overall software, etc. </p>
<p>all work against the requirement for “rapid” development. </p>
<p>In summary: the use of an entire ECU as the runtime environment for the controller offers </p>
<p>the advantage that the necessary hardware and software infrastructure for the plant exists. </p>
<p>The disadvantage lies in the high degree of complexity. The concept of bypassing was devel&shy;</p>
<p>oped to exploit the advantages of the ECU infrastructure without being burdened by the </p>
<p>disadvantages of high complexity.</p>
<p><b>4.5 Bypassing </b></p>
<p>When bypassing occurs, data is recorded from the ECU and processed outside the ECU, and </p>
<p>the result is written back to the ECU. As both measurement and writing to the ECU must </p>
<p>occur in sync with the ECU processes, DAQ and STIM mechanisms are used. At least two </p>
<p>DAQ lists are required, one with the DAQ direction (from Slave to Master) and one with the </p>
<p>STIM direction (from Master to Slave).</p>
<p>In Figure 70, the ECU is connected to the plant. The necessary I/O and software compo&shy;</p>
<p>nents  are  available  in  the  ECU.  In  the  bypassing  hardware,  an  algorithm  A1  runs,  which </p>
<p>occurs in Version A of the ECU. A1 is a new variant of the algorithm and should now be tried </p>
<p>out on the real plant.</p>
<p>4 Application Areas of XCP</p>
<h1 style="page-break-before:always; "></h1>
<p>99</p>
<p>4.5 Bypassing</p>
<p><b>Figure 70: Basic principle of bypassing</b></p>
<p>I/O</p>
<p>XCP</p>
<p>ECU</p>
<p>Bypassing Hardware</p>
<p>Bypassing</p>
<p>Hardware</p>
<p><b>CANape</b></p>
<p>ECU</p>
<p>Plant</p>
<p>XCP</p>
<p>A2L</p>
<p>A2L</p>
<p><b>Controller Model</b></p>
<p>The bypassing hardware (a VN8900 device in the figure) and the ECU are interconnected </p>
<p>over XCP. One goal here is to get the data needed for algorithm A1 from the ECU by DAQ; </p>
<p>another goal is to stimulate the results of A1 back into the ECU. The following figure illus&shy;</p>
<p>trates the schematic flow:</p>
<p><b>2.</b></p>
<p><b>3.</b></p>
<p>Bypassing Hardware</p>
<p>ECU</p>
<p><b>Algorithm A’</b></p>
<p><b>Algorithm A</b></p>
<p><b>1.</b></p>
<p><b>XCP</b></p>
<p><b>4.</b></p>
<p><b>Bypassing</b></p>
<p><b>Coordinator</b></p>
<p><b>Figure 71: </b></p>
<p><b>Bypassing flow</b></p>
<p>Depicted in the ECU is a blue function block in which the algorithm A runs. To ensure that A1 </p>
<p>can now be used, the data enters algorithm A as an input variable and it is measured from </p>
<p>the ECU by DAQ. </p>
<p>Step 1: In the ECU, the data is recorded and sent to the bypassing tool before the original </p>
<p>function  is  calculated  in  the  ECU.  Normally,  the  input  data  in  functions  A  and  A1  is  are </p>
<p>identical. </p>
<p>Step 2: The data transferred via DAQ is now transferred to algorithm A1.</p>
<p>Step 3: The results of the calculation of algorithm A1 are transferred to the bypassing tool. </p>
<p>Step 4: The data is transferred into the ECU via STIM. The ECU calculates algorithm A dur&shy;</p>
<p>ing this time. If the stimulated results are available and calculation of algorithm A is com&shy;</p>
<h1 style="page-break-before:always; "></h1>
<p>100</p>
<p>4 Application Areas of XCP</p>
<p>plete, the values calculated in the ECU are typically overwritten by the stimulated values of </p>
<p>algorithm A1.</p>
<p>This  makes  it  possible  to  use the value  computed  by  algorithm A1  and  not from A  in the </p>
<p>ECU’s overall control process. This method permits using a combination of the rapid substi&shy;</p>
<p>tution of algorithms on the bypassing hardware that incorporates the I/O and the ECU’s </p>
<p>basic software. </p>
<p>Of  course,  performance  limits  of  the  transport  protocol  also  affect  bypassing.  If  short </p>
<p>bypassing times are needed, access to the ECU by DAQ and STIM may also be performed via </p>
<p>the controller’s debugging or trace interfaces. The Vector VX1000 measurement and cali&shy;</p>
<p>bration hardware converts the data into an XCP&shy;on&shy;Ethernet data stream from the control&shy;</p>
<p>ler interface. In this process, up to one megabyte of data can be transported into the ECU.</p>
<p>Plant</p>
<p>XCP</p>
<p>ECU</p>
<p>Bypassing Hardware</p>
<p><b>CANape</b></p>
<p><b>Controller Model</b></p>
<p>I/O</p>
<p>XCP</p>
<p>Debugging and </p>
<p>Trace Interface</p>
<p>Measurement &amp; Calibration</p>
<p>Hardware VX1000</p>
<p>Bypassing</p>
<p>Hardware</p>
<p>A2L</p>
<p><b>Figure 72: Bypassing with real-time bypassing hardware and fast ECU access</b></p>
<p>In the figure, ECU access occurs via XCP on Ethernet, and calculation of the bypass algo&shy;</p>
<p>rithm occurs on separate bypassing hardware (VN8900 network interface) with a real&shy;time </p>
<p>operating  system.  This  means  that  the  variance  of  the  calculation  time  is  considerably </p>
<p>smaller than with calculation on a laptop, as the processing time is not affected by other </p>
<p>applications.</p>
<h1 style="page-break-before:always; "></h1>
<p>101</p>
<p>4.6 Shortening Iteration Cycles with Virtual ECUs</p>
<p><b>4.6 Shortening Iteration Cycles with Virtual ECUs </b></p>
<p>Stimulation with data is necessary to optimize the algorithm in the ECU with the help of </p>
<p>XCP. This can be done in the ECU in the framework of test drives. But there is yet another </p>
<p>solution that is available with XCP, in which the algorithm does not run on an ECU; rather it </p>
<p>runs on the PC in the form of executable code or as a model in Simulink in the form of a </p>
<p> “virtual ECU.” This virtual ECU does not need to run in real time, because in this case no con&shy;</p>
<p>nection to a real system exists. It can run significantly faster – depending on the PC’s com&shy;</p>
<p>puting power. </p>
<p>The  algorithm  is  stimulated  by  a  previously  logged  measurement  file,  which  contains  all </p>
<p> signals that are needed as input signals for the algorithm. The connection to CANape is set </p>
<p>up over XCP. The user can perform the parameterization and measurement configuration. </p>
<p>Afterwards, execution is started. Here the data from the test drive is fed into the algorithm </p>
<p>as stimulation and the desired measurement parameters from the application are simulta&shy;</p>
<p>neously measured out and saved to a measurement file. </p>
<p>New</p>
<p>MDF</p>
<p>Application</p>
<p>Para-</p>
<p>meter</p>
<p>MDF</p>
<p>test drive</p>
<p><b>CANape</b></p>
<p>1. Set parameters</p>
<p>2. Start</p>
<p>3. Send test drive data</p>
<p>4. Measurement data</p>
<p>5. Analyze</p>
<p><b>Simulink/</b></p>
<p><b>DLL</b></p>
<p>Slave</p>
<p><b>Figure 73: </b></p>
<p><b>Short calibration cycles </b></p>
<p><b>with virtual ECUs</b></p>
<h1 style="page-break-before:always; "></h1>
<p>102</p>
<p>4 Application Areas of XCP</p>
<p>After the calculation has been completed, a new measurement file is available to the user </p>
<p>for  analysis  of  ECU  behavior.  The  length  of  time  of  the  new  measurement  file  precisely </p>
<p>matches the length of the input measurement file. If the duration of a test drive is one hour, </p>
<p>the algorithm on the PC might calculate the entire test drive in just a few seconds. Then a </p>
<p>measurement result exists, which corresponds to a test of one hour duration. Based on the </p>
<p>data analysis, the user makes decisions about parameterization and the iteration cycle is </p>
<p>repeated. </p>
<p> </p>
<p>Parameterization</p>
<p>via XCP</p>
<p>Start</p>
<p>New software version</p>
<p><b>CANape</b></p>
<p><b>Application as EXE or DLL on PC</b></p>
<p>Set values in</p>
<p>workspace  </p>
<p>Start</p>
<p>Calculate model</p>
<p>End model calculation</p>
<p>Send measurement </p>
<p>values from the model</p>
<p>Receive new</p>
<p>measurement data</p>
<p>Analyze the</p>
<p>new data </p>
<p>Send measurement</p>
<p>data</p>
<p><b>Figure 74: </b></p>
<p><b>Process flow with </b></p>
<p><b> </b></p>
<p><b>virtual ECUs</b></p>
<p>To shorten the iteration cycles, the algorithm is always stimulated with the same data. That </p>
<p>makes the results with different parameters much more comparable, because the results </p>
<p>are only influenced by the parameters that differ.</p>
<p>This process can of course be automated. The integrated script language of CANape per&shy;</p>
<p>forms an analysis of the measurement results, from which parameter calibration settings </p>
<p>are derived and automatically executed. It is also possible to have the process controlled by </p>
<p>an external optimization tool such as MATLAB over the CANape automation interface.</p>
<h1 style="page-break-before:always; "></h1>
<p>105</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5 Example of an XCP Implementation</b></p>
<h1 style="page-break-before:always; "></h1>
<p>106</p>
<p>5 Example of an XCP Implementation</p>
<p>To make it possible for an ECU to communicate over XCP, it is necessary to integrate an XCP </p>
<p>driver in the ECU’s application. The example described below is of the XCP driver which you </p>
<p>can download free of charge at the Download Center of the Vector website (www.vector.</p>
<p>com/xcp&shy;driver). This packet also contains some sample implementations for various trans&shy;</p>
<p>port layers and target platforms. The driver consists of the protocol&shy;Layer with the basic </p>
<p>functionality needed for measurement and calibration. It does not include features such as </p>
<p>Cold Start Measurement, Stimulation or flashing. You can purchase a full implementation </p>
<p>as a product that is integrated in the Vector CANbedded or AUTOSAR environment.</p>
<p>The XCP protocol layer is placed over the XCP transport layer, which in turn is based on the </p>
<p>actual bus communication. The implementation of the XCP protocol layer only consists of a </p>
<p>single C file and a few H files (xcpBasix.c, xcpBasic.h, xcp_def.h and xcp_cfg.h). The examples </p>
<p>include implementations for various transport layers, e.g. Ethernet and RS232. In the case of </p>
<p>CAN, the transport layer is normally very simple and the various XCP message types are </p>
<p>mapped directly to CAN messages. There are then separate fixed identifiers for the Tx and </p>
<p>Rx directions.</p>
<p>The software interface between the transport and protocol layers is very simple. It contains </p>
<p>just a few functions:</p>
<p>&gt;   </p>
<p>When the Slave receives an XCP message over the bus, it first arrives in the communica&shy;</p>
<p>tion  driver,  which  routes  the  message  to  the  XCP  transport  layer.  The  transport  layer </p>
<p>informs the protocol layer about the message with the function call XcpCommand().</p>
<p>&gt;   </p>
<p>If the XCP protocol layer wishes to send a message (e.g. a response to an XCP command </p>
<p>from the Master or a DAQ message), the message is routed to the transport layer by a call </p>
<p>of the ApplXcpSend() function.</p>
<p>&gt;   </p>
<p>The transport layer informs the protocol layer that the message was successfully sent by </p>
<p>the function call XcpSendCallBack().</p>
<h1 style="page-break-before:always; "></h1>
<p>107</p>
<p>5 Example of an XCP Implementation</p>
<p><b>Application</b></p>
<p><b>XCP Protocol Layer</b></p>
<p><b>XCP Transport Layer</b></p>
<p><b>Physical Layer</b></p>
<p><b>Bus</b></p>
<p>XcpEvent</p>
<p>XcpInit</p>
<p>XcpBackground</p>
<p>ApplXcpGetPointer</p>
<p>XcpCommand</p>
<p>ApplXcpSend</p>
<p>XcpSendCallback</p>
<p>Application – XCP Transport</p>
<p>Layer Interface </p>
<p><b>Figure 75: </b></p>
<p><b>Incorporating </b></p>
<p><b>the XCP Slave </b></p>
<p><b>in the ECU code</b></p>
<p>The interface between the application and the protocol layer can only be implemented via </p>
<p>four functions:</p>
<p>&gt;   </p>
<p>The application activates the XCP driver with the help of XcpInit(). This call is made once </p>
<p>in the starting process.</p>
<p>&gt;   </p>
<p>With XcpEvent(), the application informs the XCP driver that a certain event has occurred </p>
<p>(e.g. “End of a computational cycle reached”).</p>
<p>&gt;   </p>
<p>The call XcpBackground() lets the XCP driver execute certain activities in background (e.g. </p>
<p>calculation of a checksum).</p>
<p>&gt;   </p>
<p>Since the addresses in A2L files are always defined as 40&shy;bit values (32&shy;bit address, 8&shy;bit </p>
<p>address  extension),  the  XCP  driver  uses  the  function  ApplXcpGetPointer()  to  obtain  a </p>
<p>pointer from a A2L&shy;conformant address.</p>
<p>These interfaces are sufficient to integrate basic functionalities for measurement and cali&shy;</p>
<p>bration. Other interfaces are only needed for extended functions such as page switching, </p>
<p>identification or seed &amp; key. They are described in detail in documentation for the driver.</p>
<h1 style="page-break-before:always; "></h1>
<p>108</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5.1 Description of Functions</b></p>
<p><b>void XcpInit (void)</b></p>
<p>Task: </p>
<p> </p>
<p>Initialize the XCP driver.</p>
<p>Description: </p>
<p> </p>
<p>The  application  activates the XCP  driver with XcpInit(). This  command  must  be  executed </p>
<p>exactly once before any sort of XCP driver function may be called.</p>
<p><b>void XcpEvent (BYTE event)</b></p>
<p>Task:</p>
<p>The application informs the XCP driver about which event occurred. A unique event number </p>
<p>is assigned to each event here. </p>
<p>Description:</p>
<p>In setting up the measurement configuration in the measurement and calibration tool, the </p>
<p>user selects which measured values should be synchronously acquired with which events. The </p>
<p>information on measured values and events originates from the A2L. The desired measure&shy;</p>
<p>ment configuration is communicated to the XCP driver in the form of DAQ lists. </p>
<p>Example of an event definition in an engine controller:</p>
<p>XcpEvent (1); </p>
<p>// Event 1 stands for the 10&shy;ms task</p>
<p>XcpEvent (2); </p>
<p>// Event 2 stands for the 100&shy;ms task</p>
<p>XcpEvent (5); </p>
<p>// Event 5 stands for the 1&shy;ms task</p>
<p>XcpEvent (8); </p>
<p>// Event 8 is used for ignition angle synchronous measurements</p>
<p><b>BYTE XcpBackground (void)</b></p>
<p>Task:</p>
<p>Execute background activities of the XCP driver. </p>
<p>Description:</p>
<p>This  function  should  be  called  periodically  in  a  background  or  idle  task.  It  is  used  by  the  </p>
<p>XCP driver, for example, to compute the checksum, because the computation of a longer </p>
<p>checksum  in  XcpCommand()  could  take  an  unacceptably  long  time.  With  each  call  of </p>
<p> </p>
<p>XcpBackground(), a partial checksum of 256 bytes is computed. The duration of a checksum </p>
<p>computation  therefore  depends  on  the  call  frequency  of  XcpBackground().  There  are  no </p>
<p>other requirements for the call frequency or periodicity. The return value 1 indicates that a </p>
<p>checksum computation is currently running. </p>
<h1 style="page-break-before:always; "></h1>
<p>109</p>
<p>5.1 Description of Functions</p>
<p><b>void XcpCommand (DWORD* pCommand)</b></p>
<p>Task:</p>
<p>Interpret an XCP command.</p>
<p>Description:</p>
<p>This function must be called each time the transport layer receives a XCP frame. The para&shy;</p>
<p>meter is a pointer to the frame. </p>
<p><b>void ApplXcpSend (BYTE len, BYTE *msg)</b></p>
<p>Task:</p>
<p>Transfer a frame to be sent to the transport layer.</p>
<p>Description:</p>
<p>With this call, the protocol layer sends a message to the transport layer for transmission to </p>
<p>the Master. The call XcpSendCallBack implements a handshake method between the proto&shy;</p>
<p>col and transport layers. </p>
<p><b>BYTE XcpSendCallBack (void)</b></p>
<p>Task:</p>
<p>The  protocol  layer  uses this  callback to  inform the transport  layer that the  last  message </p>
<p>that was transferred to ApplXcpSend() was successfully transmitted.</p>
<p>Description:</p>
<p>The protocol layer does not call an ApplXcpSend() command until XcpSendCallBack() indi&shy;</p>
<p>cates that the prior message was successfully transmitted. XcpSendCallBack() returns the </p>
<p>value  0  (FALSE)  if  the  XCP  driver  is  in  idle.  If  there  are  more  frames  to  be  sent,  ApplX&shy;</p>
<p>cpSend() is called directly from XcpSendCallBack(). </p>
<p><b>BYTE *ApplXcpGetPointer (BYTE addr_ext, DWORD addr)</b></p>
<p>Task:</p>
<p>Convert an A2L&shy;conformant address to a pointer.</p>
<p>Description:</p>
<p>The function maps the 40&shy;bit A2L&shy;conformant addressing (32&shy;bit address + 8&shy;bit address </p>
<p>extension) that is sent by the XCP Master to a valid pointer. The address extension can be </p>
<p>used, for example, to distinguish different address areas or memory types.</p>
<h1 style="page-break-before:always; "></h1>
<p>110</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5.2 Parameterization of the Driver</b></p>
<p>In  many  respects,  the  XCP  driver  is  scalable  and  parameterizable  to  properly  handle  the </p>
<p>wide variety of functional content, transport protocols and target platforms. All settings are </p>
<p>made in the parameter file xcp_cfg.h. In the simplest case, they appear as follows:</p>
<p>/* Define protocol parameters */</p>
<p>#define kXcpMaxCTO     8      /* Maximum CTO Message Length */</p>
<p>#define kXcpMaxDTO     8      /* Maximum DTO Message Length */</p>
<p>#define C_CPUTYPE_BIGENDIAN   /* byte order Motorola */</p>
<p>/* Enable memory checksum */</p>
<p>#define XCP_ENABLE_CHECKSUM</p>
<p>#define kXcpChecksumMethod XCP_CHECKSUM_TYPE_ADD14</p>
<p>/* Enable calibration */</p>
<p>#define XCP_ENABLE_CALIBRATION</p>
<p>#define XCP_ENABLE_SHORT_UPLOAD</p>
<p>/* Enable data acquisition */</p>
<p>#define XCP_ENABLE_DAQ                   </p>
<p>#define kXcpDaqMemSize (512) /* Memory space reserved for DAQ */</p>
<p>#define XCP_ENABLE_SEND_QUEUE</p>
<p>For a CAN transport layer, the appropriate CTO and DTO parameters of eight bytes are set. </p>
<p>The driver must know whether it is running on a platform with Motorola or Intel byte order, </p>
<p>in this case a Motorola&shy;CPU (Big Endian). The remaining parameters activate the function&shy;</p>
<p>alities: measurement, calibration and checksum computation. The algorithm for checksum </p>
<p>computation is configured (here summing of all bytes into a DWORD) and the parameter of </p>
<p>the available memory is indicated for the measurement (here 512 bytes). The memory is pri&shy;</p>
<p>marily needed to store the DAQ lists and to buffer the data during the measurement. The </p>
<p>parameter therefore determines the maximum possible number of measurement signals. In </p>
<p>the driver documentation you will find more detailed information on estimating the neces&shy;</p>
<p>sary parameters.</p>
<h1 style="page-break-before:always; "></h1>
<p>111</p>
<p>6 Protocol Development Overview</p>
<p><b>6 Protocol Development Overview</b></p>
<h1 style="page-break-before:always; "></h1>
<p>112</p>
<p>6 Protocol Development Overview</p>
<p>The  following  overview  shows  some  of  the  essential  developments  of  the  XCP  protocol, </p>
<p>which was standardized in 2003. </p>
<p><b>6.1. XCP Version 1.1 (2008)</b></p>
<p>&gt;</p>
<p>  Description of the same XCP interface using two different physical interfaces within the </p>
<p>same A2L (e.g. “XCP on Vehicle CAN” and “XCP on Calibration CAN”)</p>
<p>&gt;</p>
<p>  The new command WRITE_DAQ_MULTIPLE makes it possible to accelerate configuration </p>
<p>of the Slave. Two ODTs appearing in succession in a DAQ list can be communicated in a </p>
<p>single step. </p>
<p>&gt;</p>
<p>  High time synchronization via “TIMESTAMP_EVENT.” Timestamp information is communi&shy;</p>
<p>cated by the Slave. The trigger can be initiated via an external synchronization cable. </p>
<p>&gt;</p>
<p>  Compression of embedded A2L files</p>
<p>All expansions are optional. XCP 1.1 is thus compatible with XCP 1.0.</p>
<p><b>6.2. XCP Version 1.2 (2013)</b></p>
<p>&gt;</p>
<p>  Parameters in the A2L for the definition of the required ECU resources via XCP&shy;DAQ mea&shy;</p>
<p>surement configurations (e.g. RAM usage, CPU execution time and required transfer band&shy;</p>
<p>width  for  CAN  or  Ethernet).  The  XCP  Master  can  access  the  parameters,  calculate </p>
<p>resource usage for the measurement and warn the user if overshooting occurs. </p>
<p>&gt;</p>
<p>  Prioritization control by the Master for transfer of the measurement data via CAN. The </p>
<p>objective here is to not disturb the necessary communication flow of the vehicle CAN to </p>
<p>the greatest degree possible. </p>
<p>&gt;</p>
<p>  Calculation of the required bandwidth and limits for the transfer of data via TCP or UDP</p>
<p>&gt;</p>
<p>  Description of XCP on CAN FD</p>
<p>All expansions are optional. XCP 1.2 is thus compatible with XCP 1.1.</p>
<h1 style="page-break-before:always; "></h1>
<p>113</p>
<p>6.3. XCP Version 1.3 (2015)</p>
<p><b>6.3. XCP Version 1.3 (2015)</b></p>
<p>&gt;</p>
<p>  Improvement of the time correlation of XCP Slaves using multicast solutions found on the </p>
<p>same network </p>
<p>&gt;</p>
<p>  Time synchronization between XCP Slave timestamp and external clock, e.g. via IEEE 1588</p>
<p>&gt;</p>
<p>  Checking of the bypassing data flow and error handling</p>
<p>All expansions are optional. XCP 1.3 is thus compatible with XCP 1.2.</p>
<h1 style="page-break-before:always; "></h1>
<p>114</p>
<p>The Authors</p>
<p><b>Andreas Patzer</b></p>
<p>Mr. Patzer graduated in Electrical Engineering from the Technical University of </p>
<p>Karlsruhe. In his studies he specialized in measurement and control engineering </p>
<p>and information and industrial engineering. In 2003, he joined Vector Informatik </p>
<p>GmbH in Stuttgart. Andreas Patzer has supported XCP projects from the very </p>
<p>start, since XCP was standardized by ASAM e.V. in the same year he was hired.</p>
<p>He currently manages the Customer Relations and Services area as a team </p>
<p>leader for the Measurement &amp; Calibration product line.</p>
<p><b>The Authors</b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>115</p>
<p>The Authors</p>
<p><b>Rainer Zaiser</b></p>
<p>Mr. Zaiser has a degree in Electrical Engineering from the University of </p>
<p>Stuttgart. After graduating, he came directly to Vector Informatik GmbH in </p>
<p>autumn 1988, where he has helped to create many of the standards that have </p>
<p>become established in the automotive industry such as DBC, MDF, CCP, A2L </p>
<p>and to a large extent XCP. From the start, he headed up the Measurement &amp; </p>
<p>Calibration and Network Interfaces product lines.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>116</p>
<p><b>Table of Abbreviations and Acronyms </b></p>
<p>A2L  </p>
<p>File extension for an ASAM 2MC language file</p>
<p>AML  </p>
<p>ASAM 2 Meta Language</p>
<p>ASAM  </p>
<p>Association for Standardisation of Automation and Measuring Systems</p>
<p>BYP  </p>
<p>Bypassing</p>
<p>CAL  </p>
<p>Calibration</p>
<p>CAN  </p>
<p>Controller Area Network</p>
<p>CCP  </p>
<p>CAN Calibration Protocol</p>
<p>CMD  </p>
<p>Command</p>
<p>CS  </p>
<p>Checksum</p>
<p>CTO  </p>
<p>Command Transfer Object</p>
<p>CTR  </p>
<p>Counter</p>
<p>DAQ  </p>
<p>Data Acquisition, Data Acquisition Packet</p>
<p>DTO  </p>
<p>Data Transfer Object</p>
<p>ECU  </p>
<p>Electronic Control Unit</p>
<p>ERR  </p>
<p>Error Packet</p>
<p>EV  </p>
<p>Event Packet</p>
<p>FIBEX </p>
<p>Field Bus Exchange Format </p>
<p>LEN  </p>
<p>Length</p>
<p>MCD  </p>
<p>Measurement Calibration and Diagnostics</p>
<p>MTA  </p>
<p>Memory Transfer Address</p>
<p>ODT  </p>
<p>Object Descriptor Table</p>
<p>PAG  </p>
<p>Paging</p>
<p>PGM  </p>
<p>Programming</p>
<p>PHY </p>
<p> Physical Layer respectively description of the chip connecting a link layer </p>
<p>device to a physical medium, for example Ethernet PHY </p>
<p>PID  </p>
<p>Packet Identifier</p>
<p>PTP </p>
<p>Precision Time Protocol </p>
<p>RES  </p>
<p>Command Response Packet</p>
<p>SERV  </p>
<p>Service Request Packet</p>
<p>SPI  </p>
<p>Serial Peripheral Interface</p>
<p>STD  </p>
<p>Standard</p>
<p>STIM  </p>
<p>Data Stimulation Packet</p>
<p>TCP/IP  </p>
<p>Transfer Control Protocol / Internet Protocol</p>
<p>TS  </p>
<p>Timestamp</p>
<p>UDP/IP  </p>
<p>Unified Data Protocol / Internet Protocol</p>
<p>USB  </p>
<p>Universal Serial Bus</p>
<p>XCP  </p>
<p>Universal Measurement and Calibration Protocol</p>
<p>Download </p>
<p>Sending of data from Master to Slave </p>
<p>Upload </p>
<p>Sending of data from Slave to Master</p>
<p>Table of Abbreviations and Acronyms</p>
<h1 style="page-break-before:always; "></h1>
<p>117</p>
<p>Literature &amp; Web Addresses</p>
<p><b>Literature</b></p>
<p>XCP is specified by ASAM (Association for Standardisation of Automation and Measuring </p>
<p>Systems). </p>
<p>You will find details on the protocol and on ASAM at: <b>www.asam.net</b></p>
<p><b>Web Addresses</b></p>
<p>Standardization committees:</p>
<p>&gt;</p>
<p>  ASAM, XCP protocol&shy;specific documents, A2L specification, <b>www.asam.net</b></p>
<p>Supplier of development software:</p>
<p>&gt;</p>
<p>  MathWorks, information on MATLAB, Simulink and Simulink Coder, <b>www.mathworks.com </b></p>
<p>&gt;</p>
<p>  Vector Informatik GmbH, demo version of CANape, free of charge and openly available </p>
<p>XCP driver (basic version), comprehensive information on the topics of ECU calibration, </p>
<p>testing and simulation, <b>www.vector.com</b></p>
<h1 style="page-break-before:always; "></h1>
<p>118</p>
<p>Table of Figures</p>
<p><b>Table of Figures </b></p>
<p>Figure 1: Fundamental communication with a runtime environment ..........................................8</p>
<p>Figure 2: The Interface Model of ASAM...............................................................................................9</p>
<p>Figure 3: An XCP Master can simultaneously communicate with multiple Slaves ..................10</p>
<p>Figure 4: Subdivision of the XCP protocol into protocol layer and transport layer ................14</p>
<p>Figure 5: XCP Slaves can be used in many different runtime environments ............................15</p>
<p>Figure 6: XCP packet ..............................................................................................................................19</p>
<p>Figure 7: Overview of XCP Packet Identifier (PID) .........................................................................19</p>
<p>Figure 8: XCP communication model with CTO/DTO ....................................................................20</p>
<p>Figure 9: Message identification .........................................................................................................21</p>
<p>Figure 10: Timestamp ............................................................................................................................21</p>
<p>Figure 11: Data field in the XCP packet ............................................................................................22</p>
<p>Figure 12: The three modes of the XCP protocol: Standard, Block and Interleaved mode ...24</p>
<p>Figure 13: Overview of the CTO packet structure ..........................................................................25</p>
<p>Figure 14: Trace example from a calibration process .....................................................................30</p>
<p>Figure 15: Transfer of a parameter set file to an ECU’s RAM .....................................................31</p>
<p>Figure 16: Hex window ..........................................................................................................................32</p>
<p>Figure 17: Address information of the parameter “Triangle” from the A2L file ......................33</p>
<p>Figure 18: Polling communication in the CANape Trace window ................................................34</p>
<p>Figure 19: Events in the ECU ...............................................................................................................35</p>
<p>Figure 20: Event definition in an A2L .................................................................................................35</p>
<p>Figure 21: Allocation of “Triangle” to possible events in the A2L ................................................36</p>
<p>Figure 22: Selecting events (measurement mode) for each measurement parameter .........36</p>
<p>Figure 23: Excerpt from the CANape Trace window of a DAQ measurement .........................37</p>
<p>Figure 24: ODT: Allocation of RAM addresses to DAQ DTO .........................................................38</p>
<p>Figure 25: DAQ list with three ODTs ..................................................................................................39</p>
<p>Figure 26: Static DAQ lists ...................................................................................................................40</p>
<p>Figure 27: Dynamic DAQ lists ..............................................................................................................41</p>
<p>Figure 28: Event for DAQ and STIM ...................................................................................................42</p>
<p>Figure 29: Structure of the XCP packet for DTO transmissions..................................................43</p>
<p>Figure 30: Identification field with absolute ODT numbers ..........................................................44</p>
<p>Figure 31: ID field with relative ODT and absolute DAQ numbers (one byte) .........................44</p>
<p>Figure 32: ID field with relative ODT and absolute DAQ numbers (two bytes) ......................44</p>
<p>Figure 33:  ID field with relative ODT and absolute DAQ numbers as well as fill byte </p>
<p>(total of four bytes) ............................................................................................................45</p>
<p>Figure 34: XCP Slave with free&shy;running clock  .................................................................................46</p>
<p>Figure 35: The clock of the XCP Slave is synchronized with the grandmaster clock  .............47</p>
<p>Figure 36: Definition of which bus nodes send which messages .................................................49</p>
<p>Figure 37: Representation of a CAN network ..................................................................................50</p>
<p>Figure 38: Example of XCP&shy;on&shy;CAN communication .....................................................................51</p>
<p>Figure 39: Representation of an XCP&shy;on&shy;CAN message ...............................................................51</p>
<p>Figure 40: Illustration of a CAN FD frame ........................................................................................52</p>
<p>Figure 41: Nodes K and L are redundantly interconnected ...........................................................54</p>
<p>Figure 42: Communication by slot definition ...................................................................................54</p>
<p>Figure 43: Representation of a FlexRay communication matrix..................................................55</p>
<p>Figure 44: Representation of the FlexRay LPDUs ...........................................................................56</p>
<h1 style="page-break-before:always; "></h1>
<p>119</p>
<p>Table of Figures</p>
<p>Figure 45: Allocation of XCP communication to LPDUs ................................................................57</p>
<p>Figure 46: XCP packet with TCP/IP or UDP/IP ................................................................................58</p>
<p>Figure 47: XCP&shy;on&shy;SxI packet ..............................................................................................................59</p>
<p>Figure 48: Memory representation .....................................................................................................61</p>
<p>Figure 49: Representation of driver settings for the flash area ..................................................63</p>
<p>Figure 50: Representation of the block transfer mode ..................................................................66</p>
<p>Figure 51: Parameters in a calibration window ...............................................................................72</p>
<p>Figure 52: Signal response over time .................................................................................................72</p>
<p>Figure 53: Initial parameter setting in RAM .....................................................................................82</p>
<p>Figure 54: Initial situation after booting ...........................................................................................86</p>
<p>Figure 55: Pointer change and copying to RAM ..............................................................................87</p>
<p>Figure 56: Pointer table for individual parameters .........................................................................87</p>
<p>Figure 57: Double pointer concept ......................................................................................................89</p>
<p>Figure 58: Application areas and application cases .......................................................................92</p>
<p>Figure 59: Plants and controllers ........................................................................................................92</p>
<p>Figure 60: Model in the Loop in Simulink ..........................................................................................93</p>
<p>Figure 61: CANape as measurement and calibration tool with Simulink models ...................93</p>
<p>Figure 62: Software in the Loop with Simulink environment .......................................................94</p>
<p>Figure 63: CANape as SIL development platform ..........................................................................94</p>
<p>Figure 64: HIL solution ...........................................................................................................................95</p>
<p>Figure 65: HIL with CANape as measurement and calibration tool ...........................................95</p>
<p>Figure 66: CANoe as HIL system .........................................................................................................96</p>
<p>Figure 67: CANoe as HIL system with XCP access to the ECU ...................................................96</p>
<p>Figure 68: CANape as HIL solution .....................................................................................................97</p>
<p>Figure 69: RCP solution .........................................................................................................................97</p>
<p>Figure 70: Basic principle of bypassing ..............................................................................................99</p>
<p>Figure 71: Bypassing flow .....................................................................................................................99</p>
<p>Figure 72: Bypassing with real&shy;time bypassing hardware and fast ECU access ................. 100</p>
<p>Figure 73: Short calibration cycles with virtual ECUs ................................................................. 101</p>
<p>Figure 74: Process flow with virtual ECUs ..................................................................................... 102</p>
<p>Figure 75: Incorporating the XCP Slave in the ECU code .......................................................... 107</p>
<h1 style="page-break-before:always; "></h1>
<p>120</p>
<p>Appendix – XCP Solutions at Vector</p>
<p><b>Appendix – XCP Solutions at Vector</b></p>
<p>Vector made a significant effort in giving shape to the XCP standard. Its extensive know&shy;</p>
<p>how and vast experience were utilized to provide comprehensive XCP support:</p>
<p><b>Tools</b></p>
<p>&gt;</p>
<p>  The primary use area of <b>CANape </b>is in optimal parameterization (calibration) of electronic </p>
<p>control  units  (ECUs).  During  the  system’s  runtime,  you  calibrate  parameter  values  and </p>
<p>simultaneously acquire measured signals. The physical interface between CANape and the </p>
<p>ECU is over XCP (for all standardized transport protocols) or CCP. </p>
<p>&gt;</p>
<p>  Complete  tool  chain  for  generating  and  managing  the  necessary  A2L  description  files </p>
<p>(<b>ASAP2 Tool-Set </b>and <b>CANape </b>with the <b>ASAP2 Editor</b>).</p>
<p>&gt;</p>
<p>  </p>
<p>You use <b>CANoe.XCP </b>to access internal ECU values for testing and analysis tasks.</p>
<p><b>ECU Interfaces</b></p>
<p>The <b>VX1000 </b>measurement and calibration hardware offers the option of equipping ECUs </p>
<p>with an XCP&shy;on&shy;Ethernet interface. This involves connecting a Plug on Device (POD) to the </p>
<p>ECU for direct access to the controller, e.g. over DAP, JTAG, Nexus, etc. The POD transmits </p>
<p>the data to a base module, which operates as an XCP Slave and provides the data to the </p>
<p>XCP Master on the PC over XCP on Ethernet. This makes it unnecessary to have an XCP </p>
<p>Slave in the ECU. The user benefits from a high measurement data throughput rate of up to </p>
<p>50 MByte/s and short measurement intervals of less than 15 µs.</p>
<p><b>Embedded Software</b></p>
<p>Communication modules with separate transport layers for CAN, FlexRay and Ethernet:</p>
<p>&gt;</p>
<p>  <b>XCP Basic </b>– free download at www.vector.com/xcp&shy;driver, only contains basic XCP func&shy;</p>
<p>tions. Configuration of the XCP protocol and modification of the transport layer are per&shy;</p>
<p>formed  manually  in  the  source  code.  You  need  to  integrate  XCP  Basic  in  your  project </p>
<p>yourself.</p>
<p>&gt;</p>
<p>  <b>XCP Professional </b>– contains useful extensions to the ASAM specification and enables tool&shy;</p>
<p>based configuration. Available for Vector CANbedded basic software.</p>
<p>&gt;</p>
<p>  <b>MICROSAR XCP </b>– contains the functional features of XCP Professional and is based on </p>
<p>AUTOSAR specifications. Available for Vector MICROSAR basic software.</p>
<p><b>Services</b></p>
<p>&gt;</p>
<p>  <b>Consultation </b>for using XCP in your projects </p>
<p>&gt;</p>
<p>  <b>Integration </b>of XCP in your ECU</p>
<p><b>Training</b></p>
<p>&gt;</p>
<p>  You can learn about the underlying mechanisms and models of the protocol in the <b>“XCP </b></p>
<p><b>Fundamentals Seminar”</b>.</p>
<p>&gt;</p>
<p>  </p>
<p>In the <b>“CANape with XCP on FlexRay Workshop” </b>you learn about FlexRay fundamentals </p>
<p>and the special aspects of XCP on FlexRay are explained, in particular dynamic bandwidth </p>
<p>management.</p>
<h1 style="page-break-before:always; "></h1>
<p>121</p>
<p>Special XCP Support by CANape</p>
<p><b>Special XCP Support by CANape</b></p>
<p>CANape was the first MCD tool to support the XCP 1.0 specification and was also the first </p>
<p>XCP on FlexRay Master on the market.</p>
<p>A  special  technical  feature  of XCP  on  FlexRay  is  dynamic  bandwidth  management.  Here, </p>
<p>CANape identifies the available bandwidth provided for XCP in the FlexRay ClusterP and it </p>
<p>allocates this bandwidth to the momentary application data traffic dynamically and very </p>
<p>efficiently. The available bandwidth is thereby optimally used for XCP communication. </p>
<p>Moreover,  CANape  has  a  DLL  interface.  It  enables  support  of  XCP  on  any  desired  (user&shy;</p>
<p>defined) transport layer. This lets you integrate any desired test instrumentation or proprie&shy;</p>
<p>tary protocols in CANape. A code generator supports you in creating the XCP&shy;specific share </p>
<p>of such a driver.</p>
<h1 style="page-break-before:always; "></h1>
<p>122</p>
<p>Index</p>
<p><b>Index</b></p>
<p><b>A</b></p>
<p>A2L </p>
<p>9, 10, 25, 35, 40, 42, 56, 57, 62, 63, 68, </p>
<p>71 – 76, 94, 108, 109, 116</p>
<p>Address extension </p>
<p>29, 33, 38, 107, 109</p>
<p>AML </p>
<p>25, 74, 116</p>
<p>ASAM </p>
<p>7 – 9, 60, 116</p>
<p>ASAP2 Tool&shy;Set </p>
<p>76</p>
<p><b>B</b></p>
<p>Bandwith optimization </p>
<p>34</p>
<p>Bus load </p>
<p>34</p>
<p>BYP </p>
<p>116</p>
<p>Bypassing </p>
<p>45, 98, 100</p>
<p><b>C</b></p>
<p>CAN </p>
<p>7, 8, 14, 24, 29, 33, 38, 49, 50, 51, 55, </p>
<p> 75, 116</p>
<p>CAN FD </p>
<p>52</p>
<p>CCP </p>
<p>7, 8, 40, 49, 116</p>
<p>CMD </p>
<p>25, 56, 116</p>
<p>CTO </p>
<p>21, 22, 25, 116</p>
<p>CTR </p>
<p>58, 59, 116</p>
<p>CYCLE_REPETITION </p>
<p>56</p>
<p><b>D</b></p>
<p>DAQ </p>
<p>22, 32 – 45, 65, 67, 77, 99, 100, 106, </p>
<p>108, 116</p>
<p>DAQ_KEY_BYTE </p>
<p>45</p>
<p>DBC </p>
<p>49</p>
<p>Double Pointer Concept </p>
<p>88</p>
<p>DOWNLOAD </p>
<p>30, 31, 66</p>
<p>DTO </p>
<p>21, 22, 33, 37, 116</p>
<p><b>E</b></p>
<p>ECU </p>
<p>9, 74, 98, 99, 116</p>
<p>ECU description file A2L </p>
<p>72 – 77</p>
<p>EEPROM </p>
<p>16, 31, 67</p>
<p>ERR </p>
<p>25, 28, 116</p>
<p>Ethernet </p>
<p>57 – 59</p>
<p>EV </p>
<p>29, 116</p>
<p>Event </p>
<p>35, 38 – 40, 42,65, 67, 77, 108</p>
<p><b>F</b></p>
<p>FIBEX </p>
<p>55 – 57</p>
<p>Flash memory </p>
<p>16, 17, 61 – 64, 67</p>
<p>FLX_CHANNEL </p>
<p>56</p>
<p>FLX_LPDU_ID </p>
<p>56</p>
<p>FLX_SLOT_ID </p>
<p>56</p>
<p>Fullpassing </p>
<p>98</p>
<p><b>G</b></p>
<p>GET_CAL_PAGE </p>
<p>25, 62</p>
<p>GET_DAQ_EVENT_INFO </p>
<p>65, 77</p>
<p>GET_DAQ_LIST_INFO </p>
<p>77</p>
<p>GET_DAQ_PROCESSOR_INFO </p>
<p>45, 65, 77</p>
<p>GET_DAQ_RESOLUTION_INFO </p>
<p>65, 77</p>
<p>Grandmaster clock </p>
<p>47, 48</p>
<p><b>H</b></p>
<p>HIL </p>
<p>92, 95 – 97</p>
<p><b>I</b></p>
<p>IEEE 1588 </p>
<p>47</p>
<p>IF_DATA </p>
<p>25</p>
<p><b>K</b></p>
<p>Commands </p>
<p>25</p>
<p>Compile </p>
<p>76, 80, 82, 94</p>
<p><b>L</b></p>
<p>Linking </p>
<p>80, 94</p>
<p>LPDU </p>
<p>56</p>
<p><b>M</b></p>
<p>Maturity level </p>
<p>31 </p>
<p>MIL </p>
<p>93</p>
<p>MTA </p>
<p>30, 116</p>
<p>Multicast </p>
<p>46, 113</p>
<p><b>O</b></p>
<p>ODT </p>
<p>37 – 41, 43, 44, 65, 77, 116</p>
<p>OFFSET </p>
<p>56</p>
<h1 style="page-break-before:always; "></h1>
<p>123</p>
<p>Index</p>
<p><b>P</b></p>
<p>PAG </p>
<p>116</p>
<p>Page </p>
<p>61 – 63</p>
<p>Page switching </p>
<p>62, 63</p>
<p>Parameter </p>
<p>85</p>
<p>PGM </p>
<p>116</p>
<p>PID </p>
<p>8, 19, 21, 25, 43, 116</p>
<p>Polling </p>
<p>33, 34, 36</p>
<p>PTP </p>
<p>47</p>
<p><b>R</b></p>
<p>RAM </p>
<p>16 – 18, 30, 31, 37, 39, 63, 67, 80, 82, </p>
<p>85, 86, 88</p>
<p>Reboot </p>
<p>32</p>
<p>RES </p>
<p>21, 28, 56, 116</p>
<p><b>S</b></p>
<p>Sector  </p>
<p>61 – 63</p>
<p>Segment </p>
<p>61 – 63</p>
<p>SEGMENT_NUMBER </p>
<p>62</p>
<p>SERV </p>
<p>29, 116</p>
<p>SET_CAL_PAGE </p>
<p>25, 62</p>
<p>SET_MTA </p>
<p>30</p>
<p>SHORT_UPLOAD </p>
<p>30, 33, 66</p>
<p>SIL </p>
<p>92, 94</p>
<p>Single Pointer Concept </p>
<p>86</p>
<p>STIM </p>
<p>33, 42, 43, 45, 65, 77, 100, 116</p>
<p>Stimulation </p>
<p>29, 68, 101</p>
<p><b>T</b></p>
<p>Task </p>
<p>108</p>
<p>TCP/IP </p>
<p>57, 58, 116</p>
<p><b>U</b></p>
<p>UDP/IP </p>
<p>57, 58, 116</p>
<p>USB </p>
<p>60, 116</p>
<p><b>V</b></p>
<p>Virtual ECU </p>
<p>101</p>
<p>Volatile </p>
<p>81, 82</p>
<p>VX1000 </p>
<p>100</p>
<h1 style="page-break-before:always; "></h1>
<p>V3.0 | 12/2016</p>
<p><b>Get More Information</b></p>
<p><b>Visit our Website for:</b></p>
<p>&gt; News</p>
<p>&gt; Products</p>
<p>&gt; Demo Software</p>
<p>&gt; Support</p>
<p>&gt; Trainings Classes</p>
<p>&gt; Addresses </p>
<p><b>www.vector.com</b></p>
</body>
</html>
{% endraw %}